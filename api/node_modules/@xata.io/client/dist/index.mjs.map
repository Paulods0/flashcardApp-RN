{"version":3,"file":"index.mjs","sources":["../src/schema/tracing.ts","../src/util/lang.ts","../src/util/environment.ts","../src/util/fetch.ts","../src/util/uuid.ts","../src/util/sse.ts","../src/version.ts","../src/api/errors.ts","../src/api/fetcher.ts","../src/api/dataPlaneFetcher.ts","../src/api/dataPlaneComponents.ts","../src/api/controlPlaneFetcher.ts","../src/api/controlPlaneComponents.ts","../src/api/components.ts","../src/api/providers.ts","../src/api/client.ts","../src/api/index.ts","../src/plugins.ts","../src/files/transformations.ts","../src/schema/files.ts","../src/schema/filters.ts","../src/schema/json.ts","../src/schema/pagination.ts","../src/schema/query.ts","../src/schema/record.ts","../src/schema/selection.ts","../src/schema/sorting.ts","../src/schema/repository.ts","../src/schema/cache.ts","../src/schema/operators.ts","../src/schema/index.ts","../src/files/index.ts","../src/search/index.ts","../src/sql/parameters.ts","../src/sql/index.ts","../src/transaction/index.ts","../src/client.ts","../src/serializer/index.ts","../src/workers/index.ts","../src/index.ts"],"sourcesContent":["export type AttributeDictionary = Record<string, string | number | boolean | undefined>;\n\nexport type TraceFunction = <T>(\n  name: string,\n  fn: (options: { name?: string; setAttributes: (attrs: AttributeDictionary) => void }) => T,\n  options?: AttributeDictionary\n) => Promise<T>;\n\nexport const defaultTrace: TraceFunction = async <T>(\n  name: string,\n  fn: (options: {\n    name?: string;\n    setAttributes: (attrs: Record<string, string | number | boolean | undefined>) => void;\n  }) => T,\n  _options?: Record<string, any>\n): Promise<T> => {\n  return await fn({\n    name,\n    setAttributes: () => {\n      return;\n    }\n  });\n};\n\nexport const TraceAttributes = {\n  KIND: 'xata.trace.kind',\n\n  VERSION: 'xata.sdk.version',\n\n  TABLE: 'xata.table',\n\n  HTTP_REQUEST_ID: 'http.request_id',\n  HTTP_STATUS_CODE: 'http.status_code',\n  HTTP_HOST: 'http.host',\n  HTTP_SCHEME: 'http.scheme',\n  HTTP_USER_AGENT: 'http.user_agent',\n  HTTP_METHOD: 'http.method',\n  HTTP_URL: 'http.url',\n  HTTP_ROUTE: 'http.route',\n  HTTP_TARGET: 'http.target',\n\n  CLOUDFLARE_RAY_ID: 'cf.ray'\n};\n","function notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function compact<T>(arr: Array<T | null | undefined>): T[] {\n  return arr.filter(notEmpty);\n}\n\nexport function compactObject<T>(obj: Record<string, T | null | undefined>): Record<string, T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, value]) => notEmpty(value))) as Record<string, T>;\n}\n\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function isBlob(value: any): value is Blob {\n  try {\n    return value instanceof Blob;\n  } catch (error) {\n    // Node prior to v18.0.0 doesn't support instanceof Blob and throws a ReferenceError\n    return false;\n  }\n}\n\nexport function isObject(value: any): value is Record<string, unknown> {\n  return (\n    Boolean(value) && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date) && !isBlob(value)\n  );\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function isString(value: any): value is string {\n  return isDefined(value) && typeof value === 'string';\n}\n\nexport function isStringArray(value: any): value is string[] {\n  return isDefined(value) && Array.isArray(value) && value.every(isString);\n}\n\nexport function isNumber(value: any): value is number {\n  return isDefined(value) && typeof value === 'number';\n}\n\nexport function parseNumber(value: any): number | undefined {\n  if (isNumber(value)) {\n    return value;\n  }\n\n  if (isString(value)) {\n    const parsed = Number(value);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n\n  return undefined;\n}\n\nexport function toBase64(value: string): string {\n  try {\n    return btoa(value);\n  } catch (err) {\n    const buf = Buffer; // Avoid \"A Node.js API is used which is not supported in the Edge Runtime\" in Vercel Edge middleware\n    return buf.from(value).toString('base64');\n  }\n}\n\nexport function deepMerge<A extends Record<string, any>, B extends Record<string, any>>(a: A, b: B) {\n  const result: Record<string, any> = { ...a };\n\n  for (const [key, value] of Object.entries(b)) {\n    if (isObject(value) && isObject(result[key])) {\n      result[key] = deepMerge(result[key], value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result as DeepMergeResult<A, B>;\n}\n\ntype DeepMergeResult<A extends Record<string, any>, B extends Record<string, any>> = {\n  [K in keyof A | keyof B]: K extends keyof A\n    ? K extends keyof B\n      ? A[K] extends Record<string, any>\n        ? B[K] extends Record<string, any>\n          ? DeepMergeResult<A[K], B[K]>\n          : B[K]\n        : B[K]\n      : A[K]\n    : K extends keyof B\n    ? B[K]\n    : never;\n};\n\nexport function chunk<T>(array: T[], chunkSize: number): T[][] {\n  const result = [];\n\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n\nexport async function timeout(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function timeoutWithCancel(ms: number) {\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  const promise = new Promise<void>((resolve) => {\n    timeoutId = setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n\n  return {\n    cancel: () => clearTimeout(timeoutId),\n    promise\n  };\n}\n\n/* Map sequentially over T[] with an asynchronous function and return array of mapped values */\nexport function promiseMap<T, S>(inputValues: T[], mapper: (value: T) => Promise<S>): Promise<S[]> {\n  const reducer = (acc$: Promise<S[]>, inputValue: T): Promise<S[]> =>\n    acc$.then((acc: S[]) =>\n      mapper(inputValue).then((result) => {\n        acc.push(result);\n        return acc;\n      })\n    );\n\n  return inputValues.reduce(reducer, Promise.resolve([]));\n}\n","// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n///<reference path=\"../types/global-node.d.ts\"/>\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n///<reference path=\"../types/global-variables.d.ts\"/>\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n///<reference path=\"../types/global-deno.d.ts\"/>\n\nimport { isDefined, isObject } from './lang';\n\ninterface Environment {\n  apiKey: string | undefined;\n  databaseURL: string | undefined;\n  branch: string | undefined;\n  deployPreview: string | undefined;\n  deployPreviewBranch: string | undefined;\n  vercelGitCommitRef: string | undefined;\n  vercelGitRepoOwner: string | undefined;\n}\n\nexport function getEnvironment(): Environment {\n  // Node.js: process.env\n  try {\n    // Not using typeof process.env === 'object' because it's not working in some environments like Bun\n    if (isDefined(process) && isDefined(process.env)) {\n      return {\n        apiKey: process.env.XATA_API_KEY ?? getGlobalApiKey(),\n        databaseURL: process.env.XATA_DATABASE_URL ?? getGlobalDatabaseURL(),\n        branch: process.env.XATA_BRANCH ?? getGlobalBranch(),\n        deployPreview: process.env.XATA_PREVIEW,\n        deployPreviewBranch: process.env.XATA_PREVIEW_BRANCH,\n        vercelGitCommitRef: process.env.VERCEL_GIT_COMMIT_REF,\n        vercelGitRepoOwner: process.env.VERCEL_GIT_REPO_OWNER\n      };\n    }\n  } catch (err) {\n    // Ignore: Should never happen\n  }\n\n  // Deno: Deno.env.get\n  try {\n    if (isObject(Deno) && isObject(Deno.env)) {\n      return {\n        apiKey: Deno.env.get('XATA_API_KEY') ?? getGlobalApiKey(),\n        databaseURL: Deno.env.get('XATA_DATABASE_URL') ?? getGlobalDatabaseURL(),\n        branch: Deno.env.get('XATA_BRANCH') ?? getGlobalBranch(),\n        deployPreview: Deno.env.get('XATA_PREVIEW'),\n        deployPreviewBranch: Deno.env.get('XATA_PREVIEW_BRANCH'),\n        vercelGitCommitRef: Deno.env.get('VERCEL_GIT_COMMIT_REF'),\n        vercelGitRepoOwner: Deno.env.get('VERCEL_GIT_REPO_OWNER')\n      };\n    }\n  } catch (err) {\n    // Ignore: Will fail if not using --allow-env\n  }\n\n  return {\n    apiKey: getGlobalApiKey(),\n    databaseURL: getGlobalDatabaseURL(),\n    branch: getGlobalBranch(),\n    deployPreview: undefined,\n    deployPreviewBranch: undefined,\n    vercelGitCommitRef: undefined,\n    vercelGitRepoOwner: undefined\n  };\n}\n\nexport function getEnableBrowserVariable() {\n  try {\n    if (isObject(process) && isObject(process.env) && process.env.XATA_ENABLE_BROWSER !== undefined) {\n      return process.env.XATA_ENABLE_BROWSER === 'true';\n    }\n  } catch (err) {\n    // Ignore: Should never happen\n  }\n\n  try {\n    if (isObject(Deno) && isObject(Deno.env) && Deno.env.get('XATA_ENABLE_BROWSER') !== undefined) {\n      return Deno.env.get('XATA_ENABLE_BROWSER') === 'true';\n    }\n  } catch (err) {\n    // Ignore: Will fail if not using --allow-env\n  }\n\n  try {\n    return XATA_ENABLE_BROWSER === true || XATA_ENABLE_BROWSER === 'true';\n  } catch (err) {\n    return undefined;\n  }\n}\n\nfunction getGlobalApiKey(): string | undefined {\n  try {\n    return XATA_API_KEY;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nfunction getGlobalDatabaseURL(): string | undefined {\n  try {\n    return XATA_DATABASE_URL;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nfunction getGlobalBranch(): string | undefined {\n  try {\n    return XATA_BRANCH;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport function getDatabaseURL() {\n  try {\n    const { databaseURL } = getEnvironment();\n    return databaseURL;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport function getAPIKey() {\n  try {\n    const { apiKey } = getEnvironment();\n    return apiKey;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport function getBranch() {\n  try {\n    const { branch } = getEnvironment();\n    return branch;\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport function buildPreviewBranchName({ org, branch }: { org: string; branch: string }) {\n  return `preview-${org}-${branch}`;\n}\n\nexport function getPreviewBranch() {\n  try {\n    const { deployPreview, deployPreviewBranch, vercelGitCommitRef, vercelGitRepoOwner } = getEnvironment();\n    if (deployPreviewBranch) return deployPreviewBranch;\n\n    switch (deployPreview) {\n      case 'vercel': {\n        if (!vercelGitCommitRef || !vercelGitRepoOwner) {\n          console.warn('XATA_PREVIEW=vercel but VERCEL_GIT_COMMIT_REF or VERCEL_GIT_REPO_OWNER is not valid');\n          return undefined;\n        }\n\n        return buildPreviewBranchName({ org: vercelGitRepoOwner, branch: vercelGitCommitRef });\n      }\n    }\n\n    return undefined;\n  } catch (err) {\n    return undefined;\n  }\n}\n","import { parseNumber, timeout, timeoutWithCancel } from './lang';\n\nconst REQUEST_TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\nexport type RequestInit = { body?: any; headers?: Record<string, string>; method?: string; signal?: any };\n\nexport type Response = {\n  ok: boolean;\n  status: number;\n  url: string;\n  json(): Promise<any>;\n  text(): Promise<string>;\n  blob(): Promise<Blob>;\n  headers?: {\n    get(name: string): string | null;\n  };\n};\n\n// Typed only the subset of the spec we actually use (to be able to build a simple mock)\nexport type FetchImpl = (url: string, init?: RequestInit) => Promise<Response>;\n\nexport function getFetchImplementation(userFetch?: FetchImpl) {\n  // @ts-ignore - fetch might not be a global\n  const globalFetch = typeof fetch !== 'undefined' ? fetch : undefined;\n  // @ts-ignore - globalThis might not be a global\n  const globalThisFetch = typeof globalThis !== 'undefined' ? globalThis.fetch : undefined;\n  const fetchImpl: FetchImpl | undefined = (userFetch as any) ?? (globalFetch as any) ?? (globalThisFetch as any);\n  if (!fetchImpl) {\n    /** @todo add a link after docs exist */\n    throw new Error(`Couldn't find a global \\`fetch\\`. Pass a fetch implementation explicitly.`);\n  }\n  return fetchImpl;\n}\n\nexport class ApiRequestPool {\n  #fetch?: FetchImpl;\n  #queue: Array<(...params: any[]) => any>;\n  #concurrency: number;\n\n  running: number;\n  started: number;\n\n  constructor(concurrency = 10) {\n    this.#queue = [];\n    this.#concurrency = concurrency;\n\n    this.running = 0;\n    this.started = 0;\n  }\n\n  setFetch(fetch: FetchImpl) {\n    this.#fetch = fetch;\n  }\n\n  getFetch(): FetchImpl {\n    if (!this.#fetch) {\n      throw new Error('Fetch not set');\n    }\n\n    return this.#fetch;\n  }\n\n  request(url: string, options?: RequestInit): Promise<Response> {\n    const start = new Date();\n    const fetchImpl = this.getFetch();\n\n    const runRequest = async (stalled = false): Promise<Response> => {\n      // Some fetch implementations don't timeout and network changes hang the connection\n      const { promise, cancel } = timeoutWithCancel(REQUEST_TIMEOUT);\n      const response = await Promise.race([fetchImpl(url, options), promise.then(() => null)]).finally(cancel);\n      if (!response) {\n        throw new Error('Request timed out');\n      }\n\n      if (response.status === 429) {\n        const rateLimitReset = parseNumber(response.headers?.get('x-ratelimit-reset')) ?? 1;\n\n        await timeout(rateLimitReset * 1000);\n        return await runRequest(true);\n      }\n\n      if (stalled) {\n        const stalledTime = new Date().getTime() - start.getTime();\n        console.warn(`A request to Xata hit branch rate limits, was retried and stalled for ${stalledTime}ms`);\n      }\n\n      return response;\n    };\n\n    return this.#enqueue(async () => {\n      return await runRequest();\n    });\n  }\n  #enqueue<Result>(task: () => Promise<Result>): Promise<Result> {\n    const promise = new Promise<Result>((resolve) => this.#queue.push(resolve))\n      .finally(() => {\n        this.started--;\n        this.running++;\n      })\n      .then(() => task())\n      .finally(() => {\n        this.running--;\n\n        const next = this.#queue.shift();\n        if (next !== undefined) {\n          this.started++;\n          next();\n        }\n      });\n\n    if (this.running + this.started < this.#concurrency) {\n      const next = this.#queue.shift();\n      if (next !== undefined) {\n        this.started++;\n        next();\n      }\n    }\n\n    return promise;\n  }\n}\n","export function generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","/* eslint-disable */\n\n// Code extracted from @microsoft/fetch-event-source (MIT License)\n// Removed browser-specific parts to make it cross-platform\n\nimport { FetchImpl, RequestInit, Response } from './fetch';\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(stream: any, onChunk: (arr: Uint8Array) => void) {\n  const reader = stream.getReader();\n  let result;\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value);\n  }\n}\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined;\n  let position: number; // current read position\n  let fieldLength: number; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true;\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void\n) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + '\\n' + value : value; // otherwise,\n          break;\n        case 'event':\n          message.event = value;\n          break;\n        case 'id':\n          onId((message.id = value));\n          break;\n        case 'retry':\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry));\n          }\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined\n  };\n}\n\nexport const EventStreamContentType = 'text/event-stream';\n\nconst LastEventId = 'last-event-id';\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>;\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void;\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void;\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void;\n\n  /** The Fetch function to use. */\n  fetch?: FetchImpl;\n}\n\nexport function fetchEventSource(\n  input: string,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    fetch: inputFetch,\n    ...rest\n  }: FetchEventSourceInit\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders };\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    let curRequestController: AbortController;\n\n    function dispose() {\n      curRequestController.abort();\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose();\n      resolve(); // don't waste time constructing/logging errors\n    });\n\n    // @ts-expect-error: TS doesn't know about a global fetch\n    const fetchImpl = inputFetch ?? fetch;\n    const onopen = inputOnOpen ?? defaultOnOpen;\n    async function create() {\n      curRequestController = new AbortController();\n      try {\n        const response: any = await fetchImpl(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal\n        });\n\n        await onopen(response);\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // store the id and send it back on the next retry:\n                  headers[LastEventId] = id;\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId];\n                }\n              },\n              (_retry) => {},\n              onmessage\n            )\n          )\n        );\n\n        onclose?.();\n        dispose();\n        resolve();\n      } catch (err) {}\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response: Response) {\n  const contentType = response.headers?.get('content-type');\n  if (!contentType?.startsWith(EventStreamContentType)) {\n    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\n  }\n}\n","export const VERSION = '0.26.9';","import { Responses } from '.';\nimport { isObject, isString } from '../util/lang';\n\n// Polyfill for TypeScript < 4.6\nclass ErrorWithCause extends Error {\n  cause?: Error;\n\n  constructor(message?: string, options?: { cause?: Error }) {\n    // @ts-ignore - Options didn't exist before 4.6\n    super(message, options);\n  }\n}\n\nexport class FetcherError extends ErrorWithCause {\n  public status: number | string;\n  public requestId: string | undefined;\n  public errors: Responses.BulkError['errors'] | undefined;\n\n  constructor(status: number, data?: unknown, requestId?: string) {\n    super(getMessage(data));\n\n    this.status = status;\n    this.errors = isBulkError(data) ? data.errors : [{ message: getMessage(data), status }];\n    this.requestId = requestId;\n\n    if (data instanceof Error) {\n      this.stack = data.stack;\n      this.cause = (data as ErrorWithCause).cause;\n    }\n  }\n\n  toString() {\n    const error = super.toString();\n\n    return `[${this.status}] (${this.requestId ?? 'Unknown'}): ${error}`;\n  }\n}\n\nexport type PossibleErrors =\n  | Responses.BadRequestError\n  | Responses.AuthError\n  | Responses.SimpleError\n  | Responses.BulkError;\n\nfunction isBulkError(error: any): error is Responses.BulkError {\n  return isObject(error) && Array.isArray(error.errors);\n}\n\nfunction isErrorWithMessage(\n  error: any\n): error is Responses.BadRequestError | Responses.SimpleError | Responses.AuthError {\n  return isObject(error) && isString(error.message);\n}\n\nfunction getMessage(data?: unknown): string {\n  if (data instanceof Error) {\n    return data.message;\n  } else if (isString(data)) {\n    return data;\n  } else if (isErrorWithMessage(data)) {\n    return data.message;\n  } else if (isBulkError(data)) {\n    return 'Bulk operation failed';\n  } else {\n    return 'Unexpected error';\n  }\n}\n","import { TraceAttributes, TraceFunction } from '../schema/tracing';\nimport { ApiRequestPool, FetchImpl } from '../util/fetch';\nimport { compact, compactObject, isBlob, isDefined, isObject, isString } from '../util/lang';\nimport { fetchEventSource } from '../util/sse';\nimport { generateUUID } from '../util/uuid';\nimport { VERSION } from '../version';\nimport { FetcherError, PossibleErrors } from './errors';\n\nconst pool = new ApiRequestPool();\n\nconst resolveUrl = (\n  url: string,\n  queryParams: Record<string, any> = {},\n  pathParams: Partial<Record<string, string | number>> = {}\n) => {\n  // Remove nulls and undefineds from query params\n  const cleanQueryParams = Object.entries(queryParams).reduce((acc, [key, value]) => {\n    if (value === undefined || value === null) return acc;\n    return { ...acc, [key]: value };\n  }, {} as Record<string, any>);\n\n  const query = new URLSearchParams(cleanQueryParams).toString();\n  const queryString = query.length > 0 ? `?${query}` : '';\n\n  // We need to encode the path params because they can contain special characters\n  // Special case, `:` does not need to be encoded as we use it as a separator\n  const cleanPathParams = Object.entries(pathParams).reduce((acc, [key, value]) => {\n    return { ...acc, [key]: encodeURIComponent(String(value ?? '')).replace('%3A', ':') };\n  }, {} as Record<string, string>);\n\n  return url.replace(/\\{\\w*\\}/g, (key) => cleanPathParams[key.slice(1, -1)]) + queryString;\n};\n\nexport type WorkspaceApiUrlBuilder = (path: string, pathParams: Partial<Record<string, string | number>>) => string;\n\nexport type FetcherExtraProps = {\n  endpoint: 'controlPlane' | 'dataPlane';\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n  fetchOptions?: Record<string, unknown>;\n  rawResponse?: boolean;\n  headers?: Record<string, unknown>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n} & FetcherExtraProps;\n\nfunction buildBaseUrl({\n  endpoint,\n  path,\n  workspacesApiUrl,\n  apiUrl,\n  pathParams = {}\n}: {\n  endpoint: 'controlPlane' | 'dataPlane';\n  path: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  apiUrl: string;\n  pathParams?: Partial<Record<string, string | number>>;\n}): string {\n  if (endpoint === 'dataPlane') {\n    const url = isString(workspacesApiUrl) ? `${workspacesApiUrl}${path}` : workspacesApiUrl(path, pathParams);\n\n    const urlWithWorkspace = isString(pathParams.workspace)\n      ? url.replace('{workspaceId}', String(pathParams.workspace))\n      : url;\n\n    return isString(pathParams.region)\n      ? urlWithWorkspace.replace('{region}', String(pathParams.region))\n      : urlWithWorkspace;\n  }\n\n  return `${apiUrl}${path}`;\n}\n\n// The host header is needed by Node.js on localhost.\n// It is ignored by fetch() in the frontend\nfunction hostHeader(url: string): { Host?: string } {\n  const pattern = /.*:\\/\\/(?<host>[^/]+).*/;\n  const { groups } = pattern.exec(url) ?? {};\n\n  return groups?.host ? { Host: groups.host } : {};\n}\n\nasync function parseBody<T>(body?: T, headers?: Record<string, unknown>): Promise<any> {\n  if (!isDefined(body)) return undefined;\n\n  // If body is a blob or has a text() method, we don't need to do anything\n  if (isBlob(body) || typeof (body as any).text === 'function') {\n    return body;\n  }\n\n  const { 'Content-Type': contentType } = headers ?? {};\n  if (String(contentType).toLowerCase() === 'application/json' && isObject(body)) {\n    return JSON.stringify(body);\n  }\n\n  return body;\n}\n\nconst defaultClientID = generateUUID();\n\nexport async function fetch<\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | Blob | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>({\n  url: path,\n  method,\n  body,\n  headers: customHeaders,\n  pathParams,\n  queryParams,\n  fetch,\n  apiKey,\n  endpoint,\n  apiUrl,\n  workspacesApiUrl,\n  trace,\n  signal,\n  clientID,\n  sessionID,\n  clientName,\n  xataAgentExtra,\n  fetchOptions = {},\n  rawResponse = false\n}: FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> & FetcherExtraProps): Promise<TData> {\n  pool.setFetch(fetch);\n\n  return await trace(\n    `${method.toUpperCase()} ${path}`,\n    async ({ setAttributes }) => {\n      const baseUrl = buildBaseUrl({ endpoint, path, workspacesApiUrl, pathParams, apiUrl });\n      const fullUrl = resolveUrl(baseUrl, queryParams, pathParams);\n\n      // Node.js on localhost won't resolve localhost subdomains unless mapped in /etc/hosts\n      // So, instead, we use localhost without subdomains, but will add a Host header\n      const url = fullUrl.includes('localhost') ? fullUrl.replace(/^[^.]+\\./, 'http://') : fullUrl;\n      setAttributes({\n        [TraceAttributes.HTTP_URL]: url,\n        [TraceAttributes.HTTP_TARGET]: resolveUrl(path, queryParams, pathParams)\n      });\n\n      const xataAgent = compact([\n        ['client', 'TS_SDK'],\n        ['version', VERSION],\n        isDefined(clientName) ? ['service', clientName] : undefined,\n        ...Object.entries(xataAgentExtra ?? {})\n      ])\n        .map(([key, value]) => `${key}=${value}`)\n        .join('; ');\n\n      const headers = compactObject({\n        'Accept-Encoding': 'identity',\n        'Content-Type': 'application/json',\n        'X-Xata-Client-ID': clientID ?? defaultClientID,\n        'X-Xata-Session-ID': sessionID ?? generateUUID(),\n        'X-Xata-Agent': xataAgent,\n        ...customHeaders,\n        ...hostHeader(fullUrl),\n        Authorization: `Bearer ${apiKey}`\n      });\n\n      const response = await pool.request(url, {\n        ...fetchOptions,\n        method: method.toUpperCase(),\n        body: await parseBody(body, headers),\n        headers,\n        signal\n      });\n\n      const { host, protocol } = parseUrl(response.url);\n      const requestId = response.headers?.get('x-request-id') ?? undefined;\n      setAttributes({\n        [TraceAttributes.KIND]: 'http',\n        [TraceAttributes.HTTP_REQUEST_ID]: requestId,\n        [TraceAttributes.HTTP_STATUS_CODE]: response.status,\n        [TraceAttributes.HTTP_HOST]: host,\n        [TraceAttributes.HTTP_SCHEME]: protocol?.replace(':', ''),\n        [TraceAttributes.CLOUDFLARE_RAY_ID]: response.headers?.get('cf-ray') ?? undefined\n      });\n\n      const message = response.headers?.get('x-xata-message');\n      if (message) console.warn(message);\n\n      // No content\n      if (response.status === 204) {\n        return {} as unknown as TData;\n      }\n\n      // Rate limit exceeded\n      if (response.status === 429) {\n        throw new FetcherError(response.status, 'Rate limit exceeded', requestId);\n      }\n\n      try {\n        const jsonResponse = rawResponse ? await response.blob() : await response.json();\n\n        if (response.ok) {\n          return jsonResponse;\n        }\n\n        throw new FetcherError(response.status, jsonResponse as TError['payload'], requestId);\n      } catch (error) {\n        throw new FetcherError(response.status, error, requestId);\n      }\n    },\n    { [TraceAttributes.HTTP_METHOD]: method.toUpperCase(), [TraceAttributes.HTTP_ROUTE]: path }\n  );\n}\n\nexport function fetchSSERequest<\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>({\n  url: path,\n  method,\n  body,\n  headers: customHeaders,\n  pathParams,\n  queryParams,\n  fetch,\n  apiKey,\n  endpoint,\n  apiUrl,\n  workspacesApiUrl,\n  onMessage,\n  onError,\n  onClose,\n  signal,\n  clientID,\n  sessionID,\n  clientName,\n  xataAgentExtra\n}: FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> &\n  FetcherExtraProps & {\n    onMessage?: (message: TData) => void;\n    onError?: (error: TError) => void;\n    onClose?: () => void;\n  }): void {\n  const baseUrl = buildBaseUrl({ endpoint, path, workspacesApiUrl, pathParams, apiUrl });\n  const fullUrl = resolveUrl(baseUrl, queryParams, pathParams);\n\n  // Node.js on localhost won't resolve localhost subdomains unless mapped in /etc/hosts\n  // So, instead, we use localhost without subdomains, but will add a Host header\n  const url = fullUrl.includes('localhost') ? fullUrl.replace(/^[^.]+\\./, 'http://') : fullUrl;\n\n  void fetchEventSource(url, {\n    method,\n    body: JSON.stringify(body),\n    fetch,\n    signal,\n    headers: {\n      'X-Xata-Client-ID': clientID ?? defaultClientID,\n      'X-Xata-Session-ID': sessionID ?? generateUUID(),\n      'X-Xata-Agent': compact([\n        ['client', 'TS_SDK'],\n        ['version', VERSION],\n        isDefined(clientName) ? ['service', clientName] : undefined,\n        ...Object.entries(xataAgentExtra ?? {})\n      ])\n        .map(([key, value]) => `${key}=${value}`)\n        .join('; '),\n      ...customHeaders,\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    onmessage(ev) {\n      onMessage?.(JSON.parse(ev.data));\n    },\n    onerror(ev) {\n      onError?.(JSON.parse(ev.data));\n    },\n    onclose() {\n      onClose?.();\n    }\n  });\n}\n\nfunction parseUrl(url: string): { host?: string; protocol?: string } {\n  try {\n    const { host, protocol } = new URL(url);\n\n    return { host, protocol };\n  } catch (error) {\n    return {};\n  }\n}\n","import { TraceFunction } from '../schema/tracing';\nimport { FetchImpl } from '../util/fetch';\nimport { PossibleErrors } from './errors';\nimport { fetch, WorkspaceApiUrlBuilder } from './fetcher';\n\nexport type DataPlaneFetcherExtraProps = {\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n  rawResponse?: boolean;\n  headers?: Record<string, unknown>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type DataPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n  signal?: AbortSignal;\n} & DataPlaneFetcherExtraProps;\n\nexport const dataPlaneFetch = async <\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | Blob | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>(\n  options: DataPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams>\n): Promise<TData> =>\n  fetch<TData, TError, TBody, THeaders, TQueryParams, TPathParams>({ ...options, endpoint: 'dataPlane' });\n","/**\n * Generated by @openapi-codegen\n *\n * @version 1.0\n */\nimport type * as Fetcher from './dataPlaneFetcher';\nimport { dataPlaneFetch, DataPlaneFetcherExtraProps } from './dataPlaneFetcher';\nimport type * as Schemas from './dataPlaneSchemas';\nimport type * as Responses from './dataPlaneResponses';\n\nexport type GetBranchListPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchListVariables = {\n  pathParams: GetBranchListPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * List all available Branches\n */\nexport const getBranchList = (variables: GetBranchListVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.ListBranchesResponse, GetBranchListError, undefined, {}, {}, GetBranchListPathParams>({\n    url: '/dbs/{dbName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchDetailsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchDetailsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchDetailsVariables = {\n  pathParams: GetBranchDetailsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchDetails = (variables: GetBranchDetailsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.DBBranch, GetBranchDetailsError, undefined, {}, {}, GetBranchDetailsPathParams>({\n    url: '/db/{dbBranchName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateBranchQueryParams = {\n  /**\n   * Name of source branch to branch the new schema from\n   */\n  from?: string;\n};\n\nexport type CreateBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateBranchResponse = {\n  /**\n   * @minLength 1\n   */\n  databaseName: string;\n  branchName: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateBranchRequestBody = {\n  /**\n   * Select the branch to fork from. Defaults to 'main'\n   */\n  from?: string;\n  metadata?: Schemas.BranchMetadata;\n};\n\nexport type CreateBranchVariables = {\n  body?: CreateBranchRequestBody;\n  pathParams: CreateBranchPathParams;\n  queryParams?: CreateBranchQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const createBranch = (variables: CreateBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    CreateBranchResponse,\n    CreateBranchError,\n    CreateBranchRequestBody,\n    {},\n    CreateBranchQueryParams,\n    CreateBranchPathParams\n  >({ url: '/db/{dbBranchName}', method: 'put', ...variables, signal });\n\nexport type DeleteBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteBranchResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteBranchVariables = {\n  pathParams: DeleteBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Delete the branch in the database and all its resources\n */\nexport const deleteBranch = (variables: DeleteBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<DeleteBranchResponse, DeleteBranchError, undefined, {}, {}, DeleteBranchPathParams>({\n    url: '/db/{dbBranchName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetSchemaResponse = {\n  schema: Record<string, any>;\n};\n\nexport type GetSchemaVariables = {\n  pathParams: GetSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getSchema = (variables: GetSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetSchemaResponse, GetSchemaError, undefined, {}, {}, GetSchemaPathParams>({\n    url: '/db/{dbBranchName}/schema',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CopyBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CopyBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CopyBranchRequestBody = {\n  destinationBranch: string;\n  limit?: number;\n};\n\nexport type CopyBranchVariables = {\n  body: CopyBranchRequestBody;\n  pathParams: CopyBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Create a copy of the branch\n */\nexport const copyBranch = (variables: CopyBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchWithCopyID, CopyBranchError, CopyBranchRequestBody, {}, {}, CopyBranchPathParams>({\n    url: '/db/{dbBranchName}/copy',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type UpdateBranchMetadataPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateBranchMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateBranchMetadataVariables = {\n  body?: Schemas.BranchMetadata;\n  pathParams: UpdateBranchMetadataPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update the branch metadata\n */\nexport const updateBranchMetadata = (variables: UpdateBranchMetadataVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<undefined, UpdateBranchMetadataError, Schemas.BranchMetadata, {}, {}, UpdateBranchMetadataPathParams>({\n    url: '/db/{dbBranchName}/metadata',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMetadataPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMetadataVariables = {\n  pathParams: GetBranchMetadataPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchMetadata = (variables: GetBranchMetadataVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchMetadata, GetBranchMetadataError, undefined, {}, {}, GetBranchMetadataPathParams>({\n    url: '/db/{dbBranchName}/metadata',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchStatsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchStatsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchStatsResponse = {\n  timestamp: string;\n  interval: string;\n  resolution: string;\n  numberOfRecords?: Schemas.MetricsDatapoint[];\n  writesOverTime?: Schemas.MetricsDatapoint[];\n  readsOverTime?: Schemas.MetricsDatapoint[];\n  readLatency?: Schemas.MetricsLatency;\n  writeLatency?: Schemas.MetricsLatency;\n  warning?: string;\n};\n\nexport type GetBranchStatsVariables = {\n  pathParams: GetBranchStatsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get branch usage metrics.\n */\nexport const getBranchStats = (variables: GetBranchStatsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetBranchStatsResponse, GetBranchStatsError, undefined, {}, {}, GetBranchStatsPathParams>({\n    url: '/db/{dbBranchName}/stats',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetGitBranchesMappingPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetGitBranchesMappingError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetGitBranchesMappingVariables = {\n  pathParams: GetGitBranchesMappingPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Lists all the git branches in the mapping, and their associated Xata branches.\n *\n * Example response:\n *\n * ```json\n * {\n *   \"mappings\": [\n *       {\n *         \"gitBranch\": \"main\",\n *         \"xataBranch\": \"main\"\n *       },\n *       {\n *         \"gitBranch\": \"gitBranch1\",\n *         \"xataBranch\": \"xataBranch1\"\n *       }\n *       {\n *         \"gitBranch\": \"xataBranch2\",\n *         \"xataBranch\": \"xataBranch2\"\n *       }\n *   ]\n * }\n * ```\n */\nexport const getGitBranchesMapping = (variables: GetGitBranchesMappingVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ListGitBranchesResponse,\n    GetGitBranchesMappingError,\n    undefined,\n    {},\n    {},\n    GetGitBranchesMappingPathParams\n  >({ url: '/dbs/{dbName}/gitBranches', method: 'get', ...variables, signal });\n\nexport type AddGitBranchesEntryPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type AddGitBranchesEntryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type AddGitBranchesEntryResponse = {\n  /**\n   * Warning message\n   */\n  warning?: string;\n};\n\nexport type AddGitBranchesEntryRequestBody = {\n  /**\n   * The name of the Git branch.\n   */\n  gitBranch: string;\n  /**\n   * The name of the Xata branch.\n   */\n  xataBranch: Schemas.BranchName;\n};\n\nexport type AddGitBranchesEntryVariables = {\n  body: AddGitBranchesEntryRequestBody;\n  pathParams: AddGitBranchesEntryPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.\n *\n * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.\n *\n * Example request:\n *\n * ```json\n * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches\n * {\n *   \"gitBranch\": \"fix/bug123\",\n *   \"xataBranch\": \"fix_bug\"\n * }\n * ```\n */\nexport const addGitBranchesEntry = (variables: AddGitBranchesEntryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    AddGitBranchesEntryResponse,\n    AddGitBranchesEntryError,\n    AddGitBranchesEntryRequestBody,\n    {},\n    {},\n    AddGitBranchesEntryPathParams\n  >({ url: '/dbs/{dbName}/gitBranches', method: 'post', ...variables, signal });\n\nexport type RemoveGitBranchesEntryPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type RemoveGitBranchesEntryQueryParams = {\n  /**\n   * The Git Branch to remove from the mapping\n   */\n  gitBranch: string;\n};\n\nexport type RemoveGitBranchesEntryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type RemoveGitBranchesEntryVariables = {\n  pathParams: RemoveGitBranchesEntryPathParams;\n  queryParams: RemoveGitBranchesEntryQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.\n *\n * Example request:\n *\n * ```json\n * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123\n * ```\n */\nexport const removeGitBranchesEntry = (variables: RemoveGitBranchesEntryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    undefined,\n    RemoveGitBranchesEntryError,\n    undefined,\n    {},\n    RemoveGitBranchesEntryQueryParams,\n    RemoveGitBranchesEntryPathParams\n  >({ url: '/dbs/{dbName}/gitBranches', method: 'delete', ...variables, signal });\n\nexport type ResolveBranchPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type ResolveBranchQueryParams = {\n  /**\n   * The Git Branch\n   */\n  gitBranch?: string;\n  /**\n   * Default branch to fallback to\n   */\n  fallbackBranch?: string;\n};\n\nexport type ResolveBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ResolveBranchResponse = {\n  branch: string;\n  reason: {\n    code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';\n    message: string;\n  };\n};\n\nexport type ResolveBranchVariables = {\n  pathParams: ResolveBranchPathParams;\n  queryParams?: ResolveBranchQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * In order to resolve the database branch, the following algorithm is used:\n * * if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned\n * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it\n * * else, if `fallbackBranch` is provided and a branch with that name exists, return it\n * * else, return the default branch of the DB (`main` or the first branch)\n *\n * Example call:\n *\n * ```json\n * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg\n * ```\n *\n * Example response:\n *\n * ```json\n * {\n *   \"branch\": \"main\",\n *   \"reason\": {\n *     \"code\": \"DEFAULT_BRANCH\",\n *     \"message\": \"Default branch for this database (main)\"\n *   }\n * }\n * ```\n */\nexport const resolveBranch = (variables: ResolveBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    ResolveBranchResponse,\n    ResolveBranchError,\n    undefined,\n    {},\n    ResolveBranchQueryParams,\n    ResolveBranchPathParams\n  >({ url: '/dbs/{dbName}/resolveBranch', method: 'get', ...variables, signal });\n\nexport type GetBranchMigrationHistoryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMigrationHistoryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMigrationHistoryResponse = {\n  startedFrom?: Schemas.StartedFromMetadata;\n  migrations?: Schemas.BranchMigration[];\n};\n\nexport type GetBranchMigrationHistoryRequestBody = {\n  limit?: number;\n  startFrom?: string;\n};\n\nexport type GetBranchMigrationHistoryVariables = {\n  body?: GetBranchMigrationHistoryRequestBody;\n  pathParams: GetBranchMigrationHistoryPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchMigrationHistory = (variables: GetBranchMigrationHistoryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetBranchMigrationHistoryResponse,\n    GetBranchMigrationHistoryError,\n    GetBranchMigrationHistoryRequestBody,\n    {},\n    {},\n    GetBranchMigrationHistoryPathParams\n  >({ url: '/db/{dbBranchName}/migrations', method: 'get', ...variables, signal });\n\nexport type GetBranchMigrationPlanPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMigrationPlanError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMigrationPlanVariables = {\n  body: Schemas.Schema;\n  pathParams: GetBranchMigrationPlanPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Compute a migration plan from a target schema the branch should be migrated too.\n */\nexport const getBranchMigrationPlan = (variables: GetBranchMigrationPlanVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.BranchMigrationPlan,\n    GetBranchMigrationPlanError,\n    Schemas.Schema,\n    {},\n    {},\n    GetBranchMigrationPlanPathParams\n  >({ url: '/db/{dbBranchName}/migrations/plan', method: 'post', ...variables, signal });\n\nexport type ExecuteBranchMigrationPlanPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type ExecuteBranchMigrationPlanError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ExecuteBranchMigrationPlanRequestBody = {\n  version: number;\n  migration: Schemas.BranchMigration;\n};\n\nexport type ExecuteBranchMigrationPlanVariables = {\n  body: ExecuteBranchMigrationPlanRequestBody;\n  pathParams: ExecuteBranchMigrationPlanPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Apply a migration plan to the branch\n */\nexport const executeBranchMigrationPlan = (variables: ExecuteBranchMigrationPlanVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    ExecuteBranchMigrationPlanError,\n    ExecuteBranchMigrationPlanRequestBody,\n    {},\n    {},\n    ExecuteBranchMigrationPlanPathParams\n  >({ url: '/db/{dbBranchName}/migrations/execute', method: 'post', ...variables, signal });\n\nexport type QueryMigrationRequestsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type QueryMigrationRequestsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type QueryMigrationRequestsResponse = {\n  migrationRequests: Schemas.MigrationRequest[];\n  meta: Schemas.RecordsMetadata;\n};\n\nexport type QueryMigrationRequestsRequestBody = {\n  filter?: Schemas.FilterExpression;\n  sort?: Schemas.SortExpression;\n  page?: Schemas.PageConfig;\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type QueryMigrationRequestsVariables = {\n  body?: QueryMigrationRequestsRequestBody;\n  pathParams: QueryMigrationRequestsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const queryMigrationRequests = (variables: QueryMigrationRequestsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    QueryMigrationRequestsResponse,\n    QueryMigrationRequestsError,\n    QueryMigrationRequestsRequestBody,\n    {},\n    {},\n    QueryMigrationRequestsPathParams\n  >({ url: '/dbs/{dbName}/migrations/query', method: 'post', ...variables, signal });\n\nexport type CreateMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateMigrationRequestResponse = {\n  number: number;\n};\n\nexport type CreateMigrationRequestRequestBody = {\n  /**\n   * The source branch.\n   */\n  source: string;\n  /**\n   * The target branch.\n   */\n  target: string;\n  /**\n   * The title.\n   */\n  title: string;\n  /**\n   * Optional migration request description.\n   */\n  body?: string;\n};\n\nexport type CreateMigrationRequestVariables = {\n  body: CreateMigrationRequestRequestBody;\n  pathParams: CreateMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const createMigrationRequest = (variables: CreateMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    CreateMigrationRequestResponse,\n    CreateMigrationRequestError,\n    CreateMigrationRequestRequestBody,\n    {},\n    {},\n    CreateMigrationRequestPathParams\n  >({ url: '/dbs/{dbName}/migrations', method: 'post', ...variables, signal });\n\nexport type GetMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationRequestVariables = {\n  pathParams: GetMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationRequest = (variables: GetMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.MigrationRequest, GetMigrationRequestError, undefined, {}, {}, GetMigrationRequestPathParams>({\n    url: '/dbs/{dbName}/migrations/{mrNumber}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateMigrationRequestRequestBody = {\n  /**\n   * New migration request title.\n   */\n  title?: string;\n  /**\n   * New migration request description.\n   */\n  body?: string;\n  /**\n   * Change the migration request status.\n   */\n  status?: 'open' | 'closed';\n};\n\nexport type UpdateMigrationRequestVariables = {\n  body?: UpdateMigrationRequestRequestBody;\n  pathParams: UpdateMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateMigrationRequest = (variables: UpdateMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    undefined,\n    UpdateMigrationRequestError,\n    UpdateMigrationRequestRequestBody,\n    {},\n    {},\n    UpdateMigrationRequestPathParams\n  >({ url: '/dbs/{dbName}/migrations/{mrNumber}', method: 'patch', ...variables, signal });\n\nexport type ListMigrationRequestsCommitsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type ListMigrationRequestsCommitsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ListMigrationRequestsCommitsResponse = {\n  meta: {\n    /**\n     * last record id\n     */\n    cursor: string;\n    /**\n     * true if more records can be fetch\n     */\n    more: boolean;\n  };\n  logs: Schemas.Commit[];\n};\n\nexport type ListMigrationRequestsCommitsRequestBody = {\n  page?: {\n    /**\n     * Query the next page that follow the cursor.\n     */\n    after?: string;\n    /**\n     * Query the previous page before the cursor.\n     */\n    before?: string;\n    /**\n     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.\n     *\n     * @default 20\n     */\n    size?: number;\n  };\n};\n\nexport type ListMigrationRequestsCommitsVariables = {\n  body?: ListMigrationRequestsCommitsRequestBody;\n  pathParams: ListMigrationRequestsCommitsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const listMigrationRequestsCommits = (variables: ListMigrationRequestsCommitsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    ListMigrationRequestsCommitsResponse,\n    ListMigrationRequestsCommitsError,\n    ListMigrationRequestsCommitsRequestBody,\n    {},\n    {},\n    ListMigrationRequestsCommitsPathParams\n  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/commits', method: 'post', ...variables, signal });\n\nexport type CompareMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareMigrationRequestVariables = {\n  pathParams: CompareMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareMigrationRequest = (variables: CompareMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareMigrationRequestError,\n    undefined,\n    {},\n    {},\n    CompareMigrationRequestPathParams\n  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/compare', method: 'post', ...variables, signal });\n\nexport type GetMigrationRequestIsMergedPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationRequestIsMergedError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationRequestIsMergedResponse = {\n  merged?: boolean;\n};\n\nexport type GetMigrationRequestIsMergedVariables = {\n  pathParams: GetMigrationRequestIsMergedPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationRequestIsMerged = (variables: GetMigrationRequestIsMergedVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetMigrationRequestIsMergedResponse,\n    GetMigrationRequestIsMergedError,\n    undefined,\n    {},\n    {},\n    GetMigrationRequestIsMergedPathParams\n  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/merge', method: 'get', ...variables, signal });\n\nexport type MergeMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type MergeMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type MergeMigrationRequestVariables = {\n  pathParams: MergeMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const mergeMigrationRequest = (variables: MergeMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchOp, MergeMigrationRequestError, undefined, {}, {}, MergeMigrationRequestPathParams>({\n    url: '/dbs/{dbName}/migrations/{mrNumber}/merge',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchSchemaHistoryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchSchemaHistoryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchSchemaHistoryResponse = {\n  meta: {\n    /**\n     * last record id\n     */\n    cursor: string;\n    /**\n     * true if more records can be fetch\n     */\n    more: boolean;\n  };\n  logs: Schemas.Commit[];\n};\n\nexport type GetBranchSchemaHistoryRequestBody = {\n  page?: {\n    /**\n     * Query the next page that follow the cursor.\n     */\n    after?: string;\n    /**\n     * Query the previous page before the cursor.\n     */\n    before?: string;\n    /**\n     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.\n     *\n     * @default 20\n     */\n    size?: number;\n  };\n  /**\n   * Report only migrations that have been added since the given Migration ID.\n   */\n  since?: string;\n};\n\nexport type GetBranchSchemaHistoryVariables = {\n  body?: GetBranchSchemaHistoryRequestBody;\n  pathParams: GetBranchSchemaHistoryPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchSchemaHistory = (variables: GetBranchSchemaHistoryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetBranchSchemaHistoryResponse,\n    GetBranchSchemaHistoryError,\n    GetBranchSchemaHistoryRequestBody,\n    {},\n    {},\n    GetBranchSchemaHistoryPathParams\n  >({ url: '/db/{dbBranchName}/schema/history', method: 'post', ...variables, signal });\n\nexport type CompareBranchWithUserSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareBranchWithUserSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareBranchWithUserSchemaRequestBody = {\n  schema: Schemas.Schema;\n  schemaOperations?: Schemas.MigrationOp[];\n  branchOperations?: Schemas.MigrationOp[];\n};\n\nexport type CompareBranchWithUserSchemaVariables = {\n  body: CompareBranchWithUserSchemaRequestBody;\n  pathParams: CompareBranchWithUserSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareBranchWithUserSchema = (variables: CompareBranchWithUserSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareBranchWithUserSchemaError,\n    CompareBranchWithUserSchemaRequestBody,\n    {},\n    {},\n    CompareBranchWithUserSchemaPathParams\n  >({ url: '/db/{dbBranchName}/schema/compare', method: 'post', ...variables, signal });\n\nexport type CompareBranchSchemasPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Database Name\n   */\n  branchName: Schemas.BranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareBranchSchemasError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareBranchSchemasRequestBody = {\n  sourceBranchOperations?: Schemas.MigrationOp[];\n  targetBranchOperations?: Schemas.MigrationOp[];\n};\n\nexport type CompareBranchSchemasVariables = {\n  body: CompareBranchSchemasRequestBody;\n  pathParams: CompareBranchSchemasPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareBranchSchemas = (variables: CompareBranchSchemasVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareBranchSchemasError,\n    CompareBranchSchemasRequestBody,\n    {},\n    {},\n    CompareBranchSchemasPathParams\n  >({ url: '/db/{dbBranchName}/schema/compare/{branchName}', method: 'post', ...variables, signal });\n\nexport type UpdateBranchSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateBranchSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateBranchSchemaVariables = {\n  body: Schemas.Migration;\n  pathParams: UpdateBranchSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateBranchSchema = (variables: UpdateBranchSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateBranchSchemaError,\n    Schemas.Migration,\n    {},\n    {},\n    UpdateBranchSchemaPathParams\n  >({ url: '/db/{dbBranchName}/schema/update', method: 'post', ...variables, signal });\n\nexport type PreviewBranchSchemaEditPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type PreviewBranchSchemaEditError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PreviewBranchSchemaEditResponse = {\n  original: Schemas.Schema;\n  updated: Schemas.Schema;\n};\n\nexport type PreviewBranchSchemaEditRequestBody = {\n  edits?: Schemas.SchemaEditScript;\n};\n\nexport type PreviewBranchSchemaEditVariables = {\n  body?: PreviewBranchSchemaEditRequestBody;\n  pathParams: PreviewBranchSchemaEditPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const previewBranchSchemaEdit = (variables: PreviewBranchSchemaEditVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    PreviewBranchSchemaEditResponse,\n    PreviewBranchSchemaEditError,\n    PreviewBranchSchemaEditRequestBody,\n    {},\n    {},\n    PreviewBranchSchemaEditPathParams\n  >({ url: '/db/{dbBranchName}/schema/preview', method: 'post', ...variables, signal });\n\nexport type ApplyBranchSchemaEditPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type ApplyBranchSchemaEditError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ApplyBranchSchemaEditRequestBody = {\n  edits: Schemas.SchemaEditScript;\n};\n\nexport type ApplyBranchSchemaEditVariables = {\n  body: ApplyBranchSchemaEditRequestBody;\n  pathParams: ApplyBranchSchemaEditPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const applyBranchSchemaEdit = (variables: ApplyBranchSchemaEditVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    ApplyBranchSchemaEditError,\n    ApplyBranchSchemaEditRequestBody,\n    {},\n    {},\n    ApplyBranchSchemaEditPathParams\n  >({ url: '/db/{dbBranchName}/schema/apply', method: 'post', ...variables, signal });\n\nexport type PushBranchMigrationsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type PushBranchMigrationsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PushBranchMigrationsRequestBody = {\n  migrations: Schemas.MigrationObject[];\n};\n\nexport type PushBranchMigrationsVariables = {\n  body: PushBranchMigrationsRequestBody;\n  pathParams: PushBranchMigrationsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * The `schema/push` API accepts a list of migrations to be applied to the\n * current branch. A list of applicable migrations can be fetched using\n * the `schema/history` API from another branch or database.\n *\n * The most recent migration must be part of the list or referenced (via\n * `parentID`) by the first migration in the list of migrations to be pushed.\n *\n * Each migration in the list has an `id`, `parentID`, and `checksum`. The\n * checksum for migrations are generated and verified by xata. The\n * operation fails if any migration in the list has an invalid checksum.\n */\nexport const pushBranchMigrations = (variables: PushBranchMigrationsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    PushBranchMigrationsError,\n    PushBranchMigrationsRequestBody,\n    {},\n    {},\n    PushBranchMigrationsPathParams\n  >({ url: '/db/{dbBranchName}/schema/push', method: 'post', ...variables, signal });\n\nexport type CreateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateTableResponse = {\n  branchName: string;\n  /**\n   * @minLength 1\n   */\n  tableName: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateTableVariables = {\n  pathParams: CreateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Creates a new table with the given name. Returns 422 if a table with the same name already exists.\n */\nexport const createTable = (variables: CreateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<CreateTableResponse, CreateTableError, undefined, {}, {}, CreateTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type DeleteTableResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteTableVariables = {\n  pathParams: DeleteTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes the table with the given name.\n */\nexport const deleteTable = (variables: DeleteTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<DeleteTableResponse, DeleteTableError, undefined, {}, {}, DeleteTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type UpdateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateTableRequestBody = {\n  /**\n   * @minLength 1\n   */\n  name: string;\n};\n\nexport type UpdateTableVariables = {\n  body: UpdateTableRequestBody;\n  pathParams: UpdateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.\n *\n * In the example below, we rename a table from users to people:\n *\n * ```json\n * // PATCH /db/test:main/tables/users\n *\n * {\n *   \"name\": \"people\"\n * }\n * ```\n */\nexport const updateTable = (variables: UpdateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateTableError,\n    UpdateTableRequestBody,\n    {},\n    {},\n    UpdateTablePathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}', method: 'patch', ...variables, signal });\n\nexport type GetTableSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetTableSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTableSchemaResponse = {\n  columns: Schemas.Column[];\n};\n\nexport type GetTableSchemaVariables = {\n  pathParams: GetTableSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getTableSchema = (variables: GetTableSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetTableSchemaResponse, GetTableSchemaError, undefined, {}, {}, GetTableSchemaPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/schema',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type SetTableSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SetTableSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SetTableSchemaRequestBody = {\n  columns: Schemas.Column[];\n};\n\nexport type SetTableSchemaVariables = {\n  body: SetTableSchemaRequestBody;\n  pathParams: SetTableSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const setTableSchema = (variables: SetTableSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    SetTableSchemaError,\n    SetTableSchemaRequestBody,\n    {},\n    {},\n    SetTableSchemaPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/schema', method: 'put', ...variables, signal });\n\nexport type GetTableColumnsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetTableColumnsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTableColumnsResponse = {\n  columns: Schemas.Column[];\n};\n\nexport type GetTableColumnsVariables = {\n  pathParams: GetTableColumnsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their\n * full dot-separated path (flattened).\n */\nexport const getTableColumns = (variables: GetTableColumnsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetTableColumnsResponse, GetTableColumnsError, undefined, {}, {}, GetTableColumnsPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type AddTableColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AddTableColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AddTableColumnVariables = {\n  body: Schemas.Column;\n  pathParams: AddTableColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adds a new column to the table. The body of the request should contain the column definition.\n */\nexport const addTableColumn = (variables: AddTableColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SchemaUpdateResponse, AddTableColumnError, Schemas.Column, {}, {}, AddTableColumnPathParams>(\n    { url: '/db/{dbBranchName}/tables/{tableName}/columns', method: 'post', ...variables, signal }\n  );\n\nexport type GetColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetColumnVariables = {\n  pathParams: GetColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get the definition of a single column.\n */\nexport const getColumn = (variables: GetColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.Column, GetColumnError, undefined, {}, {}, GetColumnPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateColumnRequestBody = {\n  /**\n   * @minLength 1\n   */\n  name: string;\n};\n\nexport type UpdateColumnVariables = {\n  body: UpdateColumnRequestBody;\n  pathParams: UpdateColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update column with partial data. Can be used for renaming the column by providing a new \"name\" field.\n */\nexport const updateColumn = (variables: UpdateColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateColumnError,\n    UpdateColumnRequestBody,\n    {},\n    {},\n    UpdateColumnPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}', method: 'patch', ...variables, signal });\n\nexport type DeleteColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteColumnVariables = {\n  pathParams: DeleteColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes the specified column.\n */\nexport const deleteColumn = (variables: DeleteColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SchemaUpdateResponse, DeleteColumnError, undefined, {}, {}, DeleteColumnPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type BranchTransactionPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type BranchTransactionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Schemas.TransactionFailure;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n>;\n\nexport type BranchTransactionRequestBody = {\n  operations: Schemas.TransactionOperation[];\n};\n\nexport type BranchTransactionVariables = {\n  body: BranchTransactionRequestBody;\n  pathParams: BranchTransactionPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const branchTransaction = (variables: BranchTransactionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.TransactionSuccess,\n    BranchTransactionError,\n    BranchTransactionRequestBody,\n    {},\n    {},\n    BranchTransactionPathParams\n  >({ url: '/db/{dbBranchName}/transaction', method: 'post', ...variables, signal });\n\nexport type InsertRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type InsertRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type InsertRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InsertRecordVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: InsertRecordPathParams;\n  queryParams?: InsertRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Insert a new Record into the Table\n */\nexport const insertRecord = (variables: InsertRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    InsertRecordError,\n    Schemas.DataInputRecord,\n    {},\n    InsertRecordQueryParams,\n    InsertRecordPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/data', method: 'post', ...variables, signal });\n\nexport type GetFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetFileItemVariables = {\n  pathParams: GetFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves file content from an array by file ID\n */\nexport const getFileItem = (variables: GetFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, GetFileItemError, undefined, {}, {}, GetFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type PutFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type PutFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PutFileItemVariables = {\n  body?: Blob;\n  pathParams: PutFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Uploads the file content to an array given the file ID\n */\nexport const putFileItem = (variables: PutFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, PutFileItemError, Blob, {}, {}, PutFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteFileItemVariables = {\n  pathParams: DeleteFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes an item from an file array column given the file ID\n */\nexport const deleteFileItem = (variables: DeleteFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, DeleteFileItemError, undefined, {}, {}, DeleteFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetFileVariables = {\n  pathParams: GetFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves the file content from a file column\n */\nexport const getFile = (variables: GetFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, GetFileError, undefined, {}, {}, GetFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type PutFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type PutFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PutFileVariables = {\n  body?: Blob;\n  pathParams: PutFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Uploads the file content to the given file column\n */\nexport const putFile = (variables: PutFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, PutFileError, Blob, {}, {}, PutFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteFileVariables = {\n  pathParams: DeleteFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes a file referred in a file column\n */\nexport const deleteFile = (variables: DeleteFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, DeleteFileError, undefined, {}, {}, DeleteFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type GetRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetRecordVariables = {\n  pathParams: GetRecordPathParams;\n  queryParams?: GetRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve record by ID\n */\nexport const getRecord = (variables: GetRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.RecordResponse, GetRecordError, undefined, {}, GetRecordQueryParams, GetRecordPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type InsertRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type InsertRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  createOnly?: boolean;\n  ifVersion?: number;\n};\n\nexport type InsertRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InsertRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: InsertRecordWithIDPathParams;\n  queryParams?: InsertRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.\n */\nexport const insertRecordWithID = (variables: InsertRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    InsertRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    InsertRecordWithIDQueryParams,\n    InsertRecordWithIDPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'put', ...variables, signal });\n\nexport type UpdateRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  ifVersion?: number;\n};\n\nexport type UpdateRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: UpdateRecordWithIDPathParams;\n  queryParams?: UpdateRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateRecordWithID = (variables: UpdateRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    UpdateRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    UpdateRecordWithIDQueryParams,\n    UpdateRecordWithIDPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'patch', ...variables, signal });\n\nexport type UpsertRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type UpsertRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  ifVersion?: number;\n};\n\nexport type UpsertRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpsertRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: UpsertRecordWithIDPathParams;\n  queryParams?: UpsertRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const upsertRecordWithID = (variables: UpsertRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    UpsertRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    UpsertRecordWithIDQueryParams,\n    UpsertRecordWithIDPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'post', ...variables, signal });\n\nexport type DeleteRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type DeleteRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteRecordVariables = {\n  pathParams: DeleteRecordPathParams;\n  queryParams?: DeleteRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const deleteRecord = (variables: DeleteRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordResponse,\n    DeleteRecordError,\n    undefined,\n    {},\n    DeleteRecordQueryParams,\n    DeleteRecordPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'delete', ...variables, signal });\n\nexport type BulkInsertTableRecordsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type BulkInsertTableRecordsQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type BulkInsertTableRecordsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BulkError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type BulkInsertTableRecordsRequestBody = {\n  records: Schemas.DataInputRecord[];\n};\n\nexport type BulkInsertTableRecordsVariables = {\n  body: BulkInsertTableRecordsRequestBody;\n  pathParams: BulkInsertTableRecordsPathParams;\n  queryParams?: BulkInsertTableRecordsQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Bulk insert records\n */\nexport const bulkInsertTableRecords = (variables: BulkInsertTableRecordsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.BulkInsertResponse,\n    BulkInsertTableRecordsError,\n    BulkInsertTableRecordsRequestBody,\n    {},\n    BulkInsertTableRecordsQueryParams,\n    BulkInsertTableRecordsPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/bulk', method: 'post', ...variables, signal });\n\nexport type QueryTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type QueryTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type QueryTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  sort?: Schemas.SortExpression;\n  page?: Schemas.PageConfig;\n  columns?: Schemas.QueryColumnsProjection;\n  /**\n   * The consistency level for this request.\n   *\n   * @default strong\n   */\n  consistency?: 'strong' | 'eventual';\n};\n\nexport type QueryTableVariables = {\n  body?: QueryTableRequestBody;\n  pathParams: QueryTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * The Query Table API can be used to retrieve all records in a table.\n * The API support filtering, sorting, selecting a subset of columns, and pagination.\n *\n * The overall structure of the request looks like this:\n *\n * ```json\n * // POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [...],\n *   \"filter\": {\n *     \"$all\": [...],\n *     \"$any\": [...]\n *     ...\n *   },\n *   \"sort\": {\n *     \"multiple\": [...]\n *     ...\n *   },\n *   \"page\": {\n *     ...\n *   }\n * }\n * ```\n *\n * For usage, see also the [API Guide](https://xata.io/docs/api-guide/get).\n *\n * ### Column selection\n *\n * If the `columns` array is not specified, all columns are included. For link\n * fields, only the ID column of the linked records is included in the response.\n *\n * If the `columns` array is specified, only the selected and internal\n * columns `id` and `xata` are included. The `*` wildcard can be used to\n * select all columns.\n *\n * For objects and link fields, if the column name of the object is specified, we\n * include all of its sub-keys. If only some sub-keys are specified (via dotted\n * notation, e.g. `\"settings.plan\"` ), then only those sub-keys from the object\n * are included.\n *\n * By the way of example, assuming two tables like this:\n *\n * ```json {\"truncate\": true}\n * {\n *   \"tables\": [\n *     {\n *       \"name\": \"teams\",\n *       \"columns\": [\n *         {\n *           \"name\": \"name\",\n *           \"type\": \"string\"\n *         },\n *         {\n *           \"name\": \"owner\",\n *           \"type\": \"link\",\n *           \"link\": {\n *             \"table\": \"users\"\n *           }\n *         },\n *         {\n *           \"name\": \"foundedDate\",\n *           \"type\": \"datetime\"\n *         },\n *       ]\n *     },\n *     {\n *       \"name\": \"users\",\n *       \"columns\": [\n *         {\n *           \"name\": \"email\",\n *           \"type\": \"email\"\n *         },\n *         {\n *           \"name\": \"full_name\",\n *           \"type\": \"string\"\n *         },\n *         {\n *           \"name\": \"address\",\n *           \"type\": \"object\",\n *           \"columns\": [\n *             {\n *               \"name\": \"street\",\n *               \"type\": \"string\"\n *             },\n *             {\n *               \"name\": \"number\",\n *               \"type\": \"int\"\n *             },\n *             {\n *               \"name\": \"zipcode\",\n *               \"type\": \"int\"\n *             }\n *           ]\n *         },\n *         {\n *           \"name\": \"team\",\n *           \"type\": \"link\",\n *           \"link\": {\n *             \"table\": \"teams\"\n *           }\n *         }\n *       ]\n *     }\n *   ]\n * }\n * ```\n *\n * A query like this:\n *\n * ```json\n * POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [\n *     \"name\",\n *     \"address.*\"\n *   ]\n * }\n * ```\n *\n * returns objects like:\n *\n * ```json\n * {\n *   \"name\": \"Kilian\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   }\n * }\n * ```\n *\n * while a query like this:\n *\n * ```json\n * POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [\n *     \"name\",\n *     \"address.street\"\n *   ]\n * }\n * ```\n *\n * returns objects like:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"address\": {\n *     \"street\": \"New street\"\n *   }\n * }\n * ```\n *\n * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:\n *\n * ```json\n * {\n *   \"columns\": [\"*\", \"team.name\"]\n * }\n * ```\n *\n * The `\"*\"` in the above means all columns, including columns of objects. This returns data like:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"email\": \"kilian@gmail.com\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   },\n *   \"team\": {\n *     \"id\": \"XX\",\n *     \"xata\": {\n *       \"version\": 0\n *     },\n *     \"name\": \"first team\"\n *   }\n * }\n * ```\n *\n * If you want all columns of the linked table, you can do:\n *\n * ```json\n * {\n *   \"columns\": [\"*\", \"team.*\"]\n * }\n * ```\n *\n * This returns, for example:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"email\": \"kilian@gmail.com\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   },\n *   \"team\": {\n *     \"id\": \"XX\",\n *     \"xata\": {\n *       \"version\": 0\n *     },\n *     \"name\": \"first team\",\n *     \"code\": \"A1\",\n *     \"foundedDate\": \"2020-03-04T10:43:54.32Z\"\n *   }\n * }\n * ```\n *\n * ### Filtering\n *\n * There are two types of operators:\n *\n * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,\n *   `$includes`, `$gt`, etc.\n * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,\n *   `$none`, etc.\n *\n * All operators start with an `$` to differentiate them from column names\n * (which are not allowed to start with a dollar sign).\n *\n * #### Exact matching and control operators\n *\n * Filter by one column:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": \"value\"\n *   }\n * }\n * ```\n *\n * This is equivalent to using the `$is` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$is\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * For example:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"name\": \"r2\"\n *   }\n * }\n * ```\n *\n * Or:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"name\": {\n *       \"$is\": \"r2\"\n *     }\n *   }\n * }\n * ```\n *\n * For objects, both dots and nested versions work:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.plan\": \"free\"\n *   }\n * }\n * ```\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings\": {\n *       \"plan\": \"free\"\n *     }\n *   }\n * }\n * ```\n *\n * If you want to OR together multiple values, you can use the `$any` operator with an array of values:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.plan\": { \"$any\": [\"free\", \"paid\"] }\n *   }\n * }\n * ```\n *\n * If you specify multiple columns in the same filter, they are logically AND'ed together:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.dark\": true,\n *     \"settings.plan\": \"free\"\n *   }\n * }\n * ```\n *\n * The above matches if both conditions are met.\n *\n * To be more explicit about it, you can use `$all` or `$any`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$any\": {\n *       \"settings.dark\": true,\n *       \"settings.plan\": \"free\"\n *     }\n *   }\n * }\n * ```\n *\n * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$any\": [\n *       {\n *         \"name\": \"r1\"\n *       },\n *       {\n *         \"name\": \"r2\"\n *       }\n *     ]\n *   }\n * }\n * ```\n *\n * You can check for a value being not-null with `$exists`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$exists\": \"settings\"\n *   }\n * }\n * ```\n *\n * This can be combined with `$all` or `$any` :\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$all\": [\n *       {\n *         \"$exists\": \"settings\"\n *       },\n *       {\n *         \"$exists\": \"name\"\n *       }\n *     ]\n *   }\n * }\n * ```\n *\n * Or you can use the inverse operator `$notExists`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$notExists\": \"settings\"\n *   }\n * }\n * ```\n *\n * #### Partial match\n *\n * `$contains` is the simplest operator for partial matching. Note that `$contains` operator can\n * cause performance issues at scale, because indices cannot be used.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$contains\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * Wildcards are supported via the `$pattern` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$pattern\": \"v*alu?\"\n *     }\n *   }\n * }\n * ```\n *\n * The `$pattern` operator accepts two wildcard characters:\n * * `*` matches zero or more characters\n * * `?` matches exactly one character\n *\n * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\\`). You can escape a backslash by usign another backslash.\n *\n * You can also use the `$endsWith` and `$startsWith` operators:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$endsWith\": \".gz\"\n *     },\n *     \"<column_name>\": {\n *       \"$startsWith\": \"tmp-\"\n *     }\n *   }\n * }\n * ```\n *\n * #### Numeric or datetime ranges\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$ge\": 0,\n *       \"$lt\": 100\n *     }\n *   }\n * }\n * ```\n * Date ranges support the same operators, with the date using the format defined in\n * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$gt\": \"2019-10-12T07:20:50.52Z\",\n *       \"$lt\": \"2021-10-12T07:20:50.52Z\"\n *     }\n *   }\n * }\n * ```\n * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.\n *\n * #### Negations\n *\n * A general `$not` operator can inverse any operation.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$not\": {\n *       \"<column_name1>\": \"value1\",\n *       \"<column_name2>\": \"value1\"\n *     }\n *   }\n * }\n * ```\n *\n * Note: in the above the two condition are AND together, so this does (NOT ( ...\n * AND ...))\n *\n * Or more complex:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$not\": {\n *       \"$any\": [\n *         {\n *           \"<column_name1>\": \"value1\"\n *         },\n *         {\n *           \"$all\": [\n *             {\n *               \"<column_name2>\": \"value2\"\n *             },\n *             {\n *               \"<column_name3>\": \"value3\"\n *             }\n *           ]\n *         }\n *       ]\n *     }\n *   }\n * }\n * ```\n *\n * The `$not: { $any: {}}` can be shorted using the `$none` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$none\": {\n *       \"<column_name1>\": \"value1\",\n *       \"<column_name2>\": \"value1\"\n *     }\n *   }\n * }\n * ```\n *\n * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$isNot\": \"2019-10-12T07:20:50.52Z\"\n *     }\n *   }\n * }\n * ```\n *\n * #### Working with arrays\n *\n * To test that an array contains a value, use `$includesAny`.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<array_name>\": {\n *       \"$includesAny\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * ##### `includesAny`\n *\n * The `$includesAny` operator accepts a custom predicate that will check if\n * any value in the array column matches the predicate. The `$includes` operator is a\n * synonym for the `$includesAny` operator.\n *\n * For example a complex predicate can include\n * the `$all` , `$contains` and `$endsWith` operators:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<array name>\": {\n *       \"$includes\": {\n *         \"$all\": [\n *           { \"$contains\": \"label\" },\n *           { \"$not\": { \"$endsWith\": \"-debug\" } }\n *         ]\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * ##### `includesNone`\n *\n * The `$includesNone` operator succeeds if no array item matches the\n * predicate.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.labels\": {\n *       \"$includesNone\": [{ \"$contains\": \"label\" }]\n *     }\n *   }\n * }\n * ```\n * The above matches if none of the array values contain the string \"label\".\n *\n * ##### `includesAll`\n *\n * The `$includesAll` operator succeeds if all array items match the\n * predicate.\n *\n * Here is an example of using the `$includesAll` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.labels\": {\n *       \"$includesAll\": [{ \"$contains\": \"label\" }]\n *     }\n *   }\n * }\n * ```\n *\n * The above matches if all array values contain the string \"label\".\n *\n * ### Sorting\n *\n * Sorting by one element:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"index\": \"asc\"\n *   }\n * }\n * ```\n *\n * or descendently:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"index\": \"desc\"\n *   }\n * }\n * ```\n *\n * Sorting by multiple fields:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": [\n *     {\n *       \"index\": \"desc\"\n *     },\n *     {\n *       \"createdAt\": \"desc\"\n *     }\n *   ]\n * }\n * ```\n *\n * It is also possible to sort results randomly:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"*\": \"random\"\n *   }\n * }\n * ```\n *\n * Note that a random sort does not apply to a specific column, hence the special column name `\"*\"`.\n *\n * A random sort can be combined with an ascending or descending sort on a specific column:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": [\n *     {\n *       \"name\": \"desc\"\n *     },\n *     {\n *       \"*\": \"random\"\n *     }\n *   ]\n * }\n * ```\n *\n * This will sort on the `name` column, breaking ties randomly.\n *\n * ### Pagination\n *\n * We offer cursor pagination and offset pagination. The cursor pagination method can be used for sequential scrolling with unrestricted depth. The offset pagination can be used to skip pages and is limited to 1000 records.\n *\n * Example of cursor pagination:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"after\":\"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n *   }\n * }\n * ```\n *\n * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:\n *\n * ```json\n * {\n *   \"meta\": {\n *     \"page\": {\n *       \"cursor\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\",\n *       \"more\": true\n *     }\n *   },\n *   \"records\": [...]\n * }\n * ```\n *\n * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:\n *\n * - `after`: Return the next page 'after' the current cursor\n * - `before`: Return the previous page 'before' the current cursor.\n * - `start`: Resets the given cursor position to the beginning of the query result set.\n * Will return the first N records from the query result, where N is the `page.size` parameter.\n * - `end`: Resets the give cursor position to the end for the query result set.\n * Returns the last N records from the query result, where N is the `page.size` parameter.\n *\n * The request will fail if an invalid cursor value is given to `page.before`,\n * `page.after`, `page.start` , or `page.end`. No other cursor setting can be\n * used if `page.start` or `page.end` is set in a query.\n *\n * If both `page.before` and `page.after` parameters are present we treat the\n * request as a range query. The range query will return all entries after\n * `page.after`, but before `page.before`, up to `page.size` or the maximum\n * page size. This query requires both cursors to use the same filters and sort\n * settings, plus we require `page.after < page.before`. The range query returns\n * a new cursor. If the range encompass multiple pages the next page in the range\n * can be queried by update `page.after` to the returned cursor while keeping the\n * `page.before` cursor from the first range query.\n *\n * The `filter` , `columns`, `sort` , and `page.size` configuration will be\n * encoded with the cursor. The pagination request will be invalid if\n * `filter` or `sort` is set. The columns returned and page size can be changed\n * anytime by passing the `columns` or `page.size` settings to the next query.\n *\n * In the following example of size + offset pagination we retrieve the third page of up to 100 results:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 100,\n *     \"offset\": 200\n *   }\n * }\n * ```\n *\n * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.\n * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.\n *\n * Cursor pagination also works in combination with offset pagination. For example, starting from a specific cursor position, using a page size of 200 and an offset of 800, you can skip up to 5 pages of 200 records forwards or backwards from the cursor's position:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 200,\n *     \"offset\": 800,\n *     \"after\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n *   }\n * }\n * ```\n *\n * **Special cursors:**\n *\n * - `page.after=end`: Result points past the last entry. The list of records\n *   returned is empty, but `page.meta.cursor` will include a cursor that can be\n *   used to \"tail\" the table from the end waiting for new data to be inserted.\n * - `page.before=end`: This cursor returns the last page.\n * - `page.start=$cursor`: Start at the beginning of the result set of the $cursor query. This is equivalent to querying the\n *   first page without a cursor but applying `filter` and `sort` . Yet the `page.start`\n *   cursor can be convenient at times as user code does not need to remember the\n *   filter, sort, columns or page size configuration. All these information are\n *   read from the cursor.\n * - `page.end=$cursor`: Move to the end of the result set of the $cursor query. This is equivalent to querying the\n *   last page with `page.before=end`, `filter`, and `sort` . Yet the\n *   `page.end` cursor can be more convenient at times as user code does not\n *   need to remember the filter, sort, columns or page size configuration. All\n *   these information are read from the cursor.\n *\n * When using special cursors like `page.after=\"end\"` or `page.before=\"end\"`, we\n * still allow `filter` and `sort` to be set.\n *\n * Example of getting the last page:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 10,\n *     \"before\": \"end\"\n *   }\n * }\n * ```\n */\nexport const queryTable = (variables: QueryTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.QueryResponse, QueryTableError, QueryTableRequestBody, {}, {}, QueryTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/query',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SearchBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type SearchBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type SearchBranchRequestBody = {\n  /**\n   * An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.\n   */\n  tables?: (\n    | string\n    | {\n        /**\n         * The name of the table.\n         */\n        table: string;\n        filter?: Schemas.FilterExpression;\n        target?: Schemas.TargetExpression;\n        boosters?: Schemas.BoosterExpression[];\n      }\n  )[];\n  /**\n   * The query string.\n   *\n   * @minLength 1\n   */\n  query: string;\n  fuzziness?: Schemas.FuzzinessExpression;\n  prefix?: Schemas.PrefixExpression;\n  highlight?: Schemas.HighlightExpression;\n  page?: Schemas.SearchPageConfig;\n};\n\nexport type SearchBranchVariables = {\n  body: SearchBranchRequestBody;\n  pathParams: SearchBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run a free text search operation across the database branch.\n */\nexport const searchBranch = (variables: SearchBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SearchResponse, SearchBranchError, SearchBranchRequestBody, {}, {}, SearchBranchPathParams>({\n    url: '/db/{dbBranchName}/search',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SearchTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SearchTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SearchTableRequestBody = {\n  /**\n   * The query string.\n   *\n   * @minLength 1\n   */\n  query: string;\n  fuzziness?: Schemas.FuzzinessExpression;\n  target?: Schemas.TargetExpression;\n  prefix?: Schemas.PrefixExpression;\n  filter?: Schemas.FilterExpression;\n  highlight?: Schemas.HighlightExpression;\n  boosters?: Schemas.BoosterExpression[];\n  page?: Schemas.SearchPageConfig;\n};\n\nexport type SearchTableVariables = {\n  body: SearchTableRequestBody;\n  pathParams: SearchTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run a free text search operation in a particular table.\n *\n * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:\n * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`\n * * filtering on columns of type `multiple` is currently unsupported\n */\nexport const searchTable = (variables: SearchTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SearchResponse, SearchTableError, SearchTableRequestBody, {}, {}, SearchTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/search',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type VectorSearchTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type VectorSearchTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type VectorSearchTableRequestBody = {\n  /**\n   * The vector to search for similarities. Must have the same dimension as\n   * the vector column used.\n   */\n  queryVector: number[];\n  /**\n   * The vector column in which to search. It must be of type `vector`.\n   */\n  column: string;\n  /**\n   * The function used to measure the distance between two points. Can be one of:\n   * `cosineSimilarity`, `l1`, `l2`. The default is `cosineSimilarity`.\n   *\n   * @default cosineSimilarity\n   */\n  similarityFunction?: string;\n  /**\n   * Number of results to return.\n   *\n   * @default 10\n   * @maximum 100\n   * @minimum 1\n   */\n  size?: number;\n  filter?: Schemas.FilterExpression;\n};\n\nexport type VectorSearchTableVariables = {\n  body: VectorSearchTableRequestBody;\n  pathParams: VectorSearchTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint can be used to perform vector-based similarity searches in a table.\n * It can be used for implementing semantic search and product recommendation. To use this\n * endpoint, you need a column of type vector. The input vector must have the same\n * dimension as the vector column.\n */\nexport const vectorSearchTable = (variables: VectorSearchTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SearchResponse,\n    VectorSearchTableError,\n    VectorSearchTableRequestBody,\n    {},\n    {},\n    VectorSearchTablePathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/vectorSearch', method: 'post', ...variables, signal });\n\nexport type AskTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AskTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n>;\n\nexport type AskTableResponse = {\n  /**\n   * The answer to the input question\n   */\n  answer: string;\n  /**\n   * The session ID for the chat session.\n   */\n  sessionId: string;\n};\n\nexport type AskTableRequestBody = {\n  /**\n   * The question you'd like to ask.\n   *\n   * @minLength 3\n   */\n  question: string;\n  /**\n   * The type of search to use. If set to `keyword` (the default), the search can be configured by passing\n   * a `search` object with the following fields. For more details about each, see the Search endpoint documentation.\n   * All fields are optional.\n   *   * fuzziness  - typo tolerance\n   *   * target - columns to search into, and weights.\n   *   * prefix - prefix search type.\n   *   * filter - pre-filter before searching.\n   *   * boosters - control relevancy.\n   * If set to `vector`, a `vectorSearch` object must be passed, with the following parameters. For more details, see the Vector\n   * Search endpoint documentation. The `column` and `contentColumn` parameters are required.\n   *   * column - the vector column containing the embeddings.\n   *   * contentColumn - the column that contains the text from which the embeddings where computed.\n   *   * filter - pre-filter before searching.\n   *\n   * @default keyword\n   */\n  searchType?: 'keyword' | 'vector';\n  search?: {\n    fuzziness?: Schemas.FuzzinessExpression;\n    target?: Schemas.TargetExpression;\n    prefix?: Schemas.PrefixExpression;\n    filter?: Schemas.FilterExpression;\n    boosters?: Schemas.BoosterExpression[];\n  };\n  vectorSearch?: {\n    /**\n     * The column to use for vector search. It must be of type `vector`.\n     */\n    column: string;\n    /**\n     * The column containing the text for vector search. Must be of type `text`.\n     */\n    contentColumn: string;\n    filter?: Schemas.FilterExpression;\n  };\n  rules?: string[];\n};\n\nexport type AskTableVariables = {\n  body: AskTableRequestBody;\n  pathParams: AskTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Ask your table a question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.\n */\nexport const askTable = (variables: AskTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<AskTableResponse, AskTableError, AskTableRequestBody, {}, {}, AskTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/ask',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AskTableSessionPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * @maxLength 36\n   * @minLength 36\n   */\n  sessionId: string;\n  workspace: string;\n  region: string;\n};\n\nexport type AskTableSessionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type AskTableSessionResponse = {\n  /**\n   * The answer to the input question\n   */\n  answer: string;\n};\n\nexport type AskTableSessionRequestBody = {\n  /**\n   * The question you'd like to ask.\n   *\n   * @minLength 3\n   */\n  message?: string;\n};\n\nexport type AskTableSessionVariables = {\n  body?: AskTableSessionRequestBody;\n  pathParams: AskTableSessionPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Ask a follow-up question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.\n */\nexport const askTableSession = (variables: AskTableSessionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    AskTableSessionResponse,\n    AskTableSessionError,\n    AskTableSessionRequestBody,\n    {},\n    {},\n    AskTableSessionPathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/ask/{sessionId}', method: 'post', ...variables, signal });\n\nexport type SummarizeTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SummarizeTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SummarizeTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  columns?: Schemas.ColumnsProjection;\n  summaries?: Schemas.SummaryExpressionList;\n  sort?: Schemas.SortExpression;\n  summariesFilter?: Schemas.FilterExpression;\n  /**\n   * The consistency level for this request.\n   *\n   * @default strong\n   */\n  consistency?: 'strong' | 'eventual';\n  page?: {\n    /**\n     * The number of records returned by summarize. If the amount of data you have exceeds this, or you have\n     * more complex reporting requirements, we recommend that you use the aggregate endpoint instead.\n     *\n     * @default 20\n     * @maximum 1000\n     * @minimum 1\n     */\n    size?: number;\n  };\n};\n\nexport type SummarizeTableVariables = {\n  body?: SummarizeTableRequestBody;\n  pathParams: SummarizeTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint allows you to (optionally) define groups, and then to run\n * calculations on the values in each group. This is most helpful when\n * you'd like to understand the data you have in your database.\n *\n * A group is a combination of unique values. If you create a group for\n * `sold_by`, `product_name`, we will return one row for every combination\n * of `sold_by` and `product_name` you have in your database. When you\n * want to calculate statistics, you define these groups and ask Xata to\n * calculate data on each group.\n *\n * **Some questions you can ask of your data:**\n *\n * How many records do I have in this table?\n * - Set `columns: []` as we we want data from the entire table, so we ask\n * for no groups.\n * - Set `summaries: {\"total\": {\"count\": \"*\"}}` in order to see the count\n * of all records. We use `count: *` here we'd like to know the total\n * amount of rows; ignoring whether they are `null` or not.\n *\n * What are the top total sales for each product in July 2022 and sold\n * more than 10 units?\n * - Set `filter: {soldAt: {\n *   \"$ge\": \"2022-07-01T00:00:00.000Z\",\n *   \"$lt\": \"2022-08-01T00:00:00.000Z\"}\n * }`\n * in order to limit the result set to sales recorded in July 2022.\n * - Set `columns: [product_name]` as we'd like to run calculations on\n * each unique product name in our table. Setting `columns` like this will\n * produce one row per unique product name.\n * - Set `summaries: {\"total_sales\": {\"count\": \"product_name\"}}` as we'd\n * like to create a field called \"total_sales\" for each group. This field\n * will count all rows in each group with non-null product names.\n * - Set `sort: [{\"total_sales\": \"desc\"}]` in order to bring the rows with\n * the highest total_sales field to the top.\n * - Set `summariesFilter: {\"total_sales\": {\"$ge\": 10}}` to only send back data\n * with greater than or equal to 10 units.\n *\n * `columns`: tells Xata how to create each group. If you add `product_id`\n * we will create a new group for every unique `product_id`.\n *\n * `summaries`: tells Xata which calculations to run on each group. Xata\n * currently supports count, min, max, sum, average.\n *\n * `sort`: tells Xata in which order you'd like to see results. You may\n * sort by fields specified in `columns` as well as the summary names\n * defined in `summaries`.\n *\n * note: Sorting on summarized values can be slower on very large tables;\n * this will impact your rate limit significantly more than other queries.\n * Try use `filter` to reduce the amount of data being processed in order\n * to reduce impact on your limits.\n *\n * `summariesFilter`: tells Xata how to filter the results of a summary.\n * It has the same syntax as `filter`, however, by using `summariesFilter`\n * you may also filter on the results of a query.\n *\n * note: This is a much slower to use than `filter`. We recommend using\n * `filter` wherever possible and `summariesFilter` when it's not\n * possible to use `filter`.\n *\n * `page.size`: tells Xata how many records to return. If unspecified, Xata\n * will return the default size.\n */\nexport const summarizeTable = (variables: SummarizeTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SummarizeResponse,\n    SummarizeTableError,\n    SummarizeTableRequestBody,\n    {},\n    {},\n    SummarizeTablePathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/summarize', method: 'post', ...variables, signal });\n\nexport type AggregateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AggregateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AggregateTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  aggs?: Schemas.AggExpressionMap;\n};\n\nexport type AggregateTableVariables = {\n  body?: AggregateTableRequestBody;\n  pathParams: AggregateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint allows you to run aggregations (analytics) on the data from one table.\n * While the summary endpoint is served from a transactional store and the results are strongly\n * consistent, the aggregate endpoint is served from our columnar store and the results are\n * only eventually consistent. On the other hand, the aggregate endpoint uses a\n * store that is more appropiate for analytics, makes use of approximative algorithms\n * (e.g for cardinality), and is generally faster and can do more complex aggregations.\n *\n * For usage, see the [API Guide](https://xata.io/docs/api-guide/aggregate).\n */\nexport const aggregateTable = (variables: AggregateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.AggResponse,\n    AggregateTableError,\n    AggregateTableRequestBody,\n    {},\n    {},\n    AggregateTablePathParams\n  >({ url: '/db/{dbBranchName}/tables/{tableName}/aggregate', method: 'post', ...variables, signal });\n\nexport type FileAccessPathParams = {\n  /**\n   * The File Access Identifier\n   */\n  fileId: Schemas.FileAccessID;\n  workspace: string;\n  region: string;\n};\n\nexport type FileAccessQueryParams = {\n  /**\n   * File access signature\n   */\n  verify?: Schemas.FileSignature;\n};\n\nexport type FileAccessError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type FileAccessVariables = {\n  pathParams: FileAccessPathParams;\n  queryParams?: FileAccessQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve file content by access id\n */\nexport const fileAccess = (variables: FileAccessVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, FileAccessError, undefined, {}, FileAccessQueryParams, FileAccessPathParams>({\n    url: '/file/{fileId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type SqlQueryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type SqlQueryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type SqlQueryRequestBody = {\n  /**\n   * The SQL statement.\n   *\n   * @minLength 1\n   */\n  statement: string;\n  /**\n   * The query parameter list.\n   */\n  params?: any[] | null;\n  /**\n   * The consistency level for this request.\n   *\n   * @default strong\n   */\n  consistency?: 'strong' | 'eventual';\n};\n\nexport type SqlQueryVariables = {\n  body: SqlQueryRequestBody;\n  pathParams: SqlQueryPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run an SQL query across the database branch.\n */\nexport const sqlQuery = (variables: SqlQueryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SQLResponse, SqlQueryError, SqlQueryRequestBody, {}, {}, SqlQueryPathParams>({\n    url: '/db/{dbBranchName}/sql',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport const operationsByTag = {\n  branch: {\n    getBranchList,\n    getBranchDetails,\n    createBranch,\n    deleteBranch,\n    copyBranch,\n    updateBranchMetadata,\n    getBranchMetadata,\n    getBranchStats,\n    getGitBranchesMapping,\n    addGitBranchesEntry,\n    removeGitBranchesEntry,\n    resolveBranch\n  },\n  migrations: {\n    getSchema,\n    getBranchMigrationHistory,\n    getBranchMigrationPlan,\n    executeBranchMigrationPlan,\n    getBranchSchemaHistory,\n    compareBranchWithUserSchema,\n    compareBranchSchemas,\n    updateBranchSchema,\n    previewBranchSchemaEdit,\n    applyBranchSchemaEdit,\n    pushBranchMigrations\n  },\n  migrationRequests: {\n    queryMigrationRequests,\n    createMigrationRequest,\n    getMigrationRequest,\n    updateMigrationRequest,\n    listMigrationRequestsCommits,\n    compareMigrationRequest,\n    getMigrationRequestIsMerged,\n    mergeMigrationRequest\n  },\n  table: {\n    createTable,\n    deleteTable,\n    updateTable,\n    getTableSchema,\n    setTableSchema,\n    getTableColumns,\n    addTableColumn,\n    getColumn,\n    updateColumn,\n    deleteColumn\n  },\n  records: {\n    branchTransaction,\n    insertRecord,\n    getRecord,\n    insertRecordWithID,\n    updateRecordWithID,\n    upsertRecordWithID,\n    deleteRecord,\n    bulkInsertTableRecords\n  },\n  files: { getFileItem, putFileItem, deleteFileItem, getFile, putFile, deleteFile, fileAccess },\n  searchAndFilter: {\n    queryTable,\n    searchBranch,\n    searchTable,\n    vectorSearchTable,\n    askTable,\n    askTableSession,\n    summarizeTable,\n    aggregateTable\n  },\n  sql: { sqlQuery }\n};\n","import { TraceFunction } from '../schema/tracing';\nimport { FetchImpl } from '../util/fetch';\nimport { PossibleErrors } from './errors';\nimport { fetch, WorkspaceApiUrlBuilder } from './fetcher';\n\nexport type ControlPlaneFetcherExtraProps = {\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type ControlPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n  signal?: AbortSignal;\n} & ControlPlaneFetcherExtraProps;\n\nexport const controlPlaneFetch = async <\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>(\n  options: ControlPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams>\n): Promise<TData> =>\n  fetch<TData, TError, TBody, THeaders, TQueryParams, TPathParams>({ ...options, endpoint: 'controlPlane' });\n","/**\n * Generated by @openapi-codegen\n *\n * @version 1.0\n */\nimport type * as Fetcher from './controlPlaneFetcher';\nimport { controlPlaneFetch, ControlPlaneFetcherExtraProps } from './controlPlaneFetcher';\nimport type * as Schemas from './controlPlaneSchemas';\nimport type * as Responses from './controlPlaneResponses';\n\nexport type GetAuthorizationCodeQueryParams = {\n  clientID: string;\n  responseType: Schemas.OAuthResponseType;\n  redirectUri?: string;\n  scopes?: Schemas.OAuthScope[];\n  state?: string;\n};\n\nexport type GetAuthorizationCodeError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetAuthorizationCodeVariables = {\n  queryParams: GetAuthorizationCodeQueryParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates, stores and returns an authorization code to be used by a third party app. Supporting use of GET is required by OAuth2 spec\n */\nexport const getAuthorizationCode = (variables: GetAuthorizationCodeVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.AuthorizationCodeResponse,\n    GetAuthorizationCodeError,\n    undefined,\n    {},\n    GetAuthorizationCodeQueryParams,\n    {}\n  >({ url: '/oauth/authorize', method: 'get', ...variables, signal });\n\nexport type GrantAuthorizationCodeError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GrantAuthorizationCodeVariables = {\n  body: Schemas.AuthorizationCodeRequest;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates, stores and returns an authorization code to be used by a third party app\n */\nexport const grantAuthorizationCode = (variables: GrantAuthorizationCodeVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.AuthorizationCodeResponse,\n    GrantAuthorizationCodeError,\n    Schemas.AuthorizationCodeRequest,\n    {},\n    {},\n    {}\n  >({ url: '/oauth/authorize', method: 'post', ...variables, signal });\n\nexport type GetUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Return details of the user making the request\n */\nexport const getUser = (variables: GetUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.UserWithID, GetUserError, undefined, {}, {}, {}>({\n    url: '/user',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateUserVariables = {\n  body: Schemas.User;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update user info\n */\nexport const updateUser = (variables: UpdateUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.UserWithID, UpdateUserError, Schemas.User, {}, {}, {}>({\n    url: '/user',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the user making the request\n */\nexport const deleteUser = (variables: DeleteUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserError, undefined, {}, {}, {}>({\n    url: '/user',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserAPIKeysError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserAPIKeysResponse = {\n  keys: {\n    name: string;\n    createdAt: Schemas.DateTime;\n  }[];\n};\n\nexport type GetUserAPIKeysVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve a list of existing user API keys\n */\nexport const getUserAPIKeys = (variables: GetUserAPIKeysVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserAPIKeysResponse, GetUserAPIKeysError, undefined, {}, {}, {}>({\n    url: '/user/keys',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateUserAPIKeyPathParams = {\n  /**\n   * API Key name\n   */\n  keyName: Schemas.APIKeyName;\n};\n\nexport type CreateUserAPIKeyError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateUserAPIKeyResponse = {\n  name: string;\n  key: string;\n  createdAt: Schemas.DateTime;\n};\n\nexport type CreateUserAPIKeyVariables = {\n  pathParams: CreateUserAPIKeyPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Create and return new API key\n */\nexport const createUserAPIKey = (variables: CreateUserAPIKeyVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<CreateUserAPIKeyResponse, CreateUserAPIKeyError, undefined, {}, {}, CreateUserAPIKeyPathParams>({\n    url: '/user/keys/{keyName}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserAPIKeyPathParams = {\n  /**\n   * API Key name\n   */\n  keyName: Schemas.APIKeyName;\n};\n\nexport type DeleteUserAPIKeyError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserAPIKeyVariables = {\n  pathParams: DeleteUserAPIKeyPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete an existing API key\n */\nexport const deleteUserAPIKey = (variables: DeleteUserAPIKeyVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserAPIKeyError, undefined, {}, {}, DeleteUserAPIKeyPathParams>({\n    url: '/user/keys/{keyName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserOAuthClientsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserOAuthClientsResponse = {\n  clients?: Schemas.OAuthClientPublicDetails[];\n};\n\nexport type GetUserOAuthClientsVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of OAuth Clients that a user has authorized\n */\nexport const getUserOAuthClients = (variables: GetUserOAuthClientsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserOAuthClientsResponse, GetUserOAuthClientsError, undefined, {}, {}, {}>({\n    url: '/user/oauth/clients',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserOAuthClientPathParams = {\n  clientId: Schemas.OAuthClientID;\n};\n\nexport type DeleteUserOAuthClientError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserOAuthClientVariables = {\n  pathParams: DeleteUserOAuthClientPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the oauth client for the user and revoke all access\n */\nexport const deleteUserOAuthClient = (variables: DeleteUserOAuthClientVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserOAuthClientError, undefined, {}, {}, DeleteUserOAuthClientPathParams>({\n    url: '/user/oauth/clients/{clientId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserOAuthAccessTokensError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserOAuthAccessTokensResponse = {\n  accessTokens: Schemas.OAuthAccessToken[];\n};\n\nexport type GetUserOAuthAccessTokensVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of valid OAuth Access Tokens on the current user's account\n */\nexport const getUserOAuthAccessTokens = (variables: GetUserOAuthAccessTokensVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserOAuthAccessTokensResponse, GetUserOAuthAccessTokensError, undefined, {}, {}, {}>({\n    url: '/user/oauth/tokens',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type DeleteOAuthAccessTokenPathParams = {\n  token: Schemas.AccessToken;\n};\n\nexport type DeleteOAuthAccessTokenError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteOAuthAccessTokenVariables = {\n  pathParams: DeleteOAuthAccessTokenPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Expires the access token for a third party app\n */\nexport const deleteOAuthAccessToken = (variables: DeleteOAuthAccessTokenVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteOAuthAccessTokenError, undefined, {}, {}, DeleteOAuthAccessTokenPathParams>({\n    url: '/user/oauth/tokens/{token}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type UpdateOAuthAccessTokenPathParams = {\n  token: Schemas.AccessToken;\n};\n\nexport type UpdateOAuthAccessTokenError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateOAuthAccessTokenRequestBody = {\n  /**\n   * expiration time of the token as a unix timestamp\n   */\n  expires: number;\n};\n\nexport type UpdateOAuthAccessTokenVariables = {\n  body: UpdateOAuthAccessTokenRequestBody;\n  pathParams: UpdateOAuthAccessTokenPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Updates partially the access token for a third party app\n */\nexport const updateOAuthAccessToken = (variables: UpdateOAuthAccessTokenVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.OAuthAccessToken,\n    UpdateOAuthAccessTokenError,\n    UpdateOAuthAccessTokenRequestBody,\n    {},\n    {},\n    UpdateOAuthAccessTokenPathParams\n  >({ url: '/user/oauth/tokens/{token}', method: 'patch', ...variables, signal });\n\nexport type GetWorkspacesListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspacesListResponse = {\n  workspaces: {\n    id: Schemas.WorkspaceID;\n    name: string;\n    slug: string;\n    role: Schemas.Role;\n  }[];\n};\n\nexport type GetWorkspacesListVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of workspaces the user belongs to\n */\nexport const getWorkspacesList = (variables: GetWorkspacesListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetWorkspacesListResponse, GetWorkspacesListError, undefined, {}, {}, {}>({\n    url: '/workspaces',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateWorkspaceVariables = {\n  body: Schemas.WorkspaceMeta;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates a new workspace with the user requesting it as its single owner.\n */\nexport const createWorkspace = (variables: CreateWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, CreateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, {}>({\n    url: '/workspaces',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspaceVariables = {\n  pathParams: GetWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve workspace info from a workspace ID\n */\nexport const getWorkspace = (variables: GetWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, GetWorkspaceError, undefined, {}, {}, GetWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type UpdateWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceVariables = {\n  body: Schemas.WorkspaceMeta;\n  pathParams: UpdateWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update workspace info\n */\nexport const updateWorkspace = (variables: UpdateWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, UpdateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, UpdateWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type DeleteWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteWorkspaceVariables = {\n  pathParams: DeleteWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the workspace with the provided ID\n */\nexport const deleteWorkspace = (variables: DeleteWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteWorkspaceError, undefined, {}, {}, DeleteWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspaceMembersListPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetWorkspaceMembersListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspaceMembersListVariables = {\n  pathParams: GetWorkspaceMembersListPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of members of the given workspace\n */\nexport const getWorkspaceMembersList = (variables: GetWorkspaceMembersListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceMembers,\n    GetWorkspaceMembersListError,\n    undefined,\n    {},\n    {},\n    GetWorkspaceMembersListPathParams\n  >({ url: '/workspaces/{workspaceId}/members', method: 'get', ...variables, signal });\n\nexport type UpdateWorkspaceMemberRolePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * UserID\n   */\n  userId: Schemas.UserID;\n};\n\nexport type UpdateWorkspaceMemberRoleError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceMemberRoleRequestBody = {\n  role: Schemas.Role;\n};\n\nexport type UpdateWorkspaceMemberRoleVariables = {\n  body: UpdateWorkspaceMemberRoleRequestBody;\n  pathParams: UpdateWorkspaceMemberRolePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.\n */\nexport const updateWorkspaceMemberRole = (variables: UpdateWorkspaceMemberRoleVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    UpdateWorkspaceMemberRoleError,\n    UpdateWorkspaceMemberRoleRequestBody,\n    {},\n    {},\n    UpdateWorkspaceMemberRolePathParams\n  >({ url: '/workspaces/{workspaceId}/members/{userId}', method: 'put', ...variables, signal });\n\nexport type RemoveWorkspaceMemberPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * UserID\n   */\n  userId: Schemas.UserID;\n};\n\nexport type RemoveWorkspaceMemberError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type RemoveWorkspaceMemberVariables = {\n  pathParams: RemoveWorkspaceMemberPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Remove the member from the workspace\n */\nexport const removeWorkspaceMember = (variables: RemoveWorkspaceMemberVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, RemoveWorkspaceMemberError, undefined, {}, {}, RemoveWorkspaceMemberPathParams>({\n    url: '/workspaces/{workspaceId}/members/{userId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type InviteWorkspaceMemberPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type InviteWorkspaceMemberError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InviteWorkspaceMemberRequestBody = {\n  /**\n   * @format email\n   */\n  email: string;\n  role: Schemas.Role;\n};\n\nexport type InviteWorkspaceMemberVariables = {\n  body: InviteWorkspaceMemberRequestBody;\n  pathParams: InviteWorkspaceMemberPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Invite some user to join the workspace with the given role\n */\nexport const inviteWorkspaceMember = (variables: InviteWorkspaceMemberVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceInvite,\n    InviteWorkspaceMemberError,\n    InviteWorkspaceMemberRequestBody,\n    {},\n    {},\n    InviteWorkspaceMemberPathParams\n  >({ url: '/workspaces/{workspaceId}/invites', method: 'post', ...variables, signal });\n\nexport type UpdateWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type UpdateWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceMemberInviteRequestBody = {\n  role: Schemas.Role;\n};\n\nexport type UpdateWorkspaceMemberInviteVariables = {\n  body: UpdateWorkspaceMemberInviteRequestBody;\n  pathParams: UpdateWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to update an existing invite. Updates are performed in-place; they do not change the invite link, the expiry time, nor do they re-notify the recipient of the invite.\n */\nexport const updateWorkspaceMemberInvite = (variables: UpdateWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceInvite,\n    UpdateWorkspaceMemberInviteError,\n    UpdateWorkspaceMemberInviteRequestBody,\n    {},\n    {},\n    UpdateWorkspaceMemberInvitePathParams\n  >({ url: '/workspaces/{workspaceId}/invites/{inviteId}', method: 'patch', ...variables, signal });\n\nexport type CancelWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type CancelWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CancelWorkspaceMemberInviteVariables = {\n  pathParams: CancelWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.\n */\nexport const cancelWorkspaceMemberInvite = (variables: CancelWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    CancelWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    CancelWorkspaceMemberInvitePathParams\n  >({ url: '/workspaces/{workspaceId}/invites/{inviteId}', method: 'delete', ...variables, signal });\n\nexport type AcceptWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite Key (secret) for the invited user\n   */\n  inviteKey: Schemas.InviteKey;\n};\n\nexport type AcceptWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AcceptWorkspaceMemberInviteVariables = {\n  pathParams: AcceptWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace\n */\nexport const acceptWorkspaceMemberInvite = (variables: AcceptWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    AcceptWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    AcceptWorkspaceMemberInvitePathParams\n  >({ url: '/workspaces/{workspaceId}/invites/{inviteKey}/accept', method: 'post', ...variables, signal });\n\nexport type ResendWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type ResendWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ResendWorkspaceMemberInviteVariables = {\n  pathParams: ResendWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.\n */\nexport const resendWorkspaceMemberInvite = (variables: ResendWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    ResendWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    ResendWorkspaceMemberInvitePathParams\n  >({ url: '/workspaces/{workspaceId}/invites/{inviteId}/resend', method: 'post', ...variables, signal });\n\nexport type ListClustersPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type ListClustersError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListClustersVariables = {\n  pathParams: ListClustersPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List all clusters available in your Workspace.\n */\nexport const listClusters = (variables: ListClustersVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ListClustersResponse, ListClustersError, undefined, {}, {}, ListClustersPathParams>({\n    url: '/workspaces/{workspaceId}/clusters',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type CreateClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateClusterVariables = {\n  body: Schemas.ClusterCreateDetails;\n  pathParams: CreateClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\nexport const createCluster = (variables: CreateClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.ClusterResponse,\n    CreateClusterError,\n    Schemas.ClusterCreateDetails,\n    {},\n    {},\n    CreateClusterPathParams\n  >({ url: '/workspaces/{workspaceId}/clusters', method: 'post', ...variables, signal });\n\nexport type GetClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n};\n\nexport type GetClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetClusterVariables = {\n  pathParams: GetClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve metadata for given cluster ID\n */\nexport const getCluster = (variables: GetClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ClusterMetadata, GetClusterError, undefined, {}, {}, GetClusterPathParams>({\n    url: '/workspaces/{workspaceId}/clusters/{clusterId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n};\n\nexport type UpdateClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type UpdateClusterVariables = {\n  body: Schemas.ClusterUpdateDetails;\n  pathParams: UpdateClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update cluster for given cluster ID\n */\nexport const updateCluster = (variables: UpdateClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.ClusterMetadata,\n    UpdateClusterError,\n    Schemas.ClusterUpdateDetails,\n    {},\n    {},\n    UpdateClusterPathParams\n  >({ url: '/workspaces/{workspaceId}/clusters/{clusterId}', method: 'patch', ...variables, signal });\n\nexport type GetDatabaseListPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetDatabaseListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetDatabaseListVariables = {\n  pathParams: GetDatabaseListPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List all databases available in your Workspace.\n */\nexport const getDatabaseList = (variables: GetDatabaseListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ListDatabasesResponse, GetDatabaseListError, undefined, {}, {}, GetDatabaseListPathParams>({\n    url: '/workspaces/{workspaceId}/dbs',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type CreateDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateDatabaseResponse = {\n  /**\n   * @minLength 1\n   */\n  databaseName: string;\n  branchName?: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateDatabaseRequestBody = {\n  /**\n   * @minLength 1\n   */\n  branchName?: string;\n  /**\n   * @minLength 1\n   */\n  region: string;\n  ui?: {\n    color?: string;\n  };\n  metadata?: Schemas.BranchMetadata;\n};\n\nexport type CreateDatabaseVariables = {\n  body: CreateDatabaseRequestBody;\n  pathParams: CreateDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Create Database with identifier name\n */\nexport const createDatabase = (variables: CreateDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    CreateDatabaseResponse,\n    CreateDatabaseError,\n    CreateDatabaseRequestBody,\n    {},\n    {},\n    CreateDatabasePathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}', method: 'put', ...variables, signal });\n\nexport type DeleteDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type DeleteDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteDatabaseResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteDatabaseVariables = {\n  pathParams: DeleteDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete a database and all of its branches and tables permanently.\n */\nexport const deleteDatabase = (variables: DeleteDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<DeleteDatabaseResponse, DeleteDatabaseError, undefined, {}, {}, DeleteDatabasePathParams>({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetDatabaseMetadataPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type GetDatabaseMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetDatabaseMetadataVariables = {\n  pathParams: GetDatabaseMetadataPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve metadata of the given database\n */\nexport const getDatabaseMetadata = (variables: GetDatabaseMetadataVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    GetDatabaseMetadataError,\n    undefined,\n    {},\n    {},\n    GetDatabaseMetadataPathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}', method: 'get', ...variables, signal });\n\nexport type UpdateDatabaseMetadataPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type UpdateDatabaseMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateDatabaseMetadataRequestBody = {\n  ui?: {\n    /**\n     * @minLength 1\n     */\n    color?: string;\n  };\n};\n\nexport type UpdateDatabaseMetadataVariables = {\n  body?: UpdateDatabaseMetadataRequestBody;\n  pathParams: UpdateDatabaseMetadataPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update the color of the selected database\n */\nexport const updateDatabaseMetadata = (variables: UpdateDatabaseMetadataVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    UpdateDatabaseMetadataError,\n    UpdateDatabaseMetadataRequestBody,\n    {},\n    {},\n    UpdateDatabaseMetadataPathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}', method: 'patch', ...variables, signal });\n\nexport type RenameDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type RenameDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type RenameDatabaseRequestBody = {\n  /**\n   * @minLength 1\n   */\n  newName: string;\n};\n\nexport type RenameDatabaseVariables = {\n  body: RenameDatabaseRequestBody;\n  pathParams: RenameDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Change the name of an existing database\n */\nexport const renameDatabase = (variables: RenameDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    RenameDatabaseError,\n    RenameDatabaseRequestBody,\n    {},\n    {},\n    RenameDatabasePathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}/rename', method: 'post', ...variables, signal });\n\nexport type GetDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type GetDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetDatabaseGithubSettingsVariables = {\n  pathParams: GetDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve current Github database settings\n */\nexport const getDatabaseGithubSettings = (variables: GetDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseGithubSettings,\n    GetDatabaseGithubSettingsError,\n    undefined,\n    {},\n    {},\n    GetDatabaseGithubSettingsPathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}/github', method: 'get', ...variables, signal });\n\nexport type UpdateDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type UpdateDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateDatabaseGithubSettingsVariables = {\n  body: Schemas.DatabaseGithubSettings;\n  pathParams: UpdateDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Map the database to a Github repository, Xata will create database branch previews for all new branches/PRs in the repo.\n */\nexport const updateDatabaseGithubSettings = (variables: UpdateDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseGithubSettings,\n    UpdateDatabaseGithubSettingsError,\n    Schemas.DatabaseGithubSettings,\n    {},\n    {},\n    UpdateDatabaseGithubSettingsPathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}/github', method: 'put', ...variables, signal });\n\nexport type DeleteDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type DeleteDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteDatabaseGithubSettingsVariables = {\n  pathParams: DeleteDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete any existing database Github settings\n */\nexport const deleteDatabaseGithubSettings = (variables: DeleteDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    DeleteDatabaseGithubSettingsError,\n    undefined,\n    {},\n    {},\n    DeleteDatabaseGithubSettingsPathParams\n  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}/github', method: 'delete', ...variables, signal });\n\nexport type ListRegionsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type ListRegionsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListRegionsVariables = {\n  pathParams: ListRegionsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List regions available to create a database on\n */\nexport const listRegions = (variables: ListRegionsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ListRegionsResponse, ListRegionsError, undefined, {}, {}, ListRegionsPathParams>({\n    url: '/workspaces/{workspaceId}/regions',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport const operationsByTag = {\n  oAuth: {\n    getAuthorizationCode,\n    grantAuthorizationCode,\n    getUserOAuthClients,\n    deleteUserOAuthClient,\n    getUserOAuthAccessTokens,\n    deleteOAuthAccessToken,\n    updateOAuthAccessToken\n  },\n  users: { getUser, updateUser, deleteUser },\n  authentication: { getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },\n  workspaces: {\n    getWorkspacesList,\n    createWorkspace,\n    getWorkspace,\n    updateWorkspace,\n    deleteWorkspace,\n    getWorkspaceMembersList,\n    updateWorkspaceMemberRole,\n    removeWorkspaceMember\n  },\n  invites: {\n    inviteWorkspaceMember,\n    updateWorkspaceMemberInvite,\n    cancelWorkspaceMemberInvite,\n    acceptWorkspaceMemberInvite,\n    resendWorkspaceMemberInvite\n  },\n  xbcontrolOther: { listClusters, createCluster, getCluster, updateCluster },\n  databases: {\n    getDatabaseList,\n    createDatabase,\n    deleteDatabase,\n    getDatabaseMetadata,\n    updateDatabaseMetadata,\n    renameDatabase,\n    getDatabaseGithubSettings,\n    updateDatabaseGithubSettings,\n    deleteDatabaseGithubSettings,\n    listRegions\n  }\n};\n","export * from './dataPlaneComponents';\nexport * from './controlPlaneComponents';\n\nimport { operationsByTag as dataPlaneOperations } from './dataPlaneComponents';\nimport { operationsByTag as controlPlaneOperations } from './controlPlaneComponents';\n\nimport { deepMerge } from '../util/lang';\n\nexport const operationsByTag = deepMerge(dataPlaneOperations, controlPlaneOperations);\n","import { isObject, isString } from '../util/lang';\n\ntype HostAliases = 'production' | 'staging' | 'dev';\ntype ProviderBuilder = { main: string; workspaces: string };\nexport type HostProvider = HostAliases | ProviderBuilder;\n\nexport function getHostUrl(provider: HostProvider, type: keyof ProviderBuilder): string {\n  if (isHostProviderAlias(provider)) {\n    return providers[provider][type];\n  } else if (isHostProviderBuilder(provider)) {\n    return provider[type];\n  }\n\n  throw new Error('Invalid API provider');\n}\n\nconst providers: Record<HostAliases, ProviderBuilder> = {\n  production: {\n    main: 'https://api.xata.io',\n    workspaces: 'https://{workspaceId}.{region}.xata.sh'\n  },\n  staging: {\n    main: 'https://api.staging-xata.dev',\n    workspaces: 'https://{workspaceId}.{region}.staging-xata.dev'\n  },\n  dev: {\n    main: 'https://api.dev-xata.dev',\n    workspaces: 'https://{workspaceId}.{region}.dev-xata.dev'\n  }\n};\n\nexport function isHostProviderAlias(alias: HostProvider | string): alias is HostAliases {\n  return isString(alias) && Object.keys(providers).includes(alias);\n}\n\nexport function isHostProviderBuilder(builder: HostProvider): builder is ProviderBuilder {\n  return isObject(builder) && isString(builder.main) && isString(builder.workspaces);\n}\n\nexport function parseProviderString(provider = 'production'): HostProvider | null {\n  if (isHostProviderAlias(provider)) {\n    return provider;\n  }\n\n  const [main, workspaces] = provider.split(',');\n  if (!main || !workspaces) return null;\n  return { main, workspaces };\n}\n\nexport function buildProviderString(provider: HostProvider): string {\n  if (isHostProviderAlias(provider)) return provider;\n  return `${provider.main},${provider.workspaces}`;\n}\n\nexport function parseWorkspacesUrlParts(url: string): { workspace: string; region: string } | null {\n  if (!isString(url)) return null;\n\n  const regex = /(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.xata\\.sh.*/;\n  const regexDev = /(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.dev-xata\\.dev.*/;\n  const regexStaging = /(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.staging-xata\\.dev.*/;\n  const regexProdTesting = /(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.xata\\.tech.*/;\n\n  const match = url.match(regex) || url.match(regexDev) || url.match(regexStaging) || url.match(regexProdTesting);\n  if (!match) return null;\n\n  return { workspace: match[1], region: match[2] };\n}\n","import { defaultTrace, TraceFunction } from '../schema/tracing';\nimport { getAPIKey } from '../util/environment';\nimport { FetchImpl, getFetchImplementation } from '../util/fetch';\nimport { generateUUID } from '../util/uuid';\nimport type * as Components from './components';\nimport type * as Types from './components';\nimport { operationsByTag } from './components';\nimport type { FetcherExtraProps } from './fetcher';\nimport { getHostUrl, HostProvider } from './providers';\nimport type * as Responses from './responses';\nimport type * as Schemas from './schemas';\n\nexport type ApiExtraProps = Omit<FetcherExtraProps, 'endpoint'>;\n\nexport interface XataApiClientOptions {\n  fetch?: FetchImpl;\n  apiKey?: string;\n  host?: HostProvider;\n  trace?: TraceFunction;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n}\n\nexport class XataApiClient {\n  #extraProps: ApiExtraProps;\n  #namespaces: Partial<{\n    user: UserApi;\n    authentication: AuthenticationApi;\n    workspaces: WorkspaceApi;\n    invites: InvitesApi;\n    database: DatabaseApi;\n    branches: BranchApi;\n    migrations: MigrationsApi;\n    migrationRequests: MigrationRequestsApi;\n    tables: TableApi;\n    records: RecordsApi;\n    files: FilesApi;\n    searchAndFilter: SearchAndFilterApi;\n  }> = {};\n\n  constructor(options: XataApiClientOptions = {}) {\n    const provider = options.host ?? 'production';\n    const apiKey = options.apiKey ?? getAPIKey();\n    const trace = options.trace ?? defaultTrace;\n    const clientID = generateUUID();\n\n    if (!apiKey) {\n      throw new Error('Could not resolve a valid apiKey');\n    }\n\n    this.#extraProps = {\n      apiUrl: getHostUrl(provider, 'main'),\n      workspacesApiUrl: getHostUrl(provider, 'workspaces'),\n      fetch: getFetchImplementation(options.fetch),\n      apiKey,\n      trace,\n      clientName: options.clientName,\n      xataAgentExtra: options.xataAgentExtra,\n      clientID\n    };\n  }\n\n  public get user() {\n    if (!this.#namespaces.user) this.#namespaces.user = new UserApi(this.#extraProps);\n    return this.#namespaces.user;\n  }\n\n  public get authentication() {\n    if (!this.#namespaces.authentication) this.#namespaces.authentication = new AuthenticationApi(this.#extraProps);\n    return this.#namespaces.authentication;\n  }\n\n  public get workspaces() {\n    if (!this.#namespaces.workspaces) this.#namespaces.workspaces = new WorkspaceApi(this.#extraProps);\n    return this.#namespaces.workspaces;\n  }\n\n  public get invites() {\n    if (!this.#namespaces.invites) this.#namespaces.invites = new InvitesApi(this.#extraProps);\n    return this.#namespaces.invites;\n  }\n\n  public get database() {\n    if (!this.#namespaces.database) this.#namespaces.database = new DatabaseApi(this.#extraProps);\n    return this.#namespaces.database;\n  }\n\n  public get branches() {\n    if (!this.#namespaces.branches) this.#namespaces.branches = new BranchApi(this.#extraProps);\n    return this.#namespaces.branches;\n  }\n\n  public get migrations() {\n    if (!this.#namespaces.migrations) this.#namespaces.migrations = new MigrationsApi(this.#extraProps);\n    return this.#namespaces.migrations;\n  }\n\n  public get migrationRequests() {\n    if (!this.#namespaces.migrationRequests)\n      this.#namespaces.migrationRequests = new MigrationRequestsApi(this.#extraProps);\n    return this.#namespaces.migrationRequests;\n  }\n\n  public get tables() {\n    if (!this.#namespaces.tables) this.#namespaces.tables = new TableApi(this.#extraProps);\n    return this.#namespaces.tables;\n  }\n\n  public get records() {\n    if (!this.#namespaces.records) this.#namespaces.records = new RecordsApi(this.#extraProps);\n    return this.#namespaces.records;\n  }\n\n  public get files() {\n    if (!this.#namespaces.files) this.#namespaces.files = new FilesApi(this.#extraProps);\n    return this.#namespaces.files;\n  }\n\n  public get searchAndFilter() {\n    if (!this.#namespaces.searchAndFilter) this.#namespaces.searchAndFilter = new SearchAndFilterApi(this.#extraProps);\n    return this.#namespaces.searchAndFilter;\n  }\n}\n\nclass UserApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getUser(): Promise<Schemas.UserWithID> {\n    return operationsByTag.users.getUser({ ...this.extraProps });\n  }\n\n  public updateUser({ user }: { user: Schemas.User }): Promise<Schemas.UserWithID> {\n    return operationsByTag.users.updateUser({ body: user, ...this.extraProps });\n  }\n\n  public deleteUser(): Promise<void> {\n    return operationsByTag.users.deleteUser({ ...this.extraProps });\n  }\n}\n\nclass AuthenticationApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getUserAPIKeys(): Promise<Types.GetUserAPIKeysResponse> {\n    return operationsByTag.authentication.getUserAPIKeys({ ...this.extraProps });\n  }\n\n  public createUserAPIKey({ name }: { name: Schemas.APIKeyName }): Promise<Types.CreateUserAPIKeyResponse> {\n    return operationsByTag.authentication.createUserAPIKey({\n      pathParams: { keyName: name },\n      ...this.extraProps\n    });\n  }\n\n  public deleteUserAPIKey({ name }: { name: Schemas.APIKeyName }): Promise<void> {\n    return operationsByTag.authentication.deleteUserAPIKey({\n      pathParams: { keyName: name },\n      ...this.extraProps\n    });\n  }\n}\n\nclass WorkspaceApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getWorkspacesList(): Promise<Types.GetWorkspacesListResponse> {\n    return operationsByTag.workspaces.getWorkspacesList({ ...this.extraProps });\n  }\n\n  public createWorkspace({ data }: { data: Schemas.WorkspaceMeta }): Promise<Schemas.Workspace> {\n    return operationsByTag.workspaces.createWorkspace({\n      body: data,\n      ...this.extraProps\n    });\n  }\n\n  public getWorkspace({ workspace }: { workspace: Schemas.WorkspaceID }): Promise<Schemas.Workspace> {\n    return operationsByTag.workspaces.getWorkspace({\n      pathParams: { workspaceId: workspace },\n      ...this.extraProps\n    });\n  }\n\n  public updateWorkspace({\n    workspace,\n    update\n  }: {\n    workspace: Schemas.WorkspaceID;\n    update: Schemas.WorkspaceMeta;\n  }): Promise<Schemas.Workspace> {\n    return operationsByTag.workspaces.updateWorkspace({\n      pathParams: { workspaceId: workspace },\n      body: update,\n      ...this.extraProps\n    });\n  }\n\n  public deleteWorkspace({ workspace }: { workspace: Schemas.WorkspaceID }): Promise<void> {\n    return operationsByTag.workspaces.deleteWorkspace({\n      pathParams: { workspaceId: workspace },\n      ...this.extraProps\n    });\n  }\n\n  public getWorkspaceMembersList({ workspace }: { workspace: Schemas.WorkspaceID }): Promise<Schemas.WorkspaceMembers> {\n    return operationsByTag.workspaces.getWorkspaceMembersList({\n      pathParams: { workspaceId: workspace },\n      ...this.extraProps\n    });\n  }\n\n  public updateWorkspaceMemberRole({\n    workspace,\n    user,\n    role\n  }: {\n    workspace: Schemas.WorkspaceID;\n    user: Schemas.UserID;\n    role: Schemas.Role;\n  }): Promise<void> {\n    return operationsByTag.workspaces.updateWorkspaceMemberRole({\n      pathParams: { workspaceId: workspace, userId: user },\n      body: { role },\n      ...this.extraProps\n    });\n  }\n\n  public removeWorkspaceMember({\n    workspace,\n    user\n  }: {\n    workspace: Schemas.WorkspaceID;\n    user: Schemas.UserID;\n  }): Promise<void> {\n    return operationsByTag.workspaces.removeWorkspaceMember({\n      pathParams: { workspaceId: workspace, userId: user },\n      ...this.extraProps\n    });\n  }\n}\n\nclass InvitesApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public inviteWorkspaceMember({\n    workspace,\n    email,\n    role\n  }: {\n    workspace: Schemas.WorkspaceID;\n    email: string;\n    role: Schemas.Role;\n  }): Promise<Schemas.WorkspaceInvite> {\n    return operationsByTag.invites.inviteWorkspaceMember({\n      pathParams: { workspaceId: workspace },\n      body: { email, role },\n      ...this.extraProps\n    });\n  }\n\n  public updateWorkspaceMemberInvite({\n    workspace,\n    invite,\n    role\n  }: {\n    workspace: Schemas.WorkspaceID;\n    invite: Schemas.InviteID;\n    role: Schemas.Role;\n  }): Promise<Schemas.WorkspaceInvite> {\n    return operationsByTag.invites.updateWorkspaceMemberInvite({\n      pathParams: { workspaceId: workspace, inviteId: invite },\n      body: { role },\n      ...this.extraProps\n    });\n  }\n\n  public cancelWorkspaceMemberInvite({\n    workspace,\n    invite\n  }: {\n    workspace: Schemas.WorkspaceID;\n    invite: Schemas.InviteID;\n  }): Promise<void> {\n    return operationsByTag.invites.cancelWorkspaceMemberInvite({\n      pathParams: { workspaceId: workspace, inviteId: invite },\n      ...this.extraProps\n    });\n  }\n\n  public acceptWorkspaceMemberInvite({\n    workspace,\n    key\n  }: {\n    workspace: Schemas.WorkspaceID;\n    key: Schemas.InviteKey;\n  }): Promise<void> {\n    return operationsByTag.invites.acceptWorkspaceMemberInvite({\n      pathParams: { workspaceId: workspace, inviteKey: key },\n      ...this.extraProps\n    });\n  }\n\n  public resendWorkspaceMemberInvite({\n    workspace,\n    invite\n  }: {\n    workspace: Schemas.WorkspaceID;\n    invite: Schemas.InviteID;\n  }): Promise<void> {\n    return operationsByTag.invites.resendWorkspaceMemberInvite({\n      pathParams: { workspaceId: workspace, inviteId: invite },\n      ...this.extraProps\n    });\n  }\n}\n\nclass BranchApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getBranchList({\n    workspace,\n    region,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n  }): Promise<Schemas.ListBranchesResponse> {\n    return operationsByTag.branch.getBranchList({\n      pathParams: { workspace, region, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public getBranchDetails({\n    workspace,\n    region,\n    database,\n    branch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n  }): Promise<Schemas.DBBranch> {\n    return operationsByTag.branch.getBranchDetails({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      ...this.extraProps\n    });\n  }\n\n  public createBranch({\n    workspace,\n    region,\n    database,\n    branch,\n    from,\n    metadata\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    from?: string;\n    metadata?: Schemas.BranchMetadata;\n  }): Promise<Types.CreateBranchResponse> {\n    return operationsByTag.branch.createBranch({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { from, metadata },\n      ...this.extraProps\n    });\n  }\n\n  public deleteBranch({\n    workspace,\n    region,\n    database,\n    branch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n  }): Promise<Components.DeleteBranchResponse> {\n    return operationsByTag.branch.deleteBranch({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      ...this.extraProps\n    });\n  }\n\n  public copyBranch({\n    workspace,\n    region,\n    database,\n    branch,\n    destinationBranch,\n    limit\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    destinationBranch: Schemas.BranchName;\n    limit?: number;\n  }): Promise<Schemas.BranchWithCopyID> {\n    return operationsByTag.branch.copyBranch({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { destinationBranch, limit },\n      ...this.extraProps\n    });\n  }\n\n  public updateBranchMetadata({\n    workspace,\n    region,\n    database,\n    branch,\n    metadata\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    metadata: Schemas.BranchMetadata;\n  }): Promise<void> {\n    return operationsByTag.branch.updateBranchMetadata({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: metadata,\n      ...this.extraProps\n    });\n  }\n\n  public getBranchMetadata({\n    workspace,\n    region,\n    database,\n    branch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n  }): Promise<Schemas.BranchMetadata> {\n    return operationsByTag.branch.getBranchMetadata({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      ...this.extraProps\n    });\n  }\n\n  public getBranchStats({\n    workspace,\n    region,\n    database,\n    branch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n  }): Promise<Types.GetBranchStatsResponse> {\n    return operationsByTag.branch.getBranchStats({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      ...this.extraProps\n    });\n  }\n\n  public getGitBranchesMapping({\n    workspace,\n    region,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n  }): Promise<Schemas.ListGitBranchesResponse> {\n    return operationsByTag.branch.getGitBranchesMapping({\n      pathParams: { workspace, region, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public addGitBranchesEntry({\n    workspace,\n    region,\n    database,\n    gitBranch,\n    xataBranch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    gitBranch: string;\n    xataBranch: Schemas.BranchName;\n  }): Promise<Types.AddGitBranchesEntryResponse> {\n    return operationsByTag.branch.addGitBranchesEntry({\n      pathParams: { workspace, region, dbName: database },\n      body: { gitBranch, xataBranch },\n      ...this.extraProps\n    });\n  }\n\n  public removeGitBranchesEntry({\n    workspace,\n    region,\n    database,\n    gitBranch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    gitBranch: string;\n  }): Promise<void> {\n    return operationsByTag.branch.removeGitBranchesEntry({\n      pathParams: { workspace, region, dbName: database },\n      queryParams: { gitBranch },\n      ...this.extraProps\n    });\n  }\n\n  public resolveBranch({\n    workspace,\n    region,\n    database,\n    gitBranch,\n    fallbackBranch\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    gitBranch?: string;\n    fallbackBranch?: string;\n  }): Promise<Types.ResolveBranchResponse> {\n    return operationsByTag.branch.resolveBranch({\n      pathParams: { workspace, region, dbName: database },\n      queryParams: { gitBranch, fallbackBranch },\n      ...this.extraProps\n    });\n  }\n}\n\nclass TableApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public createTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n  }): Promise<Types.CreateTableResponse> {\n    return operationsByTag.table.createTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      ...this.extraProps\n    });\n  }\n\n  public deleteTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n  }): Promise<Components.DeleteTableResponse> {\n    return operationsByTag.table.deleteTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      ...this.extraProps\n    });\n  }\n\n  public updateTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    update\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    update: Types.UpdateTableRequestBody;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.table.updateTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: update,\n      ...this.extraProps\n    });\n  }\n\n  public getTableSchema({\n    workspace,\n    region,\n    database,\n    branch,\n    table\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n  }): Promise<Types.GetTableSchemaResponse> {\n    return operationsByTag.table.getTableSchema({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      ...this.extraProps\n    });\n  }\n\n  public setTableSchema({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    schema\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    schema: Types.SetTableSchemaRequestBody;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.table.setTableSchema({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: schema,\n      ...this.extraProps\n    });\n  }\n\n  public getTableColumns({\n    workspace,\n    region,\n    database,\n    branch,\n    table\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n  }): Promise<Types.GetTableColumnsResponse> {\n    return operationsByTag.table.getTableColumns({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      ...this.extraProps\n    });\n  }\n\n  public addTableColumn({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    column\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    column: Schemas.Column;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.table.addTableColumn({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: column,\n      ...this.extraProps\n    });\n  }\n\n  public getColumn({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    column\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    column: Schemas.ColumnName;\n  }): Promise<Schemas.Column> {\n    return operationsByTag.table.getColumn({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, columnName: column },\n      ...this.extraProps\n    });\n  }\n\n  public updateColumn({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    column,\n    update\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    column: Schemas.ColumnName;\n    update: Types.UpdateColumnRequestBody;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.table.updateColumn({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, columnName: column },\n      body: update,\n      ...this.extraProps\n    });\n  }\n\n  public deleteColumn({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    column\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    column: Schemas.ColumnName;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.table.deleteColumn({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, columnName: column },\n      ...this.extraProps\n    });\n  }\n}\n\nclass RecordsApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public insertRecord({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    columns\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Record<string, any>;\n    columns?: Schemas.ColumnsProjection;\n  }): Promise<Responses.RecordUpdateResponse> {\n    return operationsByTag.records.insertRecord({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      queryParams: { columns },\n      body: record,\n      ...this.extraProps\n    });\n  }\n\n  public getRecord({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    id,\n    columns\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    id: Schemas.RecordID;\n    columns?: Schemas.ColumnsProjection;\n  }): Promise<Schemas.XataRecord> {\n    return operationsByTag.records.getRecord({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, recordId: id },\n      queryParams: { columns },\n      ...this.extraProps\n    });\n  }\n\n  public insertRecordWithID({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    id,\n    record,\n    columns,\n    createOnly,\n    ifVersion\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    id: Schemas.RecordID;\n    record: Record<string, any>;\n    columns?: Schemas.ColumnsProjection;\n    createOnly?: boolean;\n    ifVersion?: number;\n  }): Promise<Responses.RecordUpdateResponse> {\n    return operationsByTag.records.insertRecordWithID({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, recordId: id },\n      queryParams: { columns, createOnly, ifVersion },\n      body: record,\n      ...this.extraProps\n    });\n  }\n\n  public updateRecordWithID({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    id,\n    record,\n    columns,\n    ifVersion\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    id: Schemas.RecordID;\n    record: Record<string, any>;\n    columns?: Schemas.ColumnsProjection;\n    ifVersion?: number;\n  }): Promise<Responses.RecordUpdateResponse> {\n    return operationsByTag.records.updateRecordWithID({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, recordId: id },\n      queryParams: { columns, ifVersion },\n      body: record,\n      ...this.extraProps\n    });\n  }\n\n  public upsertRecordWithID({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    id,\n    record,\n    columns,\n    ifVersion\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    id: Schemas.RecordID;\n    record: Record<string, any>;\n    columns?: Schemas.ColumnsProjection;\n    ifVersion?: number;\n  }): Promise<Responses.RecordUpdateResponse> {\n    return operationsByTag.records.upsertRecordWithID({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, recordId: id },\n      queryParams: { columns, ifVersion },\n      body: record,\n      ...this.extraProps\n    });\n  }\n\n  public deleteRecord({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    id,\n    columns\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    id: Schemas.RecordID;\n    columns?: Schemas.ColumnsProjection;\n  }): Promise<Responses.RecordUpdateResponse> {\n    return operationsByTag.records.deleteRecord({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, recordId: id },\n      queryParams: { columns },\n      ...this.extraProps\n    });\n  }\n\n  public bulkInsertTableRecords({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    records,\n    columns\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    records: Record<string, any>[];\n    columns?: Schemas.ColumnsProjection;\n  }): Promise<Responses.BulkInsertResponse> {\n    return operationsByTag.records.bulkInsertTableRecords({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      queryParams: { columns },\n      body: { records },\n      ...this.extraProps\n    });\n  }\n\n  public branchTransaction({\n    workspace,\n    region,\n    database,\n    branch,\n    operations\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    operations: Schemas.TransactionOperation[];\n  }): Promise<Schemas.TransactionSuccess> {\n    return operationsByTag.records.branchTransaction({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { operations },\n      ...this.extraProps\n    });\n  }\n}\n\nclass FilesApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getFileItem({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column,\n    fileId\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n    fileId: string;\n  }): Promise<any> {\n    return operationsByTag.files.getFileItem({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column,\n        fileId\n      },\n      ...this.extraProps\n    });\n  }\n\n  public putFileItem({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column,\n    fileId,\n    file\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n    fileId: string;\n    file: any;\n  }): Promise<Responses.PutFileResponse> {\n    return operationsByTag.files.putFileItem({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column,\n        fileId\n      },\n      // @ts-ignore\n      body: file,\n      ...this.extraProps\n    });\n  }\n\n  public deleteFileItem({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column,\n    fileId\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n    fileId: string;\n  }): Promise<Responses.PutFileResponse> {\n    return operationsByTag.files.deleteFileItem({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column,\n        fileId\n      },\n      ...this.extraProps\n    });\n  }\n\n  public getFile({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n  }): Promise<any> {\n    return operationsByTag.files.getFile({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column\n      },\n      ...this.extraProps\n    });\n  }\n\n  public putFile({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column,\n    file\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n    file: Blob;\n  }): Promise<Responses.PutFileResponse> {\n    return operationsByTag.files.putFile({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column\n      },\n      body: file,\n      ...this.extraProps\n    });\n  }\n\n  public deleteFile({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    record,\n    column\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    record: Schemas.RecordID;\n    column: Schemas.ColumnName;\n  }): Promise<Responses.PutFileResponse> {\n    return operationsByTag.files.deleteFile({\n      pathParams: {\n        workspace,\n        region,\n        dbBranchName: `${database}:${branch}`,\n        tableName: table,\n        recordId: record,\n        columnName: column\n      },\n      ...this.extraProps\n    });\n  }\n\n  public fileAccess({\n    workspace,\n    region,\n    fileId,\n    verify\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    fileId: string;\n    verify?: Schemas.FileSignature;\n  }): Promise<any> {\n    return operationsByTag.files.fileAccess({\n      pathParams: {\n        workspace,\n        region,\n        fileId\n      },\n      queryParams: { verify },\n      ...this.extraProps\n    });\n  }\n}\n\nclass SearchAndFilterApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public queryTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    filter,\n    sort,\n    page,\n    columns,\n    consistency\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    filter?: Schemas.FilterExpression;\n    sort?: Schemas.SortExpression;\n    page?: Schemas.PageConfig;\n    columns?: Schemas.ColumnsProjection;\n    consistency?: 'strong' | 'eventual';\n  }): Promise<Responses.QueryResponse> {\n    return operationsByTag.searchAndFilter.queryTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { filter, sort, page, columns, consistency },\n      ...this.extraProps\n    });\n  }\n\n  public searchTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    query,\n    fuzziness,\n    target,\n    prefix,\n    filter,\n    highlight,\n    boosters\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    query: string;\n    fuzziness?: Schemas.FuzzinessExpression;\n    target?: Schemas.TargetExpression;\n    prefix?: Schemas.PrefixExpression;\n    filter?: Schemas.FilterExpression;\n    highlight?: Schemas.HighlightExpression;\n    boosters?: Schemas.BoosterExpression[];\n  }): Promise<Responses.SearchResponse> {\n    return operationsByTag.searchAndFilter.searchTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { query, fuzziness, target, prefix, filter, highlight, boosters },\n      ...this.extraProps\n    });\n  }\n\n  public searchBranch({\n    workspace,\n    region,\n    database,\n    branch,\n    tables,\n    query,\n    fuzziness,\n    prefix,\n    highlight\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    tables?: (\n      | string\n      | {\n          table: string;\n          filter?: Schemas.FilterExpression;\n          target?: Schemas.TargetExpression;\n          boosters?: Schemas.BoosterExpression[];\n        }\n    )[];\n    query: string;\n    fuzziness?: Schemas.FuzzinessExpression;\n    prefix?: Schemas.PrefixExpression;\n    highlight?: Schemas.HighlightExpression;\n  }): Promise<Responses.SearchResponse> {\n    return operationsByTag.searchAndFilter.searchBranch({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { tables, query, fuzziness, prefix, highlight },\n      ...this.extraProps\n    });\n  }\n\n  public vectorSearchTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    queryVector,\n    column,\n    similarityFunction,\n    size,\n    filter\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    queryVector: number[];\n    column: string;\n    similarityFunction?: string;\n    size?: number;\n    filter?: Schemas.FilterExpression;\n  }): Promise<Responses.SearchResponse> {\n    return operationsByTag.searchAndFilter.vectorSearchTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { queryVector, column, similarityFunction, size, filter },\n      ...this.extraProps\n    });\n  }\n\n  public askTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    options\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    options: Components.AskTableRequestBody;\n  }): Promise<Components.AskTableResponse> {\n    return operationsByTag.searchAndFilter.askTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { ...options },\n      ...this.extraProps\n    });\n  }\n\n  public askTableSession({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    sessionId,\n    message\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    sessionId: string;\n    message: string;\n  }): Promise<Components.AskTableSessionResponse> {\n    return operationsByTag.searchAndFilter.askTableSession({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table, sessionId },\n      body: { message },\n      ...this.extraProps\n    });\n  }\n\n  public summarizeTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    filter,\n    columns,\n    summaries,\n    sort,\n    summariesFilter,\n    page,\n    consistency\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    filter?: Schemas.FilterExpression;\n    columns?: Schemas.ColumnsProjection;\n    summaries?: Schemas.SummaryExpressionList;\n    sort?: Schemas.SortExpression;\n    summariesFilter?: Schemas.FilterExpression;\n    page?: { size?: number };\n    consistency?: 'strong' | 'eventual';\n  }): Promise<Responses.SummarizeResponse> {\n    return operationsByTag.searchAndFilter.summarizeTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { filter, columns, summaries, sort, summariesFilter, page, consistency },\n      ...this.extraProps\n    });\n  }\n\n  public aggregateTable({\n    workspace,\n    region,\n    database,\n    branch,\n    table,\n    filter,\n    aggs\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    table: Schemas.TableName;\n    filter?: Schemas.FilterExpression;\n    aggs?: Schemas.AggExpressionMap;\n  }): Promise<Responses.AggResponse> {\n    return operationsByTag.searchAndFilter.aggregateTable({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, tableName: table },\n      body: { filter, aggs },\n      ...this.extraProps\n    });\n  }\n}\n\nclass MigrationRequestsApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public queryMigrationRequests({\n    workspace,\n    region,\n    database,\n    filter,\n    sort,\n    page,\n    columns\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    filter?: Schemas.FilterExpression;\n    sort?: Schemas.SortExpression;\n    page?: Schemas.PageConfig;\n    columns?: Schemas.ColumnsProjection;\n  }): Promise<Components.QueryMigrationRequestsResponse> {\n    return operationsByTag.migrationRequests.queryMigrationRequests({\n      pathParams: { workspace, region, dbName: database },\n      body: { filter, sort, page, columns },\n      ...this.extraProps\n    });\n  }\n\n  public createMigrationRequest({\n    workspace,\n    region,\n    database,\n    migration\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migration: Components.CreateMigrationRequestRequestBody;\n  }): Promise<Components.CreateMigrationRequestResponse> {\n    return operationsByTag.migrationRequests.createMigrationRequest({\n      pathParams: { workspace, region, dbName: database },\n      body: migration,\n      ...this.extraProps\n    });\n  }\n\n  public getMigrationRequest({\n    workspace,\n    region,\n    database,\n    migrationRequest\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n  }): Promise<Schemas.MigrationRequest> {\n    return operationsByTag.migrationRequests.getMigrationRequest({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      ...this.extraProps\n    });\n  }\n\n  public updateMigrationRequest({\n    workspace,\n    region,\n    database,\n    migrationRequest,\n    update\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n    update: Components.UpdateMigrationRequestRequestBody;\n  }): Promise<void> {\n    return operationsByTag.migrationRequests.updateMigrationRequest({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      body: update,\n      ...this.extraProps\n    });\n  }\n\n  public listMigrationRequestsCommits({\n    workspace,\n    region,\n    database,\n    migrationRequest,\n    page\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n    page?: { after?: string; before?: string; size?: number };\n  }): Promise<Components.ListMigrationRequestsCommitsResponse> {\n    return operationsByTag.migrationRequests.listMigrationRequestsCommits({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      body: { page },\n      ...this.extraProps\n    });\n  }\n\n  public compareMigrationRequest({\n    workspace,\n    region,\n    database,\n    migrationRequest\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n  }): Promise<Responses.SchemaCompareResponse> {\n    return operationsByTag.migrationRequests.compareMigrationRequest({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      ...this.extraProps\n    });\n  }\n\n  public getMigrationRequestIsMerged({\n    workspace,\n    region,\n    database,\n    migrationRequest\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n  }): Promise<Components.GetMigrationRequestIsMergedResponse> {\n    return operationsByTag.migrationRequests.getMigrationRequestIsMerged({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      ...this.extraProps\n    });\n  }\n\n  public mergeMigrationRequest({\n    workspace,\n    region,\n    database,\n    migrationRequest\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    migrationRequest: Schemas.MigrationRequestNumber;\n  }): Promise<Schemas.BranchOp> {\n    return operationsByTag.migrationRequests.mergeMigrationRequest({\n      pathParams: { workspace, region, dbName: database, mrNumber: migrationRequest },\n      ...this.extraProps\n    });\n  }\n}\n\nclass MigrationsApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getBranchMigrationHistory({\n    workspace,\n    region,\n    database,\n    branch,\n    limit,\n    startFrom\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    limit?: number;\n    startFrom?: string;\n  }): Promise<Types.GetBranchMigrationHistoryResponse> {\n    return operationsByTag.migrations.getBranchMigrationHistory({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { limit, startFrom },\n      ...this.extraProps\n    });\n  }\n\n  public getBranchMigrationPlan({\n    workspace,\n    region,\n    database,\n    branch,\n    schema\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    schema: Schemas.Schema;\n  }): Promise<Responses.BranchMigrationPlan> {\n    return operationsByTag.migrations.getBranchMigrationPlan({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: schema,\n      ...this.extraProps\n    });\n  }\n\n  public executeBranchMigrationPlan({\n    workspace,\n    region,\n    database,\n    branch,\n    plan\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    plan: Types.ExecuteBranchMigrationPlanRequestBody;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.migrations.executeBranchMigrationPlan({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: plan,\n      ...this.extraProps\n    });\n  }\n\n  public getBranchSchemaHistory({\n    workspace,\n    region,\n    database,\n    branch,\n    page\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    page?: { after?: string; before?: string; size?: number };\n  }): Promise<Types.GetBranchSchemaHistoryResponse> {\n    return operationsByTag.migrations.getBranchSchemaHistory({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { page },\n      ...this.extraProps\n    });\n  }\n\n  public compareBranchWithUserSchema({\n    workspace,\n    region,\n    database,\n    branch,\n    schema,\n    schemaOperations,\n    branchOperations\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    schema: Schemas.Schema;\n    schemaOperations?: Schemas.MigrationOp[];\n    branchOperations?: Schemas.MigrationOp[];\n  }): Promise<Responses.SchemaCompareResponse> {\n    return operationsByTag.migrations.compareBranchWithUserSchema({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { schema, schemaOperations, branchOperations },\n      ...this.extraProps\n    });\n  }\n\n  public compareBranchSchemas({\n    workspace,\n    region,\n    database,\n    branch,\n    compare,\n    sourceBranchOperations,\n    targetBranchOperations\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    compare: Schemas.BranchName;\n    sourceBranchOperations?: Schemas.MigrationOp[];\n    targetBranchOperations?: Schemas.MigrationOp[];\n  }): Promise<Responses.SchemaCompareResponse> {\n    return operationsByTag.migrations.compareBranchSchemas({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}`, branchName: compare },\n      body: { sourceBranchOperations, targetBranchOperations },\n      ...this.extraProps\n    });\n  }\n\n  public updateBranchSchema({\n    workspace,\n    region,\n    database,\n    branch,\n    migration\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    migration: Schemas.Migration;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.migrations.updateBranchSchema({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: migration,\n      ...this.extraProps\n    });\n  }\n\n  public previewBranchSchemaEdit({\n    workspace,\n    region,\n    database,\n    branch,\n    data\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    data: { edits?: Schemas.SchemaEditScript };\n  }): Promise<Components.PreviewBranchSchemaEditResponse> {\n    return operationsByTag.migrations.previewBranchSchemaEdit({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: data,\n      ...this.extraProps\n    });\n  }\n\n  public applyBranchSchemaEdit({\n    workspace,\n    region,\n    database,\n    branch,\n    edits\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    edits: Schemas.SchemaEditScript;\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.migrations.applyBranchSchemaEdit({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { edits },\n      ...this.extraProps\n    });\n  }\n\n  public pushBranchMigrations({\n    workspace,\n    region,\n    database,\n    branch,\n    migrations\n  }: {\n    workspace: Schemas.WorkspaceID;\n    region: string;\n    database: Schemas.DBName;\n    branch: Schemas.BranchName;\n    migrations: Schemas.MigrationObject[];\n  }): Promise<Responses.SchemaUpdateResponse> {\n    return operationsByTag.migrations.pushBranchMigrations({\n      pathParams: { workspace, region, dbBranchName: `${database}:${branch}` },\n      body: { migrations },\n      ...this.extraProps\n    });\n  }\n}\n\nclass DatabaseApi {\n  constructor(private extraProps: ApiExtraProps) {}\n\n  public getDatabaseList({ workspace }: { workspace: Schemas.WorkspaceID }): Promise<Schemas.ListDatabasesResponse> {\n    return operationsByTag.databases.getDatabaseList({\n      pathParams: { workspaceId: workspace },\n      ...this.extraProps\n    });\n  }\n\n  public createDatabase({\n    workspace,\n    database,\n    data,\n    headers\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n    data: Components.CreateDatabaseRequestBody;\n    headers?: Record<string, string>;\n  }): Promise<Components.CreateDatabaseResponse> {\n    return operationsByTag.databases.createDatabase({\n      pathParams: { workspaceId: workspace, dbName: database },\n      body: data,\n      headers,\n      ...this.extraProps\n    });\n  }\n\n  public deleteDatabase({\n    workspace,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n  }): Promise<Components.DeleteDatabaseResponse> {\n    return operationsByTag.databases.deleteDatabase({\n      pathParams: { workspaceId: workspace, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public getDatabaseMetadata({\n    workspace,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n  }): Promise<Schemas.DatabaseMetadata> {\n    return operationsByTag.databases.getDatabaseMetadata({\n      pathParams: { workspaceId: workspace, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public updateDatabaseMetadata({\n    workspace,\n    database,\n    metadata\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n    metadata: Schemas.DatabaseMetadata;\n  }): Promise<Schemas.DatabaseMetadata> {\n    return operationsByTag.databases.updateDatabaseMetadata({\n      pathParams: { workspaceId: workspace, dbName: database },\n      body: metadata,\n      ...this.extraProps\n    });\n  }\n\n  public renameDatabase({\n    workspace,\n    database,\n    newName\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n    newName: Schemas.DBName;\n  }): Promise<Schemas.DatabaseMetadata> {\n    return operationsByTag.databases.renameDatabase({\n      pathParams: { workspaceId: workspace, dbName: database },\n      body: { newName },\n      ...this.extraProps\n    });\n  }\n\n  public getDatabaseGithubSettings({\n    workspace,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n  }): Promise<Schemas.DatabaseGithubSettings> {\n    return operationsByTag.databases.getDatabaseGithubSettings({\n      pathParams: { workspaceId: workspace, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public updateDatabaseGithubSettings({\n    workspace,\n    database,\n    settings\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n    settings: Schemas.DatabaseGithubSettings;\n  }): Promise<Schemas.DatabaseGithubSettings> {\n    return operationsByTag.databases.updateDatabaseGithubSettings({\n      pathParams: { workspaceId: workspace, dbName: database },\n      body: settings,\n      ...this.extraProps\n    });\n  }\n\n  public deleteDatabaseGithubSettings({\n    workspace,\n    database\n  }: {\n    workspace: Schemas.WorkspaceID;\n    database: Schemas.DBName;\n  }): Promise<void> {\n    return operationsByTag.databases.deleteDatabaseGithubSettings({\n      pathParams: { workspaceId: workspace, dbName: database },\n      ...this.extraProps\n    });\n  }\n\n  public listRegions({ workspace }: { workspace: Schemas.WorkspaceID }): Promise<Schemas.ListRegionsResponse> {\n    return operationsByTag.databases.listRegions({\n      pathParams: { workspaceId: workspace },\n      ...this.extraProps\n    });\n  }\n}\n","import { XataPlugin, XataPluginOptions } from '../plugins';\nimport { XataApiClient } from './client';\nimport { operationsByTag } from './components';\nimport type * as Responses from './responses';\nimport type * as Schemas from './schemas';\n\nexport type { FetchImpl } from '../util/fetch';\nexport * from './client';\nexport * from './components';\nexport { FetcherError } from './errors';\nexport type { FetcherExtraProps } from './fetcher';\nexport * from './providers';\nexport { operationsByTag as Operations };\nexport type { Responses, Schemas };\n\nexport class XataApiPlugin implements XataPlugin {\n  build(options: XataPluginOptions) {\n    return new XataApiClient(options);\n  }\n}\n","import { ApiExtraProps, HostProvider } from './api';\nimport { CacheImpl } from './schema/cache';\n\nexport abstract class XataPlugin {\n  abstract build(options: XataPluginOptions): unknown;\n}\n\nexport type XataPluginOptions = ApiExtraProps & {\n  cache: CacheImpl;\n  host: HostProvider;\n};\n","import { isDefined } from '../util/lang';\n\n// Example of private URLs\n// https://us-west-2.xata.sh/file/id?verify=mrkusp0000000vd3i4bgi51glgk73f33g2uvibuc35kqne5ckiohoflsekv56f0r\n// https://us-west-2.xata.sh/transform/rotate=90/file/id?verify=mrkusp0000000vd3i4bgi51glgk73f33g2uvibuc35kqne5ckiohoflsekv56f0r\n// Example of public URLs\n// https://us-west-2.storage.xata.sh/id\n// https://us-west-2.storage.xata.sh/transform/rotate=90/id\n\nexport interface ImageTransformations {\n  /**\n   * Whether to preserve animation frames from input files. Default is true.\n   * Setting it to false reduces animations to still images. This setting is\n   * recommended when enlarging images or processing arbitrary user content,\n   * because large GIF animations can weigh tens or even hundreds of megabytes.\n   * It is also useful to set anim:false when using format:\"json\" to get the\n   * response quicker without the number of frames.\n   */\n  anim?: boolean;\n  /**\n   * Background color to add underneath the image. Applies only to images with\n   * transparency (such as PNG). Accepts any CSS color (#RRGGBB, rgba(),\n   * hsl(), etc.)\n   */\n  background?: string;\n  /**\n   * Radius of a blur filter (approximate gaussian). Maximum supported radius\n   * is 250.\n   */\n  blur?: number;\n  /**\n   * Increase brightness by a factor. A value of 1.0 equals no change, a value\n   * of 0.5 equals half brightness, and a value of 2.0 equals twice as bright.\n   * 0 is ignored.\n   */\n  brightness?: number;\n  /**\n   * Slightly reduces latency on a cache miss by selecting a\n   * quickest-to-compress file format, at a cost of increased file size and\n   * lower image quality. It will usually override the format option and choose\n   * JPEG over WebP or AVIF. We do not recommend using this option, except in\n   * unusual circumstances like resizing uncacheable dynamically-generated\n   * images.\n   */\n  compression?: 'fast';\n  /**\n   * Increase contrast by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 equals low contrast, and a value of 2.0 equals high contrast. 0 is\n   * ignored.\n   */\n  contrast?: number;\n  /**\n   * Download file. Forces browser to download the image.\n   * Value is used for the download file name. Extension is optional.\n   */\n  download?: string;\n  /**\n   * Device Pixel Ratio. Default 1. Multiplier for width/height that makes it\n   * easier to specify higher-DPI sizes in <img srcset>.\n   */\n  dpr?: number;\n  /**\n   * Resizing mode as a string. It affects interpretation of width and height\n   * options:\n   *  - scale-down: Similar to contain, but the image is never enlarged. If\n   *    the image is larger than given width or height, it will be resized.\n   *    Otherwise its original size will be kept.\n   *  - contain: Resizes to maximum size that fits within the given width and\n   *    height. If only a single dimension is given (e.g. only width), the\n   *    image will be shrunk or enlarged to exactly match that dimension.\n   *    Aspect ratio is always preserved.\n   *  - cover: Resizes (shrinks or enlarges) to fill the entire area of width\n   *    and height. If the image has an aspect ratio different from the ratio\n   *    of width and height, it will be cropped to fit.\n   *  - crop: The image will be shrunk and cropped to fit within the area\n   *    specified by width and height. The image will not be enlarged. For images\n   *    smaller than the given dimensions it's the same as scale-down. For\n   *    images larger than the given dimensions, it's the same as cover.\n   *    See also trim.\n   *  - pad: Resizes to the maximum size that fits within the given width and\n   *    height, and then fills the remaining area with a background color\n   *    (white by default). Use of this mode is not recommended, as the same\n   *    effect can be more efficiently achieved with the contain mode and the\n   *    CSS object-fit: contain property.\n   */\n  fit?: 'scale-down' | 'contain' | 'cover' | 'crop' | 'pad';\n  /**\n   * Output format to generate. It can be:\n   *  - avif: generate images in AVIF format.\n   *  - webp: generate images in Google WebP format. Set quality to 100 to get\n   *    the WebP-lossless format.\n   *  - json: instead of generating an image, outputs information about the\n   *    image, in JSON format. The JSON object will contain image size\n   *    (before and after resizing), source images MIME type, file size, etc.\n   * - jpeg: generate images in JPEG format.\n   * - png: generate images in PNG format.\n   */\n  format?: 'auto' | 'avif' | 'webp' | 'json' | 'jpeg' | 'png';\n  /**\n   * Increase exposure by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 darkens the image, and a value of 2.0 lightens the image. 0 is ignored.\n   */\n  gamma?: number;\n  /**\n   * When cropping with fit: \"cover\", this defines the side or point that should\n   * be left uncropped. The value is either a string\n   * \"left\", \"right\", \"top\", \"bottom\", \"auto\", or \"center\" (the default),\n   * or an object {x, y} containing focal point coordinates in the original\n   * image expressed as fractions ranging from 0.0 (top or left) to 1.0\n   * (bottom or right), 0.5 being the center. {fit: \"cover\", gravity: \"top\"} will\n   * crop bottom or left and right sides as necessary, but wont crop anything\n   * from the top. {fit: \"cover\", gravity: {x:0.5, y:0.2}} will crop each side to\n   * preserve as much as possible around a point at 20% of the height of the\n   * source image.\n   */\n  gravity?: 'left' | 'right' | 'top' | 'bottom' | 'center' | 'auto' | { x: number; y: number };\n  /**\n   * Maximum height in image pixels. The value must be an integer.\n   */\n  height?: number;\n  /**\n   * What EXIF data should be preserved in the output image. Note that EXIF\n   * rotation and embedded color profiles are always applied (\"baked in\" into\n   * the image), and aren't affected by this option. Note that if the Polish\n   * feature is enabled, all metadata may have been removed already and this\n   * option may have no effect.\n   *  - keep: Preserve most of EXIF metadata, including GPS location if there's\n   *    any.\n   *  - copyright: Only keep the copyright tag, and discard everything else.\n   *    This is the default behavior for JPEG files.\n   *  - none: Discard all invisible EXIF metadata. Currently WebP and PNG\n   *    output formats always discard metadata.\n   */\n  metadata?: 'keep' | 'copyright' | 'none';\n  /**\n   * Quality setting from 1-100 (useful values are in 60-90 range). Lower values\n   * make images look worse, but load faster. The default is 85. It applies only\n   * to JPEG and WebP images. It doesnt have any effect on PNG.\n   */\n  quality?: number;\n  /**\n   * Number of degrees (90, 180, 270) to rotate the image by. width and height\n   * options refer to axes after rotation.\n   */\n  rotate?: 0 | 90 | 180 | 270 | 360;\n  /**\n   * Strength of sharpening filter to apply to the image. Floating-point\n   * number between 0 (no sharpening, default) and 10 (maximum). 1.0 is a\n   * recommended value for downscaled images.\n   */\n  sharpen?: number;\n  /**\n   * An object with four properties {left, top, right, bottom} that specify\n   * a number of pixels to cut off on each side. Allows removal of borders\n   * or cutting out a specific fragment of an image. Trimming is performed\n   * before resizing or rotation. Takes dpr into account.\n   */\n  trim?: {\n    left?: number;\n    top?: number;\n    right?: number;\n    bottom?: number;\n  };\n  /**\n   * Maximum width in image pixels. The value must be an integer.\n   */\n  width?: number;\n}\n\nexport function buildTransformString(transformations: ImageTransformations[]): string {\n  return transformations\n    .flatMap((t) =>\n      Object.entries(t).map(([key, value]) => {\n        // Trim: top;right;bottom;left\n        if (key === 'trim') {\n          const { left = 0, top = 0, right = 0, bottom = 0 } = value;\n          return `${key}=${[top, right, bottom, left].join(';')}`;\n        }\n\n        // Gravity: 0x1\n        if (key === 'gravity' && typeof value === 'object') {\n          const { x = 0.5, y = 0.5 } = value;\n          return `${key}=${[x, y].join('x')}`;\n        }\n\n        return `${key}=${value}`;\n      })\n    )\n    .join(',');\n}\n\nexport function transformImage(url: string, ...transformations: ImageTransformations[]): string;\nexport function transformImage(url: string | undefined, ...transformations: ImageTransformations[]): string | undefined;\nexport function transformImage(url: string | undefined, ...transformations: ImageTransformations[]) {\n  if (!isDefined(url)) return undefined;\n\n  const newTransformations = buildTransformString(transformations);\n\n  const { hostname, pathname, search } = new URL(url);\n\n  // If pathname includes transform, we need to remove them\n  const pathParts = pathname.split('/');\n  const transformIndex = pathParts.findIndex((part) => part === 'transform');\n  const removedItems = transformIndex >= 0 ? pathParts.splice(transformIndex, 2) : [];\n\n  // Build the new URL parts\n  const transform = `/transform/${[removedItems[1], newTransformations].filter(isDefined).join(',')}`;\n  const path = pathParts.join('/');\n\n  return `https://${hostname}${transform}${path}${search}`;\n}\n","import { InputFileEntry } from '../api/schemas';\nimport { ImageTransformations, transformImage } from '../files/transformations';\nimport { compactObject, isDefined } from '../util/lang';\nimport { StringKeys } from '../util/types';\nimport { Identifiable, InputXataFile } from './record';\n\nexport type XataFileEditableFields = Partial<Pick<XataArrayFile, keyof InputFileEntry>>;\nexport type XataFileFields = Partial<\n  Pick<\n    XataArrayFile,\n    { [K in StringKeys<XataArrayFile>]: XataArrayFile[K] extends Function ? never : K }[keyof XataArrayFile]\n  >\n>;\n\nexport class XataFile {\n  /**\n   * Identifier of the file.\n   */\n  public id?: string;\n  /**\n   * Name of the file.\n   */\n  public name: string;\n  /**\n   * Media type of the file.\n   */\n  public mediaType: string;\n  /**\n   * Base64 encoded content of the file.\n   */\n  public base64Content?: string;\n  /**\n   * Whether to enable public url for the file.\n   */\n  public enablePublicUrl: boolean;\n  /**\n   * Timeout for the signed url.\n   */\n  public signedUrlTimeout: number;\n  /**\n   * Size of the file.\n   */\n  public size?: number;\n  /**\n   * Version of the file.\n   */\n  public version: number;\n  /**\n   * Url of the file.\n   */\n  public url: string;\n  /**\n   * Signed url of the file.\n   */\n  public signedUrl?: string;\n  /**\n   * Attributes of the file.\n   */\n  public attributes: Record<string, any>;\n\n  constructor(file: Partial<XataFile>) {\n    this.id = file.id;\n    this.name = file.name || '';\n    this.mediaType = file.mediaType || 'application/octet-stream';\n    this.base64Content = file.base64Content;\n    this.enablePublicUrl = file.enablePublicUrl ?? false;\n    this.signedUrlTimeout = file.signedUrlTimeout ?? 300;\n    this.size = file.size ?? 0;\n    this.version = file.version ?? 1;\n    this.url = file.url || '';\n    this.signedUrl = file.signedUrl;\n    this.attributes = file.attributes || {};\n  }\n\n  static fromBuffer(buffer: Buffer, options: XataFileEditableFields = {}): XataFile {\n    const base64Content = buffer.toString('base64');\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toBuffer(): Buffer {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return Buffer.from(this.base64Content, 'base64');\n  }\n\n  static fromArrayBuffer(arrayBuffer: ArrayBuffer, options: XataFileEditableFields = {}) {\n    const uint8Array = new Uint8Array(arrayBuffer);\n    return this.fromUint8Array(uint8Array, options);\n  }\n\n  public toArrayBuffer(): ArrayBuffer {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    return new ArrayBuffer(binary.length);\n  }\n\n  static fromUint8Array(uint8Array: Uint8Array, options: XataFileEditableFields = {}) {\n    let binary = '';\n\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n      binary += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64Content = btoa(binary);\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toUint8Array(): Uint8Array {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    const uint8Array = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      uint8Array[i] = binary.charCodeAt(i);\n    }\n\n    return uint8Array;\n  }\n\n  static async fromBlob(file: Blob, options: XataFileEditableFields = {}) {\n    // @ts-ignore - Blob doesn't have a name property, File which extends Blob does\n    const name = options.name ?? file.name;\n    const mediaType = file.type;\n    const arrayBuffer = await file.arrayBuffer();\n\n    return this.fromArrayBuffer(arrayBuffer, { ...options, name, mediaType });\n  }\n\n  public toBlob(): Blob {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    const uint8Array = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      uint8Array[i] = binary.charCodeAt(i);\n    }\n\n    return new Blob([uint8Array], { type: this.mediaType });\n  }\n\n  static fromString(string: string, options: XataFileEditableFields = {}): XataFile {\n    const base64Content = btoa(string);\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toString(): string {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return atob(this.base64Content);\n  }\n\n  static fromBase64(base64Content: string, options: XataFileEditableFields = {}): XataFile {\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toBase64(): string {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return this.base64Content;\n  }\n\n  public transform(...options: ImageTransformations[]) {\n    return {\n      url: transformImage(this.url, ...options),\n      signedUrl: transformImage(this.signedUrl, ...options),\n      metadataUrl: transformImage(this.url, ...options, { format: 'json' }),\n      metadataSignedUrl: transformImage(this.signedUrl, ...options, { format: 'json' })\n    };\n  }\n}\n\nexport type XataArrayFile = Identifiable & XataFile;\n\nexport const parseInputFileEntry = async (entry: InputXataFile): Promise<InputFileEntry | null> => {\n  if (!isDefined(entry)) return null;\n\n  const { id, name, mediaType, base64Content, enablePublicUrl, signedUrlTimeout } = await entry;\n  return compactObject({\n    id,\n    // Name cannot be an empty string in our API\n    name: name ? name : undefined,\n    mediaType,\n    base64Content,\n    enablePublicUrl,\n    signedUrlTimeout\n  });\n};\n","import { FilterExpression, FilterPredicate } from '../api/schemas';\nimport { isDefined, isObject } from '../util/lang';\nimport { SingleOrArray, Values } from '../util/types';\nimport { JSONValue } from './json';\nimport { XataRecordMetadata } from './record';\nimport { ColumnsByValue, ValueAtColumn } from './selection';\n\nexport type JSONFilterColumns<Record> = Values<{\n  [K in keyof Record]: NonNullable<Record[K]> extends JSONValue<any>\n    ? K extends string\n      ? `${K}->${string}`\n      : never\n    : never;\n}>;\n\nexport type FilterColumns<T> = ColumnsByValue<T, any> | `xata.${keyof XataRecordMetadata}`;\n\nexport type FilterValueAtColumn<Record, F> = NonNullable<ValueAtColumn<Record, F>> extends JSONValue<any>\n  ? PropertyFilter<any>\n  : Filter<NonNullable<ValueAtColumn<Record, F>>>;\n\n/**\n * PropertyMatchFilter\n * Example:\n{\n  \"filter\": {\n    \"name\": \"value\",\n    \"name\": {\n       \"$is\":  \"value\",\n       \"$any\": [ \"value1\", \"value2\" ],\n    },\n    \"settings.plan\": {\"$any\": [\"free\", \"paid\"]},\n    \"settings.plan\": \"free\",\n    \"settings\": {\n      \"plan\": \"free\"\n    },\n  }\n}\n*/\ntype PropertyAccessFilter<Record> = {\n  [key in FilterColumns<Record>]?:\n    | NestedApiFilter<ValueAtColumn<Record, key>>\n    | PropertyFilter<ValueAtColumn<Record, key>>;\n} & {\n  [key in JSONFilterColumns<Record>]?: PropertyFilter<Record[keyof Record]>;\n};\n\nexport type PropertyFilter<T> = T | { $is: T } | { $isNot: T } | { $any: T[] } | { $none: T[] } | ValueTypeFilters<T>;\n\ntype IncludesFilter<T> =\n  | PropertyFilter<T>\n  | {\n      [key in '$all' | '$none' | '$any']?: IncludesFilter<T> | Array<IncludesFilter<T> | { $not: IncludesFilter<T> }>;\n    };\n\nexport type StringTypeFilter = {\n  [key in '$contains' | '$iContains' | '$pattern' | '$iPattern' | '$startsWith' | '$endsWith']?: string;\n};\nexport type ComparableType = number | Date;\nexport type ComparableTypeFilter<T extends ComparableType> = { [key in '$gt' | '$lt' | '$ge' | '$le']?: T };\nexport type ArrayFilter<T> =\n  | {\n      [key in '$includes']?: SingleOrArray<PropertyFilter<T> | ValueTypeFilters<T>> | IncludesFilter<T>;\n    }\n  | {\n      [key in '$includesAll' | '$includesNone' | '$includesAny']?:\n        | T\n        | Array<PropertyFilter<T> | { $not: PropertyFilter<T> }>;\n    };\n\ntype ValueTypeFilters<T> = T | T extends string\n  ? StringTypeFilter\n  : T extends number\n  ? ComparableTypeFilter<number>\n  : T extends Date\n  ? ComparableTypeFilter<Date>\n  : T extends Array<infer T>\n  ? ArrayFilter<T>\n  : never;\n\n/**\n * AggregatorFilter\n * Example:\n{\n  \"filter\": {\n      \"$any\": {\n        \"settings.dark\": true,\n        \"settings.plan\": \"free\"\n      }\n  },\n}\n{\n  \"filter\": {\n    \"$any\": [\n      {\n        \"name\": \"r1\",\n      },\n      {\n        \"name\": \"r2\",\n      },\n    ],\n}\n*/\ntype AggregatorFilter<T> = {\n  [key in '$all' | '$any' | '$not' | '$none']?: SingleOrArray<Filter<T>>;\n};\n\n/**\n * Existance filter\n * Example: { filter: { $exists: \"settings\" } }\n */\nexport type ExistanceFilter<Record> = {\n  [key in '$exists' | '$notExists']?: FilterColumns<Record>;\n};\n\ntype BaseApiFilter<Record> = PropertyAccessFilter<Record> | AggregatorFilter<Record> | ExistanceFilter<Record>;\n\n/**\n * Nested filter\n * Injects the Api filters on nested properties\n * Example: { filter: { settings: { plan: { $any: ['free', 'trial'] } } } }\n */\ntype NestedApiFilter<T> = {\n  [key in keyof T]?: T[key] extends Record<string, any> ? SingleOrArray<Filter<T[key]>> : PropertyFilter<T[key]>;\n};\n\nexport type Filter<T> = T extends Record<string, any>\n  ? T extends (infer ArrayType)[] // Arrays have a special filter\n    ? ArrayType | ArrayType[] | ArrayFilter<ArrayType> | ArrayFilter<ArrayType[]>\n    : T extends Date // Date extends object but we treat it as a primitive\n    ? PropertyFilter<T>\n    : BaseApiFilter<T> | NestedApiFilter<T>\n  : PropertyFilter<T>;\n\nexport function cleanFilter(filter?: FilterExpression | FilterPredicate): any {\n  if (!isDefined(filter)) return undefined;\n  if (!isObject(filter)) return filter;\n\n  const values = Object.fromEntries(\n    Object.entries(filter).reduce((acc, [key, value]) => {\n      // Remove null and undefined values\n      if (!isDefined(value)) return acc;\n\n      if (Array.isArray(value)) {\n        // Remove empty objects from arrays\n        const clean = value.map((item) => cleanFilter(item)).filter((item) => isDefined(item));\n\n        // Remove empty arrays\n        if (clean.length === 0) return acc;\n\n        return [...acc, [key, clean]];\n      }\n\n      if (isObject(value)) {\n        // Remove empty objects\n        const clean = cleanFilter(value);\n        if (!isDefined(clean)) return acc;\n\n        return [...acc, [key, clean]];\n      }\n\n      return [...acc, [key, value]];\n    }, [] as [string, any][])\n  );\n\n  return Object.keys(values).length > 0 ? values : undefined;\n}\n","import { isDefined, isString } from '../util/lang';\n\nexport type JSONValue<Value> = Value & { __json: true };\n\nexport function stringifyJson(value: string): string;\nexport function stringifyJson(value: null): null;\nexport function stringifyJson(value: undefined): undefined;\nexport function stringifyJson(value: string | null | undefined): string | null | undefined;\nexport function stringifyJson(value: any): string | null | undefined;\nexport function stringifyJson(value: any) {\n  if (!isDefined(value)) return value;\n  if (isString(value)) return value;\n\n  try {\n    return JSON.stringify(value);\n  } catch (e) {\n    return value;\n  }\n}\n\nexport function parseJson(value: string) {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    return value;\n  }\n}\n","import { isDefined, isObject } from '../util/lang';\nimport { Query } from './query';\nimport { JSONData, XataRecord } from './record';\n\nexport type PaginationQueryMeta = { page: { cursor: string; more: boolean; size: number } };\n\nexport interface Paginable<Record extends XataRecord, Result extends XataRecord = Record> {\n  meta: PaginationQueryMeta;\n  records: RecordArray<Result>;\n\n  nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  startPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  endPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n\n  hasNextPage(): boolean;\n}\n\n/**\n * A Page contains a set of results from a query plus metadata about the retrieved\n * set of values such as the cursor, required to retrieve additional records.\n */\nexport class Page<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {\n  #query: Query<Record, Result>;\n  /**\n   * Page metadata, required to retrieve additional records.\n   */\n  readonly meta: PaginationQueryMeta;\n  /**\n   * The set of results for this page.\n   */\n  readonly records: RecordArray<Result>;\n\n  constructor(query: Query<Record, Result>, meta: PaginationQueryMeta, records: Result[] = []) {\n    this.#query = query;\n    this.meta = meta;\n    this.records = new RecordArray(this, records);\n  }\n\n  /**\n   * Retrieves the next page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The next page or results.\n   */\n  async nextPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, after: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the previous page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The previous page or results.\n   */\n  async previousPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, before: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the start page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The start page or results.\n   */\n  async startPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, start: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the end page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The end page or results.\n   */\n  async endPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, end: this.meta.page.cursor } });\n  }\n\n  /**\n   * Shortcut method to check if there will be additional results if the next page of results is retrieved.\n   * @returns Whether or not there will be additional results in the next page of results.\n   */\n  hasNextPage(): boolean {\n    return this.meta.page.more;\n  }\n}\n\nexport type CursorNavigationOptions = { start?: string } | { end?: string } | { after?: string; before?: string };\nexport type OffsetNavigationOptions = { size?: number; offset?: number };\n\nexport const PAGINATION_MAX_SIZE = 1000;\nexport const PAGINATION_DEFAULT_SIZE = 20;\nexport const PAGINATION_MAX_OFFSET = 49000;\nexport const PAGINATION_DEFAULT_OFFSET = 0;\n\nexport function isCursorPaginationOptions(\n  options: Record<string, unknown> | undefined | null\n): options is CursorNavigationOptions {\n  return (\n    isDefined(options) &&\n    (isDefined(options.start) || isDefined(options.end) || isDefined(options.after) || isDefined(options.before))\n  );\n}\n\nexport class RecordArray<Result extends XataRecord> extends Array<Result> {\n  #page: Paginable<Result, Result>;\n\n  constructor(page: Paginable<any, Result>, overrideRecords?: Result[]);\n  constructor(...args: any[]) {\n    super(...RecordArray.parseConstructorParams(...args));\n\n    // In the case of serialization/deserialization, the page might be lost\n    this.#page = isObject(args[0]?.meta) ? args[0] : { meta: { page: { cursor: '', more: false } }, records: [] };\n  }\n\n  static parseConstructorParams(...args: any[]) {\n    // new <T>(arrayLength: number): T[]\n    if (args.length === 1 && typeof args[0] === 'number') {\n      return new Array(args[0]);\n    }\n\n    // new RecordArray<T>(page: Page, overrideRecords: Array | undefined): T[>]\n    if (args.length <= 2 && isObject(args[0]?.meta) && Array.isArray(args[1] ?? [])) {\n      const result = args[1] ?? args[0].records ?? [];\n      return new Array(...result);\n    }\n\n    // <T>(...items: T[]): T[]\n    return new Array(...args);\n  }\n\n  toArray(): Result[] {\n    return new Array(...this);\n  }\n\n  toSerializable(): JSONData<Result>[] {\n    return JSON.parse(this.toString());\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toArray());\n  }\n\n  map<U>(callbackfn: (value: Result, index: number, array: Result[]) => U, thisArg?: any): U[] {\n    return this.toArray().map(callbackfn, thisArg);\n  }\n\n  /**\n   * Retrieve next page of records\n   *\n   * @returns A new array of objects\n   */\n  async nextPage(size?: number, offset?: number): Promise<RecordArray<Result>> {\n    const newPage = await this.#page.nextPage(size, offset);\n    return new RecordArray(newPage);\n  }\n\n  /**\n   * Retrieve previous page of records\n   *\n   * @returns A new array of objects\n   */\n  async previousPage(size?: number, offset?: number): Promise<RecordArray<Result>> {\n    const newPage = await this.#page.previousPage(size, offset);\n    return new RecordArray(newPage);\n  }\n\n  /**\n   * Retrieve start page of records\n   *\n   * @returns A new array of objects\n   */\n  async startPage(size?: number, offset?: number): Promise<RecordArray<Result>> {\n    const newPage = await this.#page.startPage(size, offset);\n    return new RecordArray(newPage);\n  }\n\n  /**\n   * Retrieve end page of records\n   *\n   * @returns A new array of objects\n   */\n  async endPage(size?: number, offset?: number): Promise<RecordArray<Result>> {\n    const newPage = await this.#page.endPage(size, offset);\n    return new RecordArray(newPage);\n  }\n\n  /**\n   * @returns Boolean indicating if there is a next page\n   */\n  hasNextPage(): boolean {\n    return this.#page.meta.page.more;\n  }\n}\n","import { Schemas } from '../api';\nimport { FilterExpression } from '../api/schemas';\nimport { compact, isDefined, isObject, isString, isStringArray, toBase64 } from '../util/lang';\nimport { Dictionary, OmitBy, RequiredBy, SingleOrArray } from '../util/types';\nimport { Filter, FilterColumns, FilterValueAtColumn, JSONFilterColumns } from './filters';\nimport {\n  CursorNavigationOptions,\n  OffsetNavigationOptions,\n  PAGINATION_DEFAULT_SIZE,\n  PAGINATION_MAX_SIZE,\n  Page,\n  Paginable,\n  PaginationQueryMeta,\n  RecordArray,\n  isCursorPaginationOptions\n} from './pagination';\nimport { XataRecord } from './record';\nimport { RestRepository } from './repository';\nimport { SelectableColumn, SelectableColumnWithObjectNotation, SelectedPick } from './selection';\nimport { SortColumns, SortDirection, SortFilter } from './sorting';\nimport { SummarizeExpression, SummarizeParams, SummarizeResult } from './summarize';\n\ntype BaseOptions<T extends XataRecord> = {\n  columns?: SelectableColumnWithObjectNotation<T>[];\n  consistency?: 'strong' | 'eventual';\n  cache?: number;\n  fetchOptions?: Record<string, unknown>;\n};\n\ntype CursorQueryOptions = {\n  pagination?: CursorNavigationOptions & OffsetNavigationOptions;\n  filter?: never;\n  sort?: never;\n};\n\ntype OffsetQueryOptions<T extends XataRecord> = {\n  pagination?: OffsetNavigationOptions;\n  filter?: FilterExpression;\n  sort?: SingleOrArray<SortFilter<T>>;\n};\n\nexport type QueryOptions<T extends XataRecord> = BaseOptions<T> & (CursorQueryOptions | OffsetQueryOptions<T>);\n\n/**\n * Query objects contain the information of all filters, sorting, etc. to be included in the database query.\n *\n * Query objects are immutable. Any method that adds more constraints or options to the query will return\n * a new Query object containing the both the previous and the new constraints and options.\n */\nexport class Query<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {\n  #table: { name: string; schema?: Schemas.Table };\n  #repository: RestRepository<Record>;\n  #data: QueryOptions<Record> = { filter: {} };\n\n  // Implements pagination\n  readonly meta: PaginationQueryMeta = { page: { cursor: 'start', more: true, size: PAGINATION_DEFAULT_SIZE } };\n  readonly records: RecordArray<Result> = new RecordArray<Result>(this, []);\n\n  constructor(\n    repository: RestRepository<Record> | null,\n    table: { name: string; schema?: Schemas.Table },\n    data: Partial<QueryOptions<Record>>,\n    rawParent?: Partial<QueryOptions<Record>>\n  ) {\n    this.#table = table;\n\n    if (repository) {\n      this.#repository = repository;\n    } else {\n      this.#repository = this as any;\n    }\n\n    // Clean parent query options if new query is cursor based\n    const parent = cleanParent(data, rawParent);\n\n    this.#data.filter = data.filter ?? parent?.filter ?? {};\n    this.#data.filter.$any = data.filter?.$any ?? parent?.filter?.$any;\n    this.#data.filter.$all = data.filter?.$all ?? parent?.filter?.$all;\n    this.#data.filter.$not = data.filter?.$not ?? parent?.filter?.$not;\n    this.#data.filter.$none = data.filter?.$none ?? parent?.filter?.$none;\n    this.#data.sort = (data.sort ?? parent?.sort) as QueryOptions<Record>['sort']; // Fix for TS =4.7\n    this.#data.columns = data.columns ?? parent?.columns;\n    this.#data.consistency = data.consistency ?? parent?.consistency;\n    this.#data.pagination = data.pagination ?? parent?.pagination;\n    this.#data.cache = data.cache ?? parent?.cache;\n    this.#data.fetchOptions = data.fetchOptions ?? parent?.fetchOptions;\n\n    this.any = this.any.bind(this);\n    this.all = this.all.bind(this);\n    this.not = this.not.bind(this);\n    this.filter = this.filter.bind(this);\n    this.sort = this.sort.bind(this);\n    this.none = this.none.bind(this);\n\n    Object.defineProperty(this, 'table', { enumerable: false });\n    Object.defineProperty(this, 'repository', { enumerable: false });\n  }\n\n  getQueryOptions(): QueryOptions<Record> {\n    return this.#data;\n  }\n\n  key(): string {\n    const { columns = [], filter = {}, sort = [], pagination = {} } = this.#data;\n    const key = JSON.stringify({ columns, filter, sort, pagination });\n    return toBase64(key);\n  }\n\n  /**\n   * Builds a new query object representing a logical OR between the given subqueries.\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  any(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $any = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $any } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical AND between the given subqueries.\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  all(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $all = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical OR negating each subquery. In pseudo-code: !q1 OR !q2\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  not(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $not = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $not } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical AND negating each subquery. In pseudo-code: !q1 AND !q2\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  none(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $none = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $none } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object adding one or more constraints. Examples:\n   *\n   * ```\n   * query.filter(\"columnName\", columnValue)\n   * query.filter(\"columnName\", operator(columnValue)) // Use gt, gte, lt, lte, startsWith,...\n   * ```\n   *\n   * @param column The name of the column to filter.\n   * @param value The value to filter.\n   * @returns A new Query object.\n   */\n  filter<F extends FilterColumns<Record> | JSONFilterColumns<Record>>(\n    column: F,\n    value: FilterValueAtColumn<Record, F>\n  ): Query<Record, Result>;\n\n  /**\n   * Builds a new query object adding one or more constraints. Examples:\n   *\n   * ```\n   * query.filter({ \"columnName\": columnValue })\n   * query.filter({\n   *   \"columnName\": operator(columnValue) // Use gt, gte, lt, lte, startsWith,...\n   * })\n   * ```\n   *\n   * @param filter A filter object\n   * @returns A new Query object.\n   */\n  filter(filter?: Filter<Record>): Query<Record, Result>;\n\n  filter(a: any, b?: any): Query<Record, Result> {\n    if (arguments.length === 1) {\n      const constraints = Object.entries(a ?? {}).map(([column, constraint]) => ({\n        [column]: this.#cleanFilterConstraint(column, constraint) as any\n      }));\n      const $all = compact([this.#data.filter?.$all].flat().concat(constraints));\n\n      return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n    } else {\n      const constraints = isDefined(a) && isDefined(b) ? [{ [a]: this.#cleanFilterConstraint(a, b) }] : undefined;\n      const $all = compact([this.#data.filter?.$all].flat().concat(constraints));\n\n      return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n    }\n  }\n\n  #cleanFilterConstraint<T>(column: string, value: T) {\n    const columnType = this.#table.schema?.columns.find(({ name }) => name === column)?.type;\n\n    // TODO: Fix when we support more array types than string\n    if (columnType === 'multiple' && (isString(value) || isStringArray(value))) {\n      return { $includes: value };\n    }\n\n    if (columnType === 'link' && isObject(value) && isString(value.id)) {\n      return value.id;\n    }\n\n    return value;\n  }\n\n  /**\n   * Builds a new query with a new sort option.\n   * @param column The column name.\n   * @param direction The direction. Either ascending or descending.\n   * @returns A new Query object.\n   */\n  sort<F extends SortColumns<Record>>(column: F, direction: SortDirection): Query<Record, Result>;\n  sort(column: '*', direction: 'random'): Query<Record, Result>;\n  sort<F extends SortColumns<Record>>(column: F): Query<Record, Result>;\n  sort(column: string, direction = 'asc'): Query<Record, Result> {\n    const originalSort = [this.#data.sort ?? []].flat() as SortFilter<Record, any>[];\n    const sort = [...originalSort, { column, direction }];\n    return new Query<Record, Result>(this.#repository, this.#table, { sort }, this.#data);\n  }\n\n  /**\n   * Builds a new query specifying the set of columns to be returned in the query response.\n   * @param columns Array of column names to be returned by the query.\n   * @returns A new Query object.\n   */\n  select<K extends SelectableColumnWithObjectNotation<Record>>(columns: K[]) {\n    return new Query<Record, SelectedPick<Record, typeof columns>>(\n      this.#repository,\n      this.#table,\n      { columns },\n      this.#data\n    );\n  }\n\n  /**\n   * Get paginated results\n   *\n   * @returns A page of results\n   */\n  getPaginated(): Promise<Page<Record, Result>>;\n\n  /**\n   * Get paginated results\n   *\n   * @param options Pagination options\n   * @returns A page of results\n   */\n  getPaginated(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<Page<Record, Result>>;\n\n  /**\n   * Get paginated results\n   *\n   * @param options Pagination options\n   * @returns A page of results\n   */\n  getPaginated<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(\n    options: Options\n  ): Promise<Page<Record, SelectedPick<Record, (typeof options)['columns']>>>;\n\n  getPaginated<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Page<Record, Result>> {\n    const query = new Query<Record, Result>(this.#repository, this.#table, options, this.#data);\n    return this.#repository.query(query);\n  }\n\n  /**\n   * Get results in an iterator\n   *\n   * @async\n   * @returns Async interable of results\n   */\n  async *[Symbol.asyncIterator](): AsyncIterableIterator<Result> {\n    for await (const [record] of this.getIterator({ batchSize: 1 })) {\n      yield record;\n    }\n  }\n\n  /**\n   * Build an iterator of results\n   *\n   * @returns Async generator of results array\n   */\n  getIterator(): AsyncGenerator<Result[]>;\n\n  /**\n   * Build an iterator of results\n   *\n   * @param options Pagination options with batchSize\n   * @returns Async generator of results array\n   */\n  getIterator(\n    options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & { batchSize?: number }\n  ): AsyncGenerator<Result[]>;\n\n  /**\n   * Build an iterator of results\n   *\n   * @param options Pagination options with batchSize\n   * @returns Async generator of results array\n   */\n  getIterator<\n    Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & { batchSize?: number }\n  >(options: Options): AsyncGenerator<SelectedPick<Record, (typeof options)['columns']>[]>;\n\n  async *getIterator<Result extends XataRecord>(\n    options: QueryOptions<Record> & { batchSize?: number } = {}\n  ): AsyncGenerator<Result[]> {\n    const { batchSize = 1 } = options;\n\n    let page = await this.getPaginated({ ...options, pagination: { size: batchSize, offset: 0 } });\n    let more = page.hasNextPage();\n\n    yield page.records as unknown as Result[];\n\n    while (more) {\n      page = await page.nextPage();\n      more = page.hasNextPage();\n\n      yield page.records as unknown as Result[];\n    }\n  }\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @returns An array of records from the database.\n   */\n  getMany(): Promise<RecordArray<Result>>;\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getMany<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(\n    options: Options\n  ): Promise<RecordArray<SelectedPick<Record, (typeof options)['columns']>>>;\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getMany(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<RecordArray<Result>>;\n\n  async getMany<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<RecordArray<Result>> {\n    const { pagination = {}, ...rest } = options;\n    const { size = PAGINATION_DEFAULT_SIZE, offset } = pagination;\n    const batchSize = size <= PAGINATION_MAX_SIZE ? size : PAGINATION_MAX_SIZE;\n\n    let page = await this.getPaginated({ ...rest, pagination: { size: batchSize, offset } });\n    const results = [...page.records];\n\n    while (page.hasNextPage() && results.length < size) {\n      page = await page.nextPage();\n      results.push(...page.records);\n    }\n\n    if (page.hasNextPage() && options.pagination?.size === undefined) {\n      console.trace('Calling getMany does not return all results. Paginate to get all results or call getAll.');\n    }\n\n    const array = new RecordArray(page, results.slice(0, size));\n\n    // Method overloading does not provide type inference for the return type.\n    return array as unknown as RecordArray<Result>;\n  }\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @returns An array of records from the database.\n   */\n  getAll(): Promise<Result[]>;\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getAll<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & { batchSize?: number }>(\n    options: Options\n  ): Promise<SelectedPick<Record, (typeof options)['columns']>[]>;\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getAll(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & { batchSize?: number }): Promise<Result[]>;\n\n  async getAll<Result extends XataRecord>(\n    options: QueryOptions<Record> & { batchSize?: number } = {}\n  ): Promise<Result[]> {\n    const { batchSize = PAGINATION_MAX_SIZE, ...rest } = options;\n    const results = [];\n\n    for await (const page of this.getIterator({ ...rest, batchSize })) {\n      results.push(...page);\n    }\n\n    // Method overloading does not provide type inference for the return type.\n    return results as unknown as Result[];\n  }\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst(): Promise<Result | null>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(\n    options: Options\n  ): Promise<SelectedPick<Record, (typeof options)['columns']> | null>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result | null>;\n\n  async getFirst<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Result | null> {\n    const records = await this.getMany({ ...options, pagination: { size: 1 } });\n\n    // Method overloading does not provide type inference for the return type.\n    return (records[0] as unknown as Result) ?? null;\n  }\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow(): Promise<Result>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(\n    options: Options\n  ): Promise<SelectedPick<Record, (typeof options)['columns']>>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result>;\n\n  async getFirstOrThrow<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Result> {\n    const records = await this.getMany({ ...options, pagination: { size: 1 } });\n    if (records[0] === undefined) throw new Error('No results found.');\n\n    // Method overloading does not provide type inference for the return type.\n    return records[0] as unknown as Result;\n  }\n\n  async summarize<\n    Expression extends Dictionary<SummarizeExpression<Record>>,\n    Columns extends SelectableColumn<Record>[]\n  >(params: SummarizeParams<Record, Expression, Columns> = {}): Promise<SummarizeResult<Record, Expression, Columns>> {\n    const { summaries, summariesFilter, ...options } = params;\n    const query = new Query<Record, Result>(\n      this.#repository,\n      this.#table,\n      options as Partial<QueryOptions<Record>>,\n      this.#data\n    );\n\n    return this.#repository.summarizeTable(query, summaries, summariesFilter as Schemas.FilterExpression) as any;\n  }\n\n  /**\n   * Builds a new query object adding a cache TTL in milliseconds.\n   * @param ttl The cache TTL in milliseconds.\n   * @returns A new Query object.\n   */\n  cache(ttl: number): Query<Record, Result> {\n    return new Query<Record, Result>(this.#repository, this.#table, { cache: ttl }, this.#data);\n  }\n\n  /**\n   * Retrieve next page of records\n   *\n   * @returns A new page object.\n   */\n  nextPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.startPage(size, offset);\n  }\n\n  /**\n   * Retrieve previous page of records\n   *\n   * @returns A new page object\n   */\n  previousPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.startPage(size, offset);\n  }\n\n  /**\n   * Retrieve start page of records\n   *\n   * @returns A new page object\n   */\n  startPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.getPaginated({ pagination: { size, offset } });\n  }\n\n  /**\n   * Retrieve last page of records\n   *\n   * @returns A new page object\n   */\n  endPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.getPaginated({ pagination: { size, offset, before: 'end' } });\n  }\n\n  /**\n   * @returns Boolean indicating if there is a next page\n   */\n  hasNextPage(): boolean {\n    return this.meta.page.more;\n  }\n}\n\n// When using cursor based pagination, it is not allowed to send new sorting/filtering\n// We removed the sorting/filtering from the query options to avoid the error from the API\nfunction cleanParent<Record extends XataRecord>(\n  data: Partial<QueryOptions<Record>>,\n  parent?: Partial<QueryOptions<Record>>\n) {\n  if (isCursorPaginationOptions(data.pagination)) {\n    return { ...parent, sort: undefined, filter: undefined };\n  }\n\n  return parent;\n}\n","import { isObject, isString } from '../util/lang';\nimport { ExclusiveOr } from '../util/types';\nimport { XataArrayFile, XataFile } from './files';\nimport { SelectableColumn, SelectedPick } from './selection';\n\nexport const RecordColumnTypes = [\n  'bool',\n  'int',\n  'float',\n  'string',\n  'text',\n  'email',\n  'multiple',\n  'link',\n  'object',\n  'datetime',\n  'vector',\n  'file[]',\n  'file',\n  'json'\n] as const;\n\nexport type Identifier = string;\n\n/**\n * Represents an identifiable record from the database.\n */\nexport interface Identifiable {\n  /**\n   * Unique id of this record.\n   */\n  id: Identifier;\n}\n\nexport interface BaseData {\n  [key: string]: any;\n}\n\n/**\n * Represents a persisted record from the database.\n */\nexport interface XataRecord<OriginalRecord extends XataRecord<any> = XataRecord<any>> extends Identifiable {\n  /**\n   * Metadata of this record.\n   */\n  xata: XataRecordMetadata;\n\n  /**\n   * Get metadata of this record.\n   * @deprecated Use `xata` property instead.\n   */\n  getMetadata(): XataRecordMetadata;\n\n  /**\n   * Get an object representation of this record.\n   */\n  toSerializable(): JSONData<OriginalRecord>;\n\n  /**\n   * Get a string representation of this record.\n   */\n  toString(): string;\n\n  /**\n   * Retrieves a refreshed copy of the current record from the database.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  read<K extends SelectableColumn<OriginalRecord>>(\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Retrieves a refreshed copy of the current record from the database.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  read(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a partial update of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  update<K extends SelectableColumn<OriginalRecord>>(\n    partialUpdate: Partial<EditableData<OriginalRecord>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a partial update of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  update(\n    partialUpdate: Partial<EditableData<OriginalRecord>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a replace of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  replace<K extends SelectableColumn<OriginalRecord>>(\n    object: Partial<EditableData<OriginalRecord>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a replace of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  replace(\n    object: Partial<EditableData<OriginalRecord>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a deletion of the current record in the database.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The deleted record, null if not found.\n   */\n  delete<K extends SelectableColumn<OriginalRecord>>(\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a deletion of the current record in the database.\n   * @returns The deleted record, null if not found.\n\n   */\n  delete(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n}\n\nexport type Link<Record extends XataRecord> = XataRecord<Record>;\n\nexport type XataRecordMetadata = {\n  /**\n   * Number that is increased every time the record is updated.\n   */\n  version: number;\n  /**\n   * Timestamp when the record was created.\n   */\n  createdAt: Date;\n  /**\n   * Timestamp when the record was last updated.\n   */\n  updatedAt: Date;\n};\n\nexport function isIdentifiable(x: any): x is Identifiable & Record<string, unknown> {\n  return isObject(x) && isString((x as Partial<Identifiable>)?.id);\n}\n\nexport function isXataRecord(x: any): x is XataRecord & Record<string, unknown> {\n  const record = x as XataRecord & Record<string, unknown>;\n  const metadata = record?.getMetadata();\n\n  return isIdentifiable(x) && isObject(metadata) && typeof metadata.version === 'number';\n}\n\ntype NumericOperator = ExclusiveOr<\n  { $increment?: number },\n  ExclusiveOr<{ $decrement?: number }, ExclusiveOr<{ $multiply?: number }, { $divide?: number }>>\n>;\n\nexport type InputXataFile = Partial<XataArrayFile> | Promise<Partial<XataArrayFile>>;\n\ntype EditableDataFields<T> = T extends XataRecord\n  ? { id: Identifier } | Identifier\n  : NonNullable<T> extends XataRecord\n  ? { id: Identifier } | Identifier | null | undefined\n  : T extends Date\n  ? string | Date\n  : NonNullable<T> extends Date\n  ? string | Date | null | undefined\n  : T extends XataFile\n  ? InputXataFile\n  : T extends XataFile[]\n  ? InputXataFile[]\n  : T extends number\n  ? number | NumericOperator\n  : T;\n\nexport type EditableData<O extends XataRecord> = Identifiable &\n  Partial<\n    Omit<\n      {\n        [K in keyof O]: EditableDataFields<O[K]>;\n      },\n      keyof XataRecord\n    >\n  >;\n\ntype JSONDataFile = {\n  [K in keyof XataFile]: XataFile[K] extends Function ? never : XataFile[K];\n};\n\ntype JSONDataFields<T> = T extends XataFile\n  ? JSONDataFile\n  : NonNullable<T> extends XataFile\n  ? JSONDataFile | null | undefined\n  : T extends XataRecord\n  ? JSONData<T>\n  : NonNullable<T> extends XataRecord\n  ? JSONData<T> | null | undefined\n  : T extends Date\n  ? string\n  : NonNullable<T> extends Date\n  ? string | null | undefined\n  : T;\n\ntype JSONDataBase = Identifiable & {\n  /**\n   * Metadata about the record.\n   */\n  xata: {\n    /**\n     * Timestamp when the record was created.\n     */\n    createdAt: string;\n    /**\n     * Timestamp when the record was last updated.\n     */\n    updatedAt: string;\n    /**\n     * Number that is increased every time the record is updated.\n     */\n    version: number;\n  };\n};\n\nexport type JSONData<O> = JSONDataBase &\n  Partial<\n    Omit<\n      {\n        [K in keyof O]: JSONDataFields<O[K]>;\n      },\n      keyof XataRecord\n    >\n  >;\n","import { isObject, isString } from '../util/lang';\nimport { If, IsArray, IsObject, StringKeys, UnionToIntersection, Values } from '../util/types';\nimport { XataArrayFile, XataFile, XataFileFields } from './files';\nimport { Link, XataRecord } from './record';\n\n// Public: Utility type to get a union with the selectable columns of an object\nexport type SelectableColumn<O, RecursivePath extends any[] = []> =\n  // Alias for any property\n  | '*'\n  // Alias for id (not in schema)\n  | 'id'\n  // Internal properties\n  | `xata.${'version' | 'createdAt' | 'updatedAt'}`\n  // Properties of the current level\n  | DataProps<O>\n  // Nested properties of the lower levels\n  | NestedColumns<O, RecursivePath>;\n\ntype ExpandedColumnNotation = {\n  name: string;\n  columns?: SelectableColumn<any>[];\n  as?: string;\n  limit?: number;\n  offset?: number;\n  order?: { column: string; order: 'asc' | 'desc' }[];\n};\n\n// Right now, we only support object notation in queryTable endpoint\n// Once we support it in other endpoints, we can remove this and use SelectableColumn<O> instead\nexport type SelectableColumnWithObjectNotation<O, RecursivePath extends any[] = []> =\n  | SelectableColumn<O, RecursivePath>\n  | ExpandedColumnNotation;\n\nexport function isValidExpandedColumn(column: any): column is ExpandedColumnNotation {\n  return isObject(column) && isString(column.name);\n}\n\nexport function isValidSelectableColumns(columns: any): columns is SelectableColumn<any>[] {\n  if (!Array.isArray(columns)) {\n    return false;\n  }\n\n  return columns.every((column) => {\n    if (typeof column === 'string') {\n      return true;\n    }\n\n    if (typeof column === 'object') {\n      return isValidExpandedColumn(column);\n    }\n\n    return false;\n  });\n}\n\ntype StringColumns<T> = T extends string ? T : never;\ntype ProjectionColumns<T> = T extends string\n  ? never\n  : T extends { as: infer As }\n  ? NonNullable<As> extends string\n    ? NonNullable<As>\n    : never\n  : never;\n\n// Private: Returns columns ending with a wildcard\ntype WildcardColumns<O> = Values<{\n  [K in SelectableColumn<O>]: K extends `${string}*` ? K : never;\n}>;\n\n// Public: Utility type to get a union with the selectable columns of an object by a given type\nexport type ColumnsByValue<O, Value> = Values<{\n  [K in SelectableColumn<O>]: ValueAtColumn<O, K> extends infer C\n    ? C extends Value\n      ? K extends WildcardColumns<O>\n        ? never\n        : K\n      : never\n    : never;\n}>;\n\n// Public: Utility type to get the XataRecord built from a list of selected columns\nexport type SelectedPick<O extends XataRecord, Key extends SelectableColumnWithObjectNotation<O>[]> = XataRecord<O> &\n  // For each column, we get its nested value and join it as an intersection\n  UnionToIntersection<\n    Values<{\n      [K in StringColumns<Key[number]>]: NestedValueAtColumn<O, K> & XataRecord<O>;\n    }>\n  > &\n  // For each column projection, we get its nested value and join it as an intersection\n  // The typings here are a bit tricky, but it works, can definetely be improved\n  UnionToIntersection<\n    Values<{\n      [K in ProjectionColumns<Key[number]>]: { [Key in K]: { records: (Record<string, any> & XataRecord<O>)[] } };\n    }>\n  >;\n\n// Public: Utility type to get the value of a column at a given path\nexport type ValueAtColumn<Object, Key> = Key extends '*'\n  ? Values<Object> // Alias for any property\n  : Key extends 'id'\n  ? string // Alias for id (not in schema)\n  : Key extends 'xata.version'\n  ? number\n  : Key extends 'xata.createdAt'\n  ? Date\n  : Key extends 'xata.updatedAt'\n  ? Date\n  : Key extends keyof Object\n  ? Object[Key] // Properties of the current level\n  : Key extends `${infer K}.${infer V}`\n  ? K extends keyof Object\n    ? Values<\n        NonNullable<Object[K]> extends infer Item\n          ? Item extends Record<string, any>\n            ? V extends SelectableColumn<Item>\n              ? { V: ValueAtColumn<Item, V> }\n              : never\n            : Object[K]\n          : never\n      >\n    : never\n  : never;\n\n// Private: To avoid circular dependencies, we limit the recursion depth\ntype MAX_RECURSION = 3;\n\n// Private: Utility type to get a union with the columns below the current level\n// Exclude type in union: never\ntype NestedColumns<O, RecursivePath extends any[]> = RecursivePath['length'] extends MAX_RECURSION\n  ? never\n  : If<\n      IsObject<O>,\n      Values<{\n        [K in DataProps<O>]: NonNullable<O[K]> extends infer Item\n          ? If<\n              IsArray<Item>,\n              Item extends (infer Type)[]\n                ? Type extends XataArrayFile\n                  ? K | `${K}.${keyof XataFileFields | '*'}`\n                  : K | `${K}.${StringKeys<Type> | '*'}`\n                : never,\n              If<\n                IsObject<Item>,\n                Item extends XataRecord\n                  ? SelectableColumn<Item, [...RecursivePath, Item]> extends infer Column\n                    ? Column extends string\n                      ? K | `${K}.${Column}`\n                      : never\n                    : never\n                  : Item extends Date\n                  ? K\n                  : Item extends XataFile\n                  ? K | `${K}.${keyof XataFileFields | '*'}` // This allows usage of objects that are not links\n                  : `${K}.${StringKeys<Item> | '*'}`, // This allows usage of objects that are not links\n                K\n              >\n            >\n          : never;\n      }>,\n      never\n    >;\n\n// Private: Utility type to get object properties without XataRecord ones\ntype DataProps<O> = Exclude<StringKeys<O>, StringKeys<XataRecord>>;\n\n// Private: Utility type to get the value of a column at a given path (nested object value)\n// For \"foo.bar.baz\" we return { foo: { bar: { baz: type } } }\ntype NestedValueAtColumn<O, Key extends SelectableColumn<O>> =\n  // If a column is a nested property, infer N and M\n  Key extends `${infer N}.${infer M}`\n    ? N extends DataProps<O>\n      ? {\n          [K in N]: M extends SelectableColumn<NonNullable<O[K]>>\n            ? NonNullable<O[K]> extends XataFile\n              ? ForwardNullable<O[K], XataFile>\n              : NonNullable<O[K]> extends XataRecord\n              ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M> & XataRecord>\n              : ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M>>\n            : NonNullable<O[K]> extends (infer ArrayType)[]\n            ? ArrayType extends XataArrayFile\n              ? ForwardNullable<O[K], XataArrayFile[]>\n              : M extends SelectableColumn<NonNullable<ArrayType>>\n              ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<ArrayType>, M>[]>\n              : unknown //`Property ${M} is not selectable on type ${ArrayType}`\n            : unknown; //`Property ${M} is not selectable on type ${K}`\n        }\n      : unknown //`Property ${N} is not a property of type ${O}`\n    : Key extends DataProps<O>\n    ? {\n        [K in Key]: NonNullable<O[K]> extends XataRecord\n          ? // If the property is a link, we forward the type of the internal XataRecord\n            // Since it can be nullable, we use ForwardNullable to avoid loosing the internal type\n            // Links that are not expanded [\"link\"] instead of [\"link.*\"] don't have the xata property\n            ForwardNullable<O[K], Omit<SelectedPick<NonNullable<O[K]>, ['*']>, 'xata' | 'getMetadata'>>\n          : O[K];\n      }\n    : Key extends '*'\n    ? {\n        [K in StringKeys<O>]: NonNullable<O[K]> extends XataRecord\n          ? ForwardNullable<O[K], Link<NonNullable<O[K]>>> // Link forwards read/update method signatures to avoid loosing the internal type\n          : O[K];\n      }\n    : unknown; //`Property ${Key} is invalid`;\n\ntype ForwardNullable<T, R> = T extends NonNullable<T> ? R : R | null;\n","import { isObject, isString } from '../util/lang';\nimport { SingleOrArray, Values } from '../util/types';\nimport { XataRecord, XataRecordMetadata } from './record';\nimport { ColumnsByValue } from './selection';\n\nexport type SortDirection = 'asc' | 'desc';\n\ntype RandomFilter = { '*': 'random' };\ntype RandomFilterExtended = { column: '*'; direction: 'random' };\n\nexport type SortColumns<T extends XataRecord> = ColumnsByValue<T, any> | `xata.${keyof XataRecordMetadata}`;\n\nexport type SortFilterExtended<T extends XataRecord, Columns extends string = SortColumns<T>> =\n  | RandomFilterExtended\n  | {\n      column: Columns;\n      direction?: SortDirection;\n    };\n\nexport type SortFilter<T extends XataRecord, Columns extends string = SortColumns<T>> =\n  | Columns\n  | SortFilterExtended<T, Columns>\n  | SortFilterBase<T, Columns>\n  | RandomFilter;\n\ntype SortFilterBase<T extends XataRecord, Columns extends string = SortColumns<T>> = Values<{\n  [Key in Columns]: { [K in Key]: SortDirection };\n}>;\n\nexport type ApiSortFilter<T extends XataRecord, Columns extends string = SortColumns<T>> = SingleOrArray<\n  | RandomFilter\n  | Values<{\n      [Key in Columns]: { [K in Key]: SortDirection };\n    }>\n>;\n\nexport function isSortFilterString<T extends XataRecord>(value: any): value is SortColumns<T> {\n  return isString(value);\n}\n\nexport function isSortFilterBase<T extends XataRecord>(filter: SortFilter<T, any>): filter is SortFilterBase<T> {\n  return (\n    isObject(filter) &&\n    Object.entries(filter).every(([key, value]) => {\n      // Check for the random sorting operator\n      if (key === '*') return value === 'random';\n\n      return value === 'asc' || value === 'desc';\n    })\n  );\n}\n\nexport function isSortFilterObject<T extends XataRecord>(filter: SortFilter<T, any>): filter is SortFilterExtended<T> {\n  return isObject(filter) && !isSortFilterBase(filter) && filter.column !== undefined;\n}\n\nexport function buildSortFilter<T extends XataRecord>(\n  filter: SingleOrArray<SortFilter<T, any>>\n): ApiSortFilter<T, any> {\n  if (isSortFilterString(filter)) {\n    return { [filter]: 'asc' } as { [key in SortColumns<T>]: SortDirection };\n  } else if (Array.isArray(filter)) {\n    return filter.map((item) => buildSortFilter(item)) as { [key in SortColumns<T>]: SortDirection }[];\n  } else if (isSortFilterBase(filter)) {\n    return filter as { [key in SortColumns<T>]: SortDirection };\n  } else if (isSortFilterObject(filter)) {\n    return { [filter.column]: filter.direction ?? 'asc' } as { [key in SortColumns<T>]: SortDirection };\n  } else {\n    throw new Error(`Invalid sort filter: ${filter}`);\n  }\n}\n","import { SchemaPluginResult } from '.';\nimport {\n  ApiExtraProps,\n  Schemas,\n  aggregateTable,\n  askTableSession,\n  branchTransaction,\n  deleteRecord,\n  getBranchDetails,\n  getRecord,\n  insertRecord,\n  insertRecordWithID,\n  queryTable,\n  searchTable,\n  summarizeTable,\n  updateRecordWithID,\n  upsertRecordWithID,\n  vectorSearchTable\n} from '../api';\nimport { fetchSSERequest } from '../api/fetcher';\nimport {\n  FuzzinessExpression,\n  HighlightExpression,\n  PrefixExpression,\n  RecordsMetadata,\n  SearchPageConfig,\n  TransactionOperation\n} from '../api/schemas';\nimport { XataPluginOptions } from '../plugins';\nimport { SearchXataRecord } from '../search';\nimport { Boosters } from '../search/boosters';\nimport { TargetColumn } from '../search/target';\nimport { chunk, compact, isDefined, isNumber, isObject, isString, promiseMap } from '../util/lang';\nimport { Dictionary } from '../util/types';\nimport { generateUUID } from '../util/uuid';\nimport { VERSION } from '../version';\nimport { AggregationExpression, AggregationResult } from './aggregate';\nimport { AskOptions, AskResult } from './ask';\nimport { CacheImpl } from './cache';\nimport { XataArrayFile, XataFile, parseInputFileEntry } from './files';\nimport { Filter, cleanFilter } from './filters';\nimport { parseJson, stringifyJson } from './json';\nimport { Page } from './pagination';\nimport { Query } from './query';\nimport { EditableData, Identifiable, Identifier, InputXataFile, XataRecord, isIdentifiable } from './record';\nimport {\n  ColumnsByValue,\n  SelectableColumn,\n  SelectableColumnWithObjectNotation,\n  SelectedPick,\n  isValidSelectableColumns\n} from './selection';\nimport { buildSortFilter } from './sorting';\nimport { SummarizeExpression } from './summarize';\nimport { AttributeDictionary, TraceAttributes, TraceFunction, defaultTrace } from './tracing';\n\nconst BULK_OPERATION_MAX_SIZE = 1000;\n\n/**\n * Common interface for performing operations on a table.\n */\nexport abstract class Repository<Record extends XataRecord> extends Query<\n  Record,\n  Readonly<SelectedPick<Record, ['*']>>\n> {\n  /*\n   * Creates a single record in the table.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /*\n   * Creates a single record in the table.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @returns The full persisted record.\n   */\n  abstract create(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates a single record in the table with a unique id.\n   * @param id The unique id.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates a single record in the table with a unique id.\n   * @param id The unique id.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @returns The full persisted record.\n   */\n  abstract create(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates multiple records in the table.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates multiple records in the table.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records in order.\n   */\n  abstract create(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    ids: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read(ids: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    ids: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow(ids: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order (if a record could not be found null is returned).\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @returns Array of the persisted records in order (if a record could not be found null is returned).\n   */\n  abstract update(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @returns Array of the persisted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract updateOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrUpdate(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace(\n    object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrReplace(\n    objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    object: Identifiable & Partial<EditableData<Record>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete(\n    object: Identifiable & Partial<EditableData<Record>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @returns Array of the deleted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Search for records in the table.\n   * @param query The query to search for.\n   * @param options The options to search with (like: fuzziness)\n   * @returns The found records.\n   */\n  abstract search(\n    query: string,\n    options?: {\n      fuzziness?: FuzzinessExpression;\n      prefix?: PrefixExpression;\n      highlight?: HighlightExpression;\n      filter?: Filter<Record>;\n      boosters?: Boosters<Record>[];\n      page?: SearchPageConfig;\n      target?: TargetColumn<Record>[];\n    }\n  ): Promise<SearchXataRecord<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Search for vectors in the table.\n   * @param column The column to search for.\n   * @param query The vector to search for similarities. Must have the same dimension as the vector column used.\n   * @param options The options to search with (like: spaceFunction)\n   */\n  abstract vectorSearch<F extends ColumnsByValue<Record, number[]>>(\n    column: F,\n    query: number[],\n    options?: {\n      /**\n       * The function used to measure the distance between two points. Can be one of:\n       * `cosineSimilarity`, `l1`, `l2`. The default is `cosineSimilarity`.\n       *\n       * @default cosineSimilarity\n       */\n      similarityFunction?: string;\n      /**\n       * Number of results to return.\n       *\n       * @default 10\n       * @maximum 100\n       * @minimum 1\n       */\n      size?: number;\n      filter?: Filter<Record>;\n    }\n  ): Promise<SearchXataRecord<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Aggregates records in the table.\n   * @param expression The aggregations to perform.\n   * @param filter The filter to apply to the queried records.\n   * @returns The requested aggregations.\n   */\n  abstract aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(\n    expression?: Expression,\n    filter?: Filter<Record>\n  ): Promise<AggregationResult<Record, Expression>>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options?: AskOptions<Record>): Promise<AskResult>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options: AskOptions<Record>): Promise<AskResult>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options: AskOptions<Record> & { onMessage: (message: AskResult) => void }): void;\n\n  abstract query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;\n}\n\nexport class RestRepository<Record extends XataRecord>\n  extends Query<Record, SelectedPick<Record, ['*']>>\n  implements Repository<Record>\n{\n  #table: string;\n  #getFetchProps: () => ApiExtraProps;\n  #db: SchemaPluginResult<any>;\n  #cache?: CacheImpl;\n  #schemaTables?: Schemas.Table[];\n  #trace: TraceFunction;\n\n  constructor(options: {\n    table: string;\n    db: SchemaPluginResult<any>;\n    pluginOptions: XataPluginOptions;\n    schemaTables?: Schemas.Table[];\n  }) {\n    super(\n      null,\n      { name: options.table, schema: options.schemaTables?.find((table) => table.name === options.table) },\n      {}\n    );\n\n    this.#table = options.table;\n    this.#db = options.db;\n    this.#cache = options.pluginOptions.cache;\n    this.#schemaTables = options.schemaTables;\n    this.#getFetchProps = () => ({ ...options.pluginOptions, sessionID: generateUUID() });\n\n    const trace = options.pluginOptions.trace ?? defaultTrace;\n    this.#trace = async <T>(\n      name: string,\n      fn: (options: { setAttributes: (attrs: AttributeDictionary) => void }) => T,\n      options: AttributeDictionary = {}\n    ) => {\n      return trace<T>(name, fn, {\n        ...options,\n        [TraceAttributes.TABLE]: this.#table,\n        [TraceAttributes.KIND]: 'sdk-operation',\n        [TraceAttributes.VERSION]: VERSION\n      });\n    };\n  }\n\n  async create<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async create(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async create<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: EditableData<Record>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async create(\n    id: Identifier,\n    object: EditableData<Record>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async create<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async create(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async create<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (EditableData<Record> & Partial<Identifiable>)\n      | Array<EditableData<Record> & Partial<Identifiable>>,\n    b?: EditableData<Record> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, K[]>>\n    | Readonly<SelectedPick<Record, K[]>>[]\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Readonly<SelectedPick<Record, ['*']>>[]\n  > {\n    return this.#trace('create', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = await this.#insertRecords(a, { ifVersion, createOnly: true });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(ids as string[], columns);\n        return result;\n      }\n\n      // Create one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a, b as EditableData<Record>, columns, { createOnly: true, ifVersion });\n      }\n\n      // Create one record with id as property\n      if (isObject(a) && isString(a.id)) {\n        if (a.id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(b) ? b : undefined;\n        return await this.#insertRecordWithId(a.id, { ...a, id: undefined }, columns, { createOnly: true, ifVersion });\n      }\n\n      // Create one record without id\n      if (isObject(a)) {\n        const columns = isValidSelectableColumns(b) ? b : undefined;\n        return this.#insertRecordWithoutId(a, columns);\n      }\n\n      throw new Error('Invalid arguments for create method');\n    });\n  }\n\n  async #insertRecordWithoutId(object: EditableData<Record>, columns: SelectableColumn<Record>[] = ['*']) {\n    const record = await this.#transformObjectToApi(object);\n\n    const response = await insertRecord({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table\n      },\n      queryParams: { columns },\n      body: record,\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async #insertRecordWithId(\n    recordId: Identifier,\n    object: EditableData<Record>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { createOnly, ifVersion }: { createOnly: boolean; ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    const record = await this.#transformObjectToApi(object);\n\n    const response = await insertRecordWithID({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        recordId\n      },\n      body: record,\n      queryParams: { createOnly, columns, ifVersion },\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async #insertRecords(\n    objects: EditableData<Record>[],\n    { createOnly, ifVersion }: { createOnly: boolean; ifVersion?: number }\n  ) {\n    const operations = await promiseMap(objects, async (object) => {\n      const record = await this.#transformObjectToApi(object);\n      return { insert: { table: this.#table, record, createOnly, ifVersion } };\n    });\n\n    const chunkedOperations: TransactionOperation[][] = chunk(operations, BULK_OPERATION_MAX_SIZE);\n\n    const ids = [];\n\n    for (const operations of chunkedOperations) {\n      const { results } = await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n\n      for (const result of results) {\n        if (result.operation === 'insert') {\n          ids.push(result.id);\n        } else {\n          ids.push(null);\n        }\n      }\n    }\n\n    return ids;\n  }\n\n  async read<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n  async read(id: string): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    ids: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async read(ids: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n  async read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifier[] | Identifiable | Identifiable[],\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('read', async () => {\n      const columns = isValidSelectableColumns(b) ? b : ['*' as const];\n\n      // Read many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = a.map((item) => extractId(item));\n\n        const finalObjects = await this.getAll({ filter: { id: { $any: compact(ids) } }, columns });\n\n        // Maintain order of objects\n        const dictionary = finalObjects.reduce((acc, object) => {\n          acc[object.id] = object;\n          return acc;\n        }, {} as Dictionary<any>);\n\n        return ids.map((id) => dictionary[id ?? ''] ?? null);\n      }\n\n      // Read one record\n      const id = extractId(a);\n      if (id) {\n        try {\n          const response = await getRecord({\n            pathParams: {\n              workspace: '{workspaceId}',\n              dbBranchName: '{dbBranch}',\n              region: '{region}',\n              tableName: this.#table,\n              recordId: id\n            },\n            queryParams: { columns },\n            ...this.#getFetchProps()\n          });\n\n          const schemaTables = await this.#getSchemaTables();\n          return initObject<Record>(\n            this.#db,\n            schemaTables,\n            this.#table,\n            response,\n            columns as SelectableColumn<Record>[]\n          ) as any;\n        } catch (e) {\n          if (isObject(e) && e.status === 404) {\n            return null;\n          }\n\n          throw e;\n        }\n      }\n\n      return null;\n    });\n  }\n\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async readOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    ids: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async readOrThrow(ids: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifier[] | Identifiable | Identifiable[],\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Readonly<SelectedPick<Record, ['*']>>[]\n    | Readonly<SelectedPick<Record, K[]>>\n    | Readonly<SelectedPick<Record, K[]>>[]\n  > {\n    return this.#trace('readOrThrow', async () => {\n      const result = await this.read(a as any, b as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      }\n\n      if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async update<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async update(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async update<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async update(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async update<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async update(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async update<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (Partial<EditableData<Record>> & Identifiable)\n      | Array<Partial<EditableData<Record>> & Identifiable>,\n    b?: Partial<EditableData<Record>> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('update', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Update many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        // TODO: Transaction API fails fast if one of the records is not found\n        const existing = await this.read(a, ['id']);\n        const updates = a.filter((_item, index) => existing[index] !== null);\n\n        await this.#updateRecords(updates as Array<Partial<EditableData<Record>> & Identifiable>, {\n          ifVersion,\n          upsert: false\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a, columns);\n        return result;\n      }\n\n      try {\n        // Update one record with id as param\n        if (isString(a) && isObject(b)) {\n          const columns = isValidSelectableColumns(c) ? c : undefined;\n          return await this.#updateRecordWithID(a, b as EditableData<Record>, columns, { ifVersion });\n        }\n\n        // Update one record with id as property\n        if (isObject(a) && isString(a.id)) {\n          const columns = isValidSelectableColumns(b) ? b : undefined;\n          return await this.#updateRecordWithID(a.id, { ...a, id: undefined }, columns, { ifVersion });\n        }\n      } catch (error: any) {\n        if (error.status === 422) return null;\n        throw error;\n      }\n\n      throw new Error('Invalid arguments for update method');\n    });\n  }\n\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async updateOrThrow(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async updateOrThrow(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async updateOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (Partial<EditableData<Record>> & Identifiable)\n      | Array<Partial<EditableData<Record>> & Identifiable>,\n    b?: Partial<EditableData<Record>> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('updateOrThrow', async () => {\n      const result = await this.update(a as any, b as any, c as any, d as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      }\n\n      if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async #updateRecordWithID(\n    recordId: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { ifVersion }: { ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    // Ensure id is not present in the update payload\n    const { id: _id, ...record } = await this.#transformObjectToApi(object);\n\n    try {\n      const response = await updateRecordWithID({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table,\n          recordId\n        },\n        queryParams: { columns, ifVersion },\n        body: record,\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n    } catch (e) {\n      if (isObject(e) && e.status === 404) {\n        return null;\n      }\n\n      throw e;\n    }\n  }\n\n  async #updateRecords(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    { ifVersion, upsert }: { ifVersion?: number; upsert: boolean }\n  ) {\n    const operations = await promiseMap(objects, async ({ id, ...object }) => {\n      const fields = await this.#transformObjectToApi(object);\n      return { update: { table: this.#table, id, ifVersion, upsert, fields } };\n    });\n\n    const chunkedOperations: TransactionOperation[][] = chunk(operations, BULK_OPERATION_MAX_SIZE);\n\n    const ids = [];\n\n    for (const operations of chunkedOperations) {\n      const { results } = await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n\n      for (const result of results) {\n        if (result.operation === 'update') {\n          ids.push(result.id);\n        } else {\n          ids.push(null);\n        }\n      }\n    }\n\n    return ids;\n  }\n\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrUpdate(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrUpdate(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async createOrUpdate(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    a: Identifier | EditableData<Record> | EditableData<Record>[],\n    b?: EditableData<Record> | Omit<EditableData<Record>, 'id'> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('createOrUpdate', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create or update many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        await this.#updateRecords(a as Array<Partial<EditableData<Record>> & Identifiable>, {\n          ifVersion,\n          upsert: true\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a, columns);\n        return result;\n      }\n\n      // Create or update one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#upsertRecordWithID(a, b as EditableData<Record>, columns, { ifVersion });\n      }\n\n      // Create or update one record with id as property\n      if (isObject(a) && isString(a.id)) {\n        if (a.id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#upsertRecordWithID(a.id, { ...a, id: undefined }, columns, { ifVersion });\n      }\n\n      // Create with undefined id as param\n      if (!isDefined(a) && isObject(b)) {\n        return await this.create(b as EditableData<Record>, c as K[]);\n      }\n\n      // Create with undefined id as property\n      if (isObject(a) && !isDefined(a.id)) {\n        return await this.create(a as EditableData<Record>, b as K[]);\n      }\n\n      throw new Error('Invalid arguments for createOrUpdate method');\n    });\n  }\n\n  async #upsertRecordWithID(\n    recordId: Identifier,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { ifVersion }: { ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    const response = await upsertRecordWithID({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        recordId\n      },\n      queryParams: { columns, ifVersion },\n      body: object as Schemas.DataInputRecord,\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrReplace(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrReplace(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async createOrReplace(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    a: Identifier | EditableData<Record> | EditableData<Record>[] | undefined,\n    b?: EditableData<Record> | Omit<EditableData<Record>, 'id'> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('createOrReplace', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create or replace many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = await this.#insertRecords(a, { ifVersion, createOnly: false });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(ids as string[], columns);\n        return result;\n      }\n\n      // Create or replace one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a, b as EditableData<Record>, columns, { createOnly: false, ifVersion });\n      }\n\n      // Create or replace one record with id as property\n      if (isObject(a) && isString(a.id)) {\n        if (a.id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a.id, { ...a, id: undefined }, columns, { createOnly: false, ifVersion });\n      }\n\n      // Create with undefined id as param\n      if (!isDefined(a) && isObject(b)) {\n        return await this.create(b as EditableData<Record>, c as K[]);\n      }\n\n      // Create with undefined id as property\n      if (isObject(a) && !isDefined(a.id)) {\n        return await this.create(a as EditableData<Record>, b as K[]);\n      }\n\n      throw new Error('Invalid arguments for createOrReplace method');\n    });\n  }\n\n  async delete<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async delete(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async delete<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async delete(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async delete<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async delete(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async delete<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async delete(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async delete<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifiable | Array<Identifier | Identifiable>,\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('delete', async () => {\n      // Delete many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = a.map((o) => {\n          if (isString(o)) return o;\n          if (isString(o.id)) return o.id;\n          throw new Error('Invalid arguments for delete method');\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a as any, columns);\n\n        await this.#deleteRecords(ids);\n\n        return result;\n      }\n\n      // Delete one record with id as param\n      if (isString(a)) {\n        return this.#deleteRecord(a, b);\n      }\n\n      // Delete one record with id as property\n      if (isObject(a) && isString(a.id)) {\n        return this.#deleteRecord(a.id, b);\n      }\n\n      throw new Error('Invalid arguments for delete method');\n    });\n  }\n\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async deleteOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async deleteOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async deleteOrThrow(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifiable | Array<Identifier | Identifiable>,\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('deleteOrThrow', async () => {\n      const result = await this.delete(a as any, b as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      } else if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async #deleteRecord(recordId: Identifier, columns: SelectableColumn<Record>[] = ['*']) {\n    if (!recordId) return null;\n\n    try {\n      const response = await deleteRecord({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table,\n          recordId\n        },\n        queryParams: { columns },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n    } catch (e) {\n      if (isObject(e) && e.status === 404) {\n        return null;\n      }\n\n      throw e;\n    }\n  }\n\n  async #deleteRecords(recordIds: Identifier[]) {\n    const chunkedOperations: TransactionOperation[][] = chunk(\n      compact(recordIds).map((id) => ({ delete: { table: this.#table, id } })),\n      BULK_OPERATION_MAX_SIZE\n    );\n\n    for (const operations of chunkedOperations) {\n      await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n    }\n  }\n\n  async search(\n    query: string,\n    options: {\n      fuzziness?: FuzzinessExpression;\n      prefix?: PrefixExpression;\n      highlight?: HighlightExpression;\n      filter?: Filter<Record>;\n      boosters?: Boosters<Record>[];\n      page?: SearchPageConfig;\n      target?: TargetColumn<Record>[];\n    } = {}\n  ) {\n    return this.#trace('search', async () => {\n      const { records } = await searchTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          query,\n          fuzziness: options.fuzziness,\n          prefix: options.prefix,\n          highlight: options.highlight,\n          filter: options.filter as Schemas.FilterExpression,\n          boosters: options.boosters as Schemas.BoosterExpression[],\n          page: options.page,\n          target: options.target as Schemas.TargetExpression\n        },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n\n      // TODO - Column selection not supported by search endpoint yet\n      return records.map((item) => initObject(this.#db, schemaTables, this.#table, item, ['*'])) as any;\n    });\n  }\n\n  async vectorSearch<F extends ColumnsByValue<Record, number[]>>(\n    column: F,\n    query: number[],\n    options?:\n      | {\n          similarityFunction?: string | undefined;\n          size?: number | undefined;\n          filter?: Filter<Record> | undefined;\n        }\n      | undefined\n  ): Promise<SearchXataRecord<SelectedPick<Record, ['*']>>[]> {\n    return this.#trace('vectorSearch', async () => {\n      const { records } = await vectorSearchTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          column,\n          queryVector: query,\n          similarityFunction: options?.similarityFunction,\n          size: options?.size,\n          filter: options?.filter as Schemas.FilterExpression\n        },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n\n      // TODO - Column selection not supported by search endpoint yet\n      return records.map((item) => initObject(this.#db, schemaTables, this.#table, item, ['*'])) as any;\n    });\n  }\n\n  async aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(\n    aggs?: Expression,\n    filter?: Filter<Record>\n  ) {\n    return this.#trace('aggregate', async () => {\n      const result = await aggregateTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: { aggs, filter: filter as Schemas.FilterExpression },\n        ...this.#getFetchProps()\n      });\n\n      return result as any;\n    });\n  }\n\n  async query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>> {\n    return this.#trace('query', async () => {\n      const cacheQuery = await this.#getCacheQuery<Result>(query);\n      if (cacheQuery) return new Page<Record, Result>(query, cacheQuery.meta, cacheQuery.records);\n\n      const data = query.getQueryOptions();\n\n      const { meta, records: objects } = await queryTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          filter: cleanFilter(data.filter),\n          sort: data.sort !== undefined ? buildSortFilter(data.sort) : undefined,\n          page: data.pagination,\n          columns: data.columns ?? ['*'],\n          consistency: data.consistency\n        },\n        fetchOptions: data.fetchOptions,\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      const records = objects.map((record) =>\n        initObject<Result>(\n          this.#db,\n          schemaTables,\n          this.#table,\n          record,\n          (data.columns as SelectableColumn<Result>[]) ?? ['*']\n        )\n      );\n      await this.#setCacheQuery(query, meta, records);\n\n      return new Page<Record, Result>(query, meta, records);\n    });\n  }\n\n  async summarizeTable<Result extends XataRecord>(\n    query: Query<Record, Result>,\n    summaries?: Dictionary<SummarizeExpression<Record>>,\n    summariesFilter?: Schemas.FilterExpression\n  ) {\n    return this.#trace('summarize', async () => {\n      const data = query.getQueryOptions();\n\n      const result = await summarizeTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          filter: cleanFilter(data.filter),\n          sort: data.sort !== undefined ? buildSortFilter(data.sort) : undefined,\n          columns: data.columns as SelectableColumn<Record>[],\n          consistency: data.consistency,\n          page: data.pagination?.size !== undefined ? { size: data.pagination?.size } : undefined,\n          summaries,\n          summariesFilter\n        },\n        ...this.#getFetchProps()\n      });\n      const schemaTables = await this.#getSchemaTables();\n      return {\n        ...result,\n        summaries: result.summaries.map((summary) =>\n          initObject(this.#db, schemaTables, this.#table, summary, data.columns ?? [])\n        )\n      };\n    });\n  }\n\n  ask(question: string, options?: AskOptions<Record> & { onMessage?: (message: AskResult) => void }): any {\n    // Ask with session uses message, ask without session uses question param\n    const questionParam = options?.sessionId ? { message: question } : { question };\n    const params = {\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        sessionId: options?.sessionId\n      },\n      body: {\n        ...questionParam,\n        rules: options?.rules,\n        searchType: options?.searchType,\n        search: options?.searchType === 'keyword' ? options?.search : undefined,\n        vectorSearch: options?.searchType === 'vector' ? options?.vectorSearch : undefined\n      },\n      ...this.#getFetchProps()\n    };\n\n    if (options?.onMessage) {\n      fetchSSERequest({\n        endpoint: 'dataPlane',\n        url: '/db/{dbBranchName}/tables/{tableName}/ask/{sessionId}',\n        method: 'POST',\n        onMessage: (message: { text: string; records: string[] }) => {\n          options.onMessage?.({ answer: message.text, records: message.records });\n        },\n        ...params\n      });\n    } else {\n      return askTableSession(params as any);\n    }\n  }\n\n  async #setCacheQuery(query: Query<Record, XataRecord>, meta: RecordsMetadata, records: XataRecord[]): Promise<void> {\n    await this.#cache?.set(`query_${this.#table}:${query.key()}`, { date: new Date(), meta, records });\n  }\n\n  async #getCacheQuery<T extends XataRecord>(\n    query: Query<Record, XataRecord>\n  ): Promise<{ meta: RecordsMetadata; records: T[] } | null> {\n    const key = `query_${this.#table}:${query.key()}`;\n    const result = await this.#cache?.get<{ date: Date; meta: RecordsMetadata; records: T[] }>(key);\n    if (!result) return null;\n\n    const defaultTTL = this.#cache?.defaultQueryTTL ?? -1;\n    const { cache: ttl = defaultTTL } = query.getQueryOptions();\n    if (ttl < 0) return null;\n\n    const hasExpired = result.date.getTime() + ttl < Date.now();\n    return hasExpired ? null : result;\n  }\n\n  async #getSchemaTables(): Promise<Schemas.Table[]> {\n    if (this.#schemaTables) return this.#schemaTables;\n\n    const { schema } = await getBranchDetails({\n      pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n      ...this.#getFetchProps()\n    });\n\n    this.#schemaTables = schema.tables;\n    return schema.tables;\n  }\n\n  async #transformObjectToApi(object: any): Promise<Schemas.DataInputRecord> {\n    const schemaTables = await this.#getSchemaTables();\n    const schema = schemaTables.find((table) => table.name === this.#table);\n    if (!schema) throw new Error(`Table ${this.#table} not found in schema`);\n\n    const result: Dictionary<any> = {};\n\n    for (const [key, value] of Object.entries(object)) {\n      // Ignore internal properties\n      if (key === 'xata') continue;\n\n      const type = schema.columns.find((column) => column.name === key)?.type;\n\n      switch (type) {\n        case 'link': {\n          result[key] = isIdentifiable(value) ? value.id : value;\n          break;\n        }\n        case 'datetime': {\n          result[key] = value instanceof Date ? value.toISOString() : value;\n          break;\n        }\n        case `file`:\n          result[key] = await parseInputFileEntry(value as InputXataFile);\n          break;\n        case 'file[]':\n          result[key] = await promiseMap(value as InputXataFile[], (item) => parseInputFileEntry(item));\n          break;\n        case 'json':\n          result[key] = stringifyJson(value as any);\n          break;\n        default:\n          result[key] = value;\n      }\n    }\n\n    return result;\n  }\n}\n\nexport const initObject = <T>(\n  db: Record<string, Repository<any>>,\n  schemaTables: Schemas.Table[],\n  table: string,\n  object: Record<string, any>,\n  selectedColumns: SelectableColumn<T>[] | SelectableColumnWithObjectNotation<T>[]\n) => {\n  const data: Dictionary<unknown> = {};\n  const { xata, ...rest } = object ?? {};\n  Object.assign(data, rest);\n\n  const { columns } = schemaTables.find(({ name }) => name === table) ?? {};\n  if (!columns) console.error(`Table ${table} not found in schema`);\n\n  for (const column of columns ?? []) {\n    // Ignore columns not selected\n    if (!isValidColumn(selectedColumns, column)) continue;\n\n    const value = data[column.name];\n\n    switch (column.type) {\n      case 'datetime': {\n        const date = value !== undefined ? new Date(value as string) : null;\n\n        if (date !== null && isNaN(date.getTime())) {\n          console.error(`Failed to parse date ${value} for field ${column.name}`);\n        } else {\n          data[column.name] = date;\n        }\n\n        break;\n      }\n      case 'link': {\n        const linkTable = column.link?.table;\n\n        if (!linkTable) {\n          console.error(`Failed to parse link for field ${column.name}`);\n        } else if (isObject(value)) {\n          const selectedLinkColumns = (selectedColumns as string[]).reduce((acc, item) => {\n            if (item === column.name) {\n              return [...acc, '*'];\n            }\n\n            if (isString(item) && item.startsWith(`${column.name}.`)) {\n              const [, ...path] = item.split('.');\n              return [...acc, path.join('.')];\n            }\n\n            return acc;\n          }, [] as string[]);\n\n          data[column.name] = initObject(\n            db,\n            schemaTables,\n            linkTable,\n            value,\n            selectedLinkColumns as SelectableColumn<unknown>[]\n          );\n        } else {\n          data[column.name] = null;\n        }\n\n        break;\n      }\n      case 'file':\n        data[column.name] = isDefined(value) ? new XataFile(value as any) : null;\n        break;\n      case 'file[]':\n        data[column.name] = (value as XataArrayFile[])?.map((item) => new XataFile(item)) ?? null;\n        break;\n      case 'json':\n        data[column.name] = parseJson(value as string);\n        break;\n      default:\n        data[column.name] = value ?? null;\n\n        if (column.notNull === true && value === null) {\n          console.error(`Parse error, column ${column.name} is non nullable and value resolves null`);\n        }\n        break;\n    }\n  }\n\n  const record = { ...data };\n  const metadata =\n    xata !== undefined\n      ? { ...xata, createdAt: new Date(xata.createdAt), updatedAt: new Date(xata.updatedAt) }\n      : undefined;\n\n  record.read = function (columns?: any) {\n    return db[table].read(record['id'] as string, columns);\n  };\n\n  record.update = function (data: any, b?: any, c?: any) {\n    const columns = isValidSelectableColumns(b) ? b : ['*'];\n    const ifVersion = parseIfVersion(b, c);\n\n    return db[table].update(record['id'] as string, data, columns, { ifVersion });\n  };\n\n  record.replace = function (data: any, b?: any, c?: any) {\n    const columns = isValidSelectableColumns(b) ? b : ['*'];\n    const ifVersion = parseIfVersion(b, c);\n\n    return db[table].createOrReplace(record['id'] as string, data, columns, { ifVersion });\n  };\n\n  record.delete = function () {\n    return db[table].delete(record['id'] as string);\n  };\n\n  if (metadata !== undefined) {\n    record.xata = Object.freeze(metadata);\n  }\n\n  record.getMetadata = function () {\n    return record.xata;\n  };\n\n  record.toSerializable = function () {\n    return JSON.parse(JSON.stringify(record));\n  };\n\n  record.toString = function () {\n    return JSON.stringify(record);\n  };\n\n  for (const prop of ['read', 'update', 'replace', 'delete', 'getMetadata', 'toSerializable', 'toString']) {\n    Object.defineProperty(record, prop, { enumerable: false });\n  }\n\n  Object.freeze(record);\n  // `as unkwnown` to avoid TS error on versions prior to 4.9 (can be removed once we drop support for older versions)\n  return record as unknown as T;\n};\n\nfunction extractId(value: any): Identifier | undefined {\n  if (isString(value)) return value;\n  if (isObject(value) && isString(value.id)) return value.id;\n  return undefined;\n}\n\nfunction isValidColumn(\n  columns: SelectableColumn<any>[] | SelectableColumnWithObjectNotation<any>[],\n  column: Schemas.Column\n) {\n  // Every column alias\n  if (columns.includes('*')) return true;\n\n  // Match column name and all its children (foo, foo.bar, foo.bar.baz)\n  return columns.filter((item) => isString(item) && item.startsWith(column.name)).length > 0;\n}\n\nfunction parseIfVersion(...args: any[]): number | undefined {\n  for (const arg of args) {\n    if (isObject(arg) && isNumber(arg.ifVersion)) {\n      return arg.ifVersion;\n    }\n  }\n\n  return undefined;\n}\n","export interface CacheImpl {\n  defaultQueryTTL: number;\n\n  getAll(): Promise<Record<string, unknown>>;\n  get: <T>(key: string) => Promise<T | null>;\n  set: <T>(key: string, value: T) => Promise<void>;\n  delete: (key: string) => Promise<void>;\n  clear: () => Promise<void>;\n}\n\nexport interface SimpleCacheOptions {\n  max?: number;\n  defaultQueryTTL?: number;\n}\n\nexport class SimpleCache implements CacheImpl {\n  #map: Map<string, unknown>;\n\n  capacity: number;\n  defaultQueryTTL: number;\n\n  constructor(options: SimpleCacheOptions = {}) {\n    this.#map = new Map();\n    this.capacity = options.max ?? 500;\n    this.defaultQueryTTL = options.defaultQueryTTL ?? 60 * 1000;\n  }\n\n  async getAll(): Promise<Record<string, unknown>> {\n    return Object.fromEntries(this.#map);\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    return (this.#map.get(key) ?? null) as T | null;\n  }\n\n  async set<T>(key: string, value: T): Promise<void> {\n    await this.delete(key);\n    this.#map.set(key, value);\n\n    if (this.#map.size > this.capacity) {\n      const leastRecentlyUsed = this.#map.keys().next().value;\n      await this.delete(leastRecentlyUsed);\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    this.#map.delete(key);\n  }\n\n  async clear(): Promise<void> {\n    return this.#map.clear();\n  }\n}\n","import {\n  ArrayFilter,\n  ComparableType,\n  ComparableTypeFilter,\n  ExistanceFilter,\n  FilterColumns,\n  PropertyFilter,\n  StringTypeFilter\n} from './filters';\n\n/**\n * Operator to restrict results to only values that are greater than the given value.\n */\nexport const greaterThan = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $gt: value });\n\n/**\n * Operator to restrict results to only values that are greater than the given value.\n */\nexport const gt = greaterThan;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const greaterThanEquals = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $ge: value });\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const greaterEquals = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const gte = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const ge = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than the given value.\n */\nexport const lessThan = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $lt: value });\n\n/**\n * Operator to restrict results to only values that are lower than the given value.\n */\nexport const lt = lessThan;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lessThanEquals = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $le: value });\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lessEquals = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lte = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const le = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are not null.\n */\nexport const exists = <T>(column?: FilterColumns<T>): ExistanceFilter<T> => ({ $exists: column });\n\n/**\n * Operator to restrict results to only values that are null.\n */\nexport const notExists = <T>(column?: FilterColumns<T>): ExistanceFilter<T> => ({ $notExists: column });\n\n/**\n * Operator to restrict results to only values that start with the given prefix.\n */\nexport const startsWith = (value: string): StringTypeFilter => ({ $startsWith: value });\n\n/**\n * Operator to restrict results to only values that end with the given suffix.\n */\nexport const endsWith = (value: string): StringTypeFilter => ({ $endsWith: value });\n\n/**\n * Operator to restrict results to only values that match the given pattern.\n */\nexport const pattern = (value: string): StringTypeFilter => ({ $pattern: value });\n\n/**\n * Operator to restrict results to only values that match the given pattern (case insensitive).\n */\nexport const iPattern = (value: string): StringTypeFilter => ({ $iPattern: value });\n\n/**\n * Operator to restrict results to only values that are equal to the given value.\n */\nexport const is = <T>(value: T): PropertyFilter<T> => ({ $is: value });\n\n/**\n * Operator to restrict results to only values that are equal to the given value.\n */\nexport const equals = is;\n\n/**\n * Operator to restrict results to only values that are not equal to the given value.\n */\nexport const isNot = <T>(value: T): PropertyFilter<T> => ({ $isNot: value });\n\n/**\n * Operator to restrict results to only values that contain the given value.\n */\nexport const contains = (value: string): StringTypeFilter => ({ $contains: value });\n\n/**\n * Operator to restrict results to only values that contain the given value (case insensitive).\n */\nexport const iContains = (value: string): StringTypeFilter => ({ $iContains: value });\n\n/**\n * Operator to restrict results if some array items match the predicate.\n */\nexport const includes = <T>(value: T): ArrayFilter<T> => ({ $includes: value });\n\n/**\n * Operator to restrict results if all array items match the predicate.\n */\nexport const includesAll = <T>(value: T): ArrayFilter<T> => ({ $includesAll: value });\n\n/**\n * Operator to restrict results if none array items match the predicate.\n */\nexport const includesNone = <T>(value: T): ArrayFilter<T> => ({ $includesNone: value });\n\n/**\n * Operator to restrict results if some array items match the predicate.\n */\nexport const includesAny = <T>(value: T): ArrayFilter<T> => ({ $includesAny: value });\n","import { Table } from '../api/schemas';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { isString } from '../util/lang';\nimport { XataRecord } from './record';\nimport { Repository, RestRepository } from './repository';\n\nexport * from './cache';\nexport * from './inference';\nexport * from './operators';\nexport * from './pagination';\nexport { Query } from './query';\nexport { isIdentifiable, isXataRecord, RecordColumnTypes } from './record';\nexport type { BaseData, EditableData, Identifiable, Link, XataRecord, JSONData } from './record';\nexport { XataFile } from './files';\nexport type { XataArrayFile } from './files';\nexport { Repository, RestRepository } from './repository';\nexport * from './selection';\nexport * from './ask';\n\nexport type SchemaDefinition = {\n  table: string;\n};\n\nexport type SchemaPluginResult<Schemas extends Record<string, XataRecord>> = {\n  [Key in keyof Schemas]: Repository<Schemas[Key]>;\n};\n\nexport class SchemaPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  #tables: Record<string, Repository<any>> = {};\n  #schemaTables?: Table[];\n\n  constructor(schemaTables?: Table[]) {\n    super();\n\n    this.#schemaTables = schemaTables;\n  }\n\n  build(pluginOptions: XataPluginOptions): SchemaPluginResult<Schemas> {\n    const db: any = new Proxy(\n      {},\n      {\n        get: (_target, table) => {\n          if (!isString(table)) throw new Error('Invalid table name');\n          if (this.#tables[table] === undefined) {\n            this.#tables[table] = new RestRepository({ db, pluginOptions, table, schemaTables: this.#schemaTables });\n          }\n\n          return this.#tables[table];\n        }\n      }\n    );\n\n    // Inject generated tables for shell to auto-complete\n    const tableNames = this.#schemaTables?.map(({ name }) => name) ?? [];\n    for (const table of tableNames) {\n      db[table] = new RestRepository({ db, pluginOptions, table, schemaTables: this.#schemaTables });\n    }\n\n    return db;\n  }\n}\n","import { deleteFileItem, getFileItem, putFileItem } from '../api';\nimport { FileResponse } from '../api/dataPlaneSchemas';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { ColumnsByValue, XataArrayFile, XataFile } from '../schema';\nimport { BaseData, XataRecord } from '../schema/record';\nimport { isBlob } from '../util/lang';\nimport { GetArrayInnerType, StringKeys, Values } from '../util/types';\n\nexport type BinaryFile = string | Blob | ArrayBuffer | XataFile | Promise<XataFile>;\n\nexport type FilesPluginResult<Schemas extends Record<string, BaseData>> = {\n  download: <Tables extends StringKeys<Schemas>>(location: DownloadDestination<Schemas, Tables>) => Promise<Blob>;\n  upload: <Tables extends StringKeys<Schemas>>(\n    location: UploadDestination<Schemas, Tables>,\n    file: BinaryFile,\n    options?: { mediaType?: string }\n  ) => Promise<FileResponse>;\n  delete: <Tables extends StringKeys<Schemas>>(location: DownloadDestination<Schemas, Tables>) => Promise<FileResponse>;\n};\n\nexport type UploadDestination<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = Values<{\n  [Model in GetArrayInnerType<NonNullable<Tables[]>>]:\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataFile>;\n        record: string;\n      }\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataArrayFile[]>;\n        record: string;\n        fileId?: string;\n      };\n}>;\n\nexport type DownloadDestination<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = Values<{\n  [Model in GetArrayInnerType<NonNullable<Tables[]>>]:\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataFile>;\n        record: string;\n      }\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataArrayFile[]>;\n        record: string;\n        fileId: string;\n      };\n}>;\n\nexport class FilesPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): FilesPluginResult<Schemas> {\n    return {\n      download: async (location: Record<string, string | undefined>) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n\n        return await getFileItem({\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          ...pluginOptions,\n          rawResponse: true\n        });\n      },\n      upload: async (\n        location: Record<string, string | undefined>,\n        file: BinaryFile,\n        options?: { mediaType?: string }\n      ) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n        const resolvedFile = await file;\n        const contentType = options?.mediaType || getContentType(resolvedFile);\n        const body = resolvedFile instanceof XataFile ? resolvedFile.toBlob() : (resolvedFile as Blob);\n\n        return await putFileItem({\n          ...pluginOptions,\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          body,\n          headers: { 'Content-Type': contentType }\n        });\n      },\n      delete: async (location: Record<string, string | undefined>) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n\n        return await deleteFileItem({\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          ...pluginOptions\n        });\n      }\n    };\n  }\n}\n\nfunction getContentType(file: BinaryFile): string {\n  if (typeof file === 'string') {\n    return 'text/plain';\n  }\n\n  // Check for XataFile\n  if ('mediaType' in file) {\n    return file.mediaType;\n  }\n\n  if (isBlob(file)) {\n    return file.type;\n  }\n\n  try {\n    // Check for Blobs that are not instances of Blob\n    return (file as any).type;\n  } catch (e) {\n    // ignore\n  }\n\n  return 'application/octet-stream';\n}\n","import { getBranchDetails, searchBranch } from '../api';\nimport { FuzzinessExpression, HighlightExpression, PrefixExpression, SearchPageConfig, Table } from '../api/schemas';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { SchemaPluginResult } from '../schema';\nimport { Filter } from '../schema/filters';\nimport { BaseData, XataRecord, XataRecordMetadata } from '../schema/record';\nimport { initObject } from '../schema/repository';\nimport { SelectedPick } from '../schema/selection';\nimport { GetArrayInnerType, StringKeys, Values } from '../util/types';\nimport { Boosters } from './boosters';\nimport { TargetColumn } from './target';\n\nexport type SearchOptions<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = {\n  fuzziness?: FuzzinessExpression;\n  prefix?: PrefixExpression;\n  highlight?: HighlightExpression;\n  tables?: Array<\n    | Tables\n    | Values<{\n        [Model in GetArrayInnerType<NonNullable<Tables[]>>]: {\n          table: Model;\n          target?: TargetColumn<Schemas[Model] & XataRecord>[];\n          filter?: Filter<SelectedPick<Schemas[Model] & XataRecord, ['*']>>;\n          boosters?: Boosters<Schemas[Model] & XataRecord>[];\n        };\n      }>\n  >;\n  page?: SearchPageConfig;\n};\n\nexport type SearchPluginResult<Schemas extends Record<string, BaseData>> = {\n  all: <Tables extends StringKeys<Schemas>>(\n    query: string,\n    options?: SearchOptions<Schemas, Tables>\n  ) => Promise<\n    Values<{\n      [Model in ExtractTables<\n        Schemas,\n        Tables,\n        GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>\n      >]: {\n        table: Model;\n        record: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>>;\n      };\n    }>[]\n  >;\n  byTable: <Tables extends StringKeys<Schemas>>(\n    query: string,\n    options?: SearchOptions<Schemas, Tables>\n  ) => Promise<{\n    [Model in ExtractTables<\n      Schemas,\n      Tables,\n      GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>\n    >]?: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>[]>;\n  }>;\n};\n\nexport class SearchPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  #schemaTables?: Table[];\n\n  constructor(private db: SchemaPluginResult<Schemas>, schemaTables?: Table[]) {\n    super();\n    this.#schemaTables = schemaTables;\n  }\n\n  build(pluginOptions: XataPluginOptions): SearchPluginResult<Schemas> {\n    return {\n      all: async <Tables extends StringKeys<Schemas>>(query: string, options: SearchOptions<Schemas, Tables> = {}) => {\n        const records = await this.#search(query, options, pluginOptions);\n        const schemaTables = await this.#getSchemaTables(pluginOptions);\n\n        return records.map((record) => {\n          const { table = 'orphan' } = record.xata;\n\n          // TODO: Search endpoint doesn't support column selection\n          return { table, record: initObject(this.db, schemaTables, table, record, ['*']) } as any;\n        });\n      },\n      byTable: async <Tables extends StringKeys<Schemas>>(\n        query: string,\n        options: SearchOptions<Schemas, Tables> = {}\n      ) => {\n        const records = await this.#search(query, options, pluginOptions);\n        const schemaTables = await this.#getSchemaTables(pluginOptions);\n\n        return records.reduce((acc, record) => {\n          const { table = 'orphan' } = record.xata;\n\n          const items = acc[table] ?? [];\n          // TODO: Search endpoint doesn't support column selection\n          const item = initObject(this.db, schemaTables, table, record, ['*']);\n\n          return { ...acc, [table]: [...items, item] };\n        }, {} as any);\n      }\n    };\n  }\n\n  async #search<Tables extends StringKeys<Schemas>>(\n    query: string,\n    options: SearchOptions<Schemas, Tables>,\n    pluginOptions: XataPluginOptions\n  ) {\n    const { tables, fuzziness, highlight, prefix, page } = options ?? {};\n\n    const { records } = await searchBranch({\n      pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n      // @ts-ignore https://github.com/xataio/client-ts/issues/313\n      body: { tables, query, fuzziness, prefix, highlight, page },\n      ...pluginOptions\n    });\n\n    return records;\n  }\n\n  async #getSchemaTables(pluginOptions: XataPluginOptions): Promise<Table[]> {\n    if (this.#schemaTables) return this.#schemaTables;\n\n    const { schema } = await getBranchDetails({\n      pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n      ...pluginOptions\n    });\n\n    this.#schemaTables = schema.tables;\n    return schema.tables;\n  }\n}\n\nexport type SearchXataRecord<Record extends XataRecord> = Omit<Record, 'getMetadata'> & {\n  getMetadata: () => XataRecordMetadata & SearchExtraProperties;\n};\n\ntype SearchExtraProperties = {\n  /*\n   * The record's table name. APIs that return records from multiple tables will set this field accordingly.\n   */\n  table: string;\n  /*\n   * Highlights of the record. This is used by the search APIs to indicate which fields and parts of the fields have matched the search.\n   */\n  highlight?: {\n    [key: string]:\n      | string[]\n      | {\n          [key: string]: any;\n        };\n  };\n  /*\n   * The record's relevancy score. This is returned by the search APIs.\n   */\n  score?: number;\n};\n\ntype ReturnTable<Table, Tables> = Table extends Tables ? Table : never;\n\ntype ExtractTables<\n  Schemas extends Record<string, BaseData>,\n  Tables extends StringKeys<Schemas>,\n  TableOptions extends GetArrayInnerType<NonNullable<NonNullable<SearchOptions<Schemas, Tables>>['tables']>>\n> = TableOptions extends `${infer Table}`\n  ? ReturnTable<Table, Tables>\n  : TableOptions extends { table: infer Table }\n  ? ReturnTable<Table, Tables>\n  : never;\n","import { SQLQuery } from '.';\nimport { isDefined, isObject, isString, isStringArray } from '../util/lang';\n\nfunction escapeElement(elementRepresentation: string) {\n  const escaped = elementRepresentation.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\n  return '\"' + escaped + '\"';\n}\n\nfunction arrayString<T extends any[]>(val: T) {\n  let result = '{';\n  for (let i = 0; i < val.length; i++) {\n    if (i > 0) {\n      result = result + ',';\n    }\n    if (val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL';\n    } else if (Array.isArray(val[i])) {\n      result = result + arrayString(val[i]);\n    } else if (val[i] instanceof Buffer) {\n      result += '\\\\\\\\x' + val[i].toString('hex');\n    } else {\n      result += escapeElement(prepareValue(val[i]));\n    }\n  }\n  result = result + '}';\n  return result;\n}\n\n// Code distilled from pg/lib/utils.js\nfunction prepareValue(value: unknown) {\n  // null and undefined are both NULL in postgres\n  if (!isDefined(value)) return null;\n\n  // Convert JS Date to Postgres timestamp type\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  // Convert arrays to postgres array syntax\n  if (Array.isArray(value)) {\n    return arrayString(value);\n  }\n\n  // Convert objects to JSON strings\n  if (isObject(value)) {\n    return JSON.stringify(value);\n  }\n\n  try {\n    // @ts-expect-error - Unknown type, attempt to coerce to string\n    return value.toString();\n  } catch (e) {\n    return value;\n  }\n}\n\nexport function prepareParams(param1: SQLQuery, param2?: any[]) {\n  if (isString(param1)) {\n    return { statement: param1, params: param2?.map((value) => prepareValue(value)) };\n  }\n\n  if (isStringArray(param1)) {\n    const statement = param1.reduce((acc, curr, index) => {\n      return acc + curr + (index < (param2?.length ?? 0) ? '$' + (index + 1) : '');\n    }, '');\n\n    return { statement, params: param2?.map((value) => prepareValue(value)) };\n  }\n\n  if (isObject(param1)) {\n    const { statement, params, consistency } = param1;\n\n    return { statement, params: params?.map((value) => prepareValue(value)), consistency };\n  }\n\n  throw new Error('Invalid query');\n}\n","import { sqlQuery } from '../api';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { prepareParams } from './parameters';\n\nexport type SQLQueryParams<T = any[]> = {\n  statement: string;\n  params?: T;\n  consistency?: 'strong' | 'eventual';\n};\n\nexport type SQLQuery = TemplateStringsArray | SQLQueryParams | string;\n\nexport type SQLPluginResult = <T>(\n  query: SQLQuery,\n  ...parameters: any[]\n) => Promise<{\n  records: T[];\n  warning?: string;\n}>;\n\nexport class SQLPlugin extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): SQLPluginResult {\n    return async <T>(param1: SQLQuery, ...param2: any[]) => {\n      const { statement, params, consistency } = prepareParams(param1, param2);\n\n      const { records, warning } = await sqlQuery({\n        pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n        body: { statement, params, consistency },\n        ...pluginOptions\n      });\n\n      return { records: records as T[], warning };\n    };\n  }\n}\n","import { branchTransaction } from '../api';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { XataRecord } from '../schema/record';\nimport { Narrow, StringKeys } from '../util/types';\nimport { TransactionOperation, TransactionResults } from './operations';\n\nexport type TransactionPluginResult<Schemas extends Record<string, XataRecord>> = {\n  run: <Tables extends StringKeys<Schemas>, Operations extends TransactionOperation<Schemas, Tables>[]>(\n    operations: Narrow<Operations>\n  ) => Promise<TransactionResults<Schemas, Tables, Operations>>;\n};\n\nexport class TransactionPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): TransactionPluginResult<Schemas> {\n    return {\n      run: async <Tables extends StringKeys<Schemas>, Operations extends TransactionOperation<Schemas, Tables>[]>(\n        operations: Narrow<Operations>\n      ) => {\n        const response = await branchTransaction({\n          pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n          body: { operations: operations as any },\n          ...pluginOptions\n        });\n\n        return response as any;\n      }\n    };\n  }\n}\n\nexport * from './operations';\n","import { ApiExtraProps, HostProvider, Schemas } from './api';\nimport { FilesPlugin, FilesPluginResult } from './files';\nimport { XataPlugin, XataPluginOptions } from './plugins';\nimport { BaseSchema, SchemaPlugin, SchemaPluginResult, XataRecord } from './schema';\nimport { CacheImpl, SimpleCache } from './schema/cache';\nimport { defaultTrace, TraceFunction } from './schema/tracing';\nimport { SearchPlugin, SearchPluginResult } from './search';\nimport { SQLPlugin, SQLPluginResult } from './sql';\nimport { TransactionPlugin, TransactionPluginResult } from './transaction';\nimport { getAPIKey, getBranch, getDatabaseURL, getEnableBrowserVariable, getPreviewBranch } from './util/environment';\nimport { FetchImpl, getFetchImplementation } from './util/fetch';\nimport { AllRequired, StringKeys } from './util/types';\nimport { generateUUID } from './util/uuid';\n\nexport type BaseClientOptions = {\n  fetch?: FetchImpl;\n  host?: HostProvider;\n  apiKey?: string;\n  databaseURL?: string;\n  branch?: string;\n  cache?: CacheImpl;\n  trace?: TraceFunction;\n  enableBrowser?: boolean;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\ntype SafeOptions = AllRequired<Omit<BaseClientOptions, 'clientName' | 'xataAgentExtra'>> & {\n  host: HostProvider;\n  clientID: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const buildClient = <Plugins extends Record<string, XataPlugin> = {}>(plugins?: Plugins) =>\n  class {\n    #options: SafeOptions;\n\n    db: SchemaPluginResult<any>;\n    search: SearchPluginResult<any>;\n    transactions: TransactionPluginResult<any>;\n    sql: SQLPluginResult;\n    files: FilesPluginResult<any>;\n\n    constructor(options: BaseClientOptions = {}, schemaTables?: Schemas.Table[]) {\n      const safeOptions = this.#parseOptions(options);\n      this.#options = safeOptions;\n\n      const pluginOptions: XataPluginOptions = {\n        ...this.#getFetchProps(safeOptions),\n        cache: safeOptions.cache,\n        host: safeOptions.host\n      };\n\n      const db = new SchemaPlugin(schemaTables).build(pluginOptions);\n      const search = new SearchPlugin(db, schemaTables).build(pluginOptions);\n      const transactions = new TransactionPlugin().build(pluginOptions);\n      const sql = new SQLPlugin().build(pluginOptions);\n      const files = new FilesPlugin().build(pluginOptions);\n\n      // We assign the namespaces after creating in case the user overrides the db plugin\n      this.db = db;\n      this.search = search;\n      this.transactions = transactions;\n      this.sql = sql;\n      this.files = files;\n\n      for (const [key, namespace] of Object.entries(plugins ?? {})) {\n        if (namespace === undefined) continue;\n\n        // @ts-ignore\n        this[key] = namespace.build(pluginOptions);\n      }\n    }\n\n    public async getConfig() {\n      const databaseURL = this.#options.databaseURL;\n      const branch = this.#options.branch;\n\n      return { databaseURL, branch };\n    }\n\n    #parseOptions(options?: BaseClientOptions): SafeOptions {\n      // If is running from the browser and the user didn't pass `enableBrowser` we throw an error\n      const enableBrowser = options?.enableBrowser ?? getEnableBrowserVariable() ?? false;\n      // @ts-ignore Window, Deno are not globals\n      const isBrowser = typeof window !== 'undefined' && typeof Deno === 'undefined';\n      if (isBrowser && !enableBrowser) {\n        throw new Error(\n          'You are trying to use Xata from the browser, which is potentially a non-secure environment. If you understand the security concerns, such as leaking your credentials, pass `enableBrowser: true` to the client options to remove this error.'\n        );\n      }\n\n      const fetch = getFetchImplementation(options?.fetch);\n      const databaseURL = options?.databaseURL || getDatabaseURL();\n      const apiKey = options?.apiKey || getAPIKey();\n      const cache = options?.cache ?? new SimpleCache({ defaultQueryTTL: 0 });\n      const trace = options?.trace ?? defaultTrace;\n      const clientName = options?.clientName;\n      const host = options?.host ?? 'production';\n      const xataAgentExtra = options?.xataAgentExtra;\n\n      if (!apiKey) {\n        throw new Error('Option apiKey is required');\n      }\n\n      if (!databaseURL) {\n        throw new Error('Option databaseURL is required');\n      }\n\n      const envBranch = getBranch();\n      const previewBranch = getPreviewBranch();\n      const branch = options?.branch || previewBranch || envBranch || 'main';\n      if (!!previewBranch && branch !== previewBranch) {\n        console.warn(\n          `Ignoring preview branch ${previewBranch} because branch option was passed to the client constructor with value ${branch}`\n        );\n      } else if (!!envBranch && branch !== envBranch) {\n        console.warn(\n          `Ignoring branch ${envBranch} because branch option was passed to the client constructor with value ${branch}`\n        );\n      } else if (!!previewBranch && !!envBranch && previewBranch !== envBranch) {\n        console.warn(\n          `Ignoring preview branch ${previewBranch} and branch ${envBranch} because branch option was passed to the client constructor with value ${branch}`\n        );\n      } else if (!previewBranch && !envBranch && options?.branch === undefined) {\n        console.warn(\n          `No branch was passed to the client constructor. Using default branch ${branch}. You can set the branch with the environment variable XATA_BRANCH or by passing the branch option to the client constructor.`\n        );\n      }\n\n      return {\n        fetch,\n        databaseURL,\n        apiKey,\n        branch,\n        cache,\n        trace,\n        host,\n        clientID: generateUUID(),\n        enableBrowser,\n        clientName,\n        xataAgentExtra\n      };\n    }\n\n    #getFetchProps({\n      fetch,\n      apiKey,\n      databaseURL,\n      branch,\n      trace,\n      clientID,\n      clientName,\n      xataAgentExtra\n    }: SafeOptions): ApiExtraProps {\n      return {\n        fetch,\n        apiKey,\n        apiUrl: '',\n        // Instead of using workspace and dbBranch, we inject a probably CNAME'd URL\n        workspacesApiUrl: (path, params) => {\n          const hasBranch = params.dbBranchName ?? params.branch;\n          const newPath = path.replace(/^\\/db\\/[^/]+/, hasBranch !== undefined ? `:${branch}` : '');\n          return databaseURL + newPath;\n        },\n        trace,\n        clientID,\n        clientName,\n        xataAgentExtra\n      };\n    }\n  } as unknown as ClientConstructor<Plugins>;\n\nexport interface ClientConstructor<Plugins extends Record<string, XataPlugin>> {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  new <Schemas extends Record<string, XataRecord> = {}>(\n    options?: Partial<BaseClientOptions>,\n    schemaTables?: readonly BaseSchema[]\n  ): Omit<\n    {\n      db: Awaited<ReturnType<SchemaPlugin<Schemas>['build']>>;\n      search: Awaited<ReturnType<SearchPlugin<Schemas>['build']>>;\n      transactions: Awaited<ReturnType<TransactionPlugin<Schemas>['build']>>;\n      sql: Awaited<ReturnType<SQLPlugin['build']>>;\n      files: Awaited<ReturnType<FilesPlugin<Schemas>['build']>>;\n    },\n    keyof Plugins\n  > & {\n    [Key in StringKeys<NonNullable<Plugins>>]: Awaited<ReturnType<NonNullable<Plugins>[Key]['build']>>;\n  } & {\n    getConfig(): Promise<{\n      databaseURL: string;\n      branch: string;\n    }>;\n  };\n}\n\nexport class BaseClient extends buildClient()<Record<string, any>> {}\n","import { Identifiable, XataRecord } from '../schema/record';\n\n// These will be used to set special fields to serialized objects.\n// So objects should not use this field names. I think that's fine. Another approach would be to generate two objects:\n// One containing the \"data tree\" and another containing the a tree with the type information.\nconst META = '__';\nconst VALUE = '___';\n\n// TODO: Add types for the serializer\nexport class Serializer {\n  classes: Record<string, any> = {};\n\n  add(clazz: any) {\n    this.classes[clazz.name] = clazz;\n  }\n\n  toJSON<T>(data: T): string {\n    // We are not using JSON.stringify() and the replacer function here, because the replacer receives\n    // the result of toJSON() if the object has a toJSON() method. This is a problem for the Date type:\n    // we get a string, because Date.toJSON() returns the date formatted into a ISO string alreayd,\n    // so it's not possible to guess the type of the original object.\n    function visit(obj: any): any {\n      if (Array.isArray(obj)) return obj.map(visit);\n\n      const type = typeof obj;\n      if (type === 'undefined') return { [META]: 'undefined' };\n      if (type === 'bigint') return { [META]: 'bigint', [VALUE]: obj.toString() };\n      if (obj === null || type !== 'object') return obj;\n\n      const constructor = obj.constructor;\n      const o: Record<string, any> = { [META]: constructor.name };\n      for (const [key, value] of Object.entries(obj)) {\n        o[key] = visit(value);\n      }\n      if (constructor === Date) o[VALUE] = obj.toISOString();\n      if (constructor === Map) o[VALUE] = Object.fromEntries(obj);\n      if (constructor === Set) o[VALUE] = [...obj];\n      return o;\n    }\n\n    return JSON.stringify(visit(data));\n  }\n\n  fromJSON<T>(json: string): T {\n    return JSON.parse(json, (key, value) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        const { [META]: clazz, [VALUE]: val, ...rest } = value;\n        const constructor = this.classes[clazz];\n\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (constructor) {\n          return Object.assign(Object.create(constructor.prototype), rest);\n        }\n        if (clazz === 'Date') return new Date(val);\n        if (clazz === 'Set') return new Set(val);\n        if (clazz === 'Map') return new Map(Object.entries(val));\n        if (clazz === 'bigint') return BigInt(val);\n        // TODO: this is ignored. In order to support undefined we'd need to traverse the JSON tree ourselves.\n        // Instead of using the JSON.parse() reviver argument.\n        if (clazz === 'undefined') return undefined;\n        return rest;\n      }\n      return value;\n    });\n  }\n}\n\nconst defaultSerializer = new Serializer();\n\nexport type SerializedString<T> = string | (string & { __type: T });\nexport type DeserializedType<T> = T extends SerializedString<infer U> ? U : T;\n\nexport const serialize = <T>(data: T): SerializedString<T> => {\n  return defaultSerializer.toJSON(data) as SerializedString<T>;\n};\n\nexport const deserialize = <T extends SerializedString<any>>(json: T): SerializerResult<DeserializedType<T>> => {\n  return defaultSerializer.fromJSON(json);\n};\n\nexport type SerializerResult<T> = T extends XataRecord\n  ? Identifiable &\n      Omit<\n        {\n          [K in keyof T]: SerializerResult<T[K]>;\n        },\n        keyof XataRecord\n      >\n  : T extends any[]\n  ? SerializerResult<T[number]>[]\n  : T;\n","import { deserialize, serialize, SerializerResult } from '../serializer';\nimport { Request } from '../util/request';\n\ntype XataWorkerContext<XataClient> = { xata: XataClient; request: Request; env: Record<string, string | undefined> };\n\ntype XataWorkerResult<T extends (...args: any) => any> = SerializerResult<Awaited<ReturnType<T>>>;\n\ntype RemoveFirst<T> = T extends [any, ...infer U] ? U : never;\n\ntype WorkerRunnerConfig = {\n  workspace: string;\n  worker: string;\n};\n\nexport function buildWorkerRunner<XataClient>(config: WorkerRunnerConfig) {\n  return function xataWorker<WorkerFunction extends (ctx: XataWorkerContext<XataClient>, ...args: any[]) => any>(\n    name: string,\n    worker: WorkerFunction\n  ) {\n    return async (...args: RemoveFirst<Parameters<WorkerFunction>>): Promise<XataWorkerResult<typeof worker>> => {\n      const url =\n        process.env.NODE_ENV === 'development'\n          ? `http://localhost:64749/${name}`\n          : `https://dispatcher.xata.workers.dev/${config.workspace}/${config.worker}/${name}`;\n\n      const result = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: serialize({ args })\n      });\n\n      // TODO: Detect if not compiled yet (+ other errors)\n\n      const text = await (result as any).text();\n      return deserialize<any>(text);\n    };\n  };\n}\n","export class XataError extends Error {\n  readonly status: number;\n\n  constructor(message: string, status: number) {\n    super(message);\n    this.status = status;\n  }\n}\n\nexport * from './api';\nexport * from './client';\nexport * from './plugins';\nexport * from './schema';\nexport * from './search';\nexport * from './sql';\nexport * from './serializer';\nexport * from './files';\nexport * from './transaction';\nexport { transformImage } from './files/transformations';\nexport type { ImageTransformations } from './files/transformations';\nexport { getAPIKey, getBranch, getDatabaseURL, getPreviewBranch, buildPreviewBranchName } from './util/environment';\nexport * from './workers';\n"],"names":["__privateAdd","__privateSet","fetch","__privateGet","__privateMethod","operationsByTag","dataPlaneOperations","controlPlaneOperations","_table","_schemaTables","_getSchemaTables","getSchemaTables_fn","options","id","operations","columns","data"],"mappings":"AAQO,MAAM,YAA8B,GAAA,OACzC,IACA,EAAA,EAAA,EAIA,QACe,KAAA;AACf,EAAA,OAAO,MAAM,EAAG,CAAA;AAAA,IACd,IAAA;AAAA,IACA,eAAe,MAAM;AACnB,MAAA,OAAA;AAAA,KACF;AAAA,GACD,CAAA,CAAA;AACH,CAAA,CAAA;AAEO,MAAM,eAAkB,GAAA;AAAA,EAC7B,IAAM,EAAA,iBAAA;AAAA,EAEN,OAAS,EAAA,kBAAA;AAAA,EAET,KAAO,EAAA,YAAA;AAAA,EAEP,eAAiB,EAAA,iBAAA;AAAA,EACjB,gBAAkB,EAAA,kBAAA;AAAA,EAClB,SAAW,EAAA,WAAA;AAAA,EACX,WAAa,EAAA,aAAA;AAAA,EACb,eAAiB,EAAA,iBAAA;AAAA,EACjB,WAAa,EAAA,aAAA;AAAA,EACb,QAAU,EAAA,UAAA;AAAA,EACV,UAAY,EAAA,YAAA;AAAA,EACZ,WAAa,EAAA,aAAA;AAAA,EAEb,iBAAmB,EAAA,QAAA;AACrB,CAAA;;AC1CA,SAAS,SAAY,KAAyC,EAAA;AAC5D,EAAO,OAAA,KAAA,KAAU,QAAQ,KAAU,KAAA,KAAA,CAAA,CAAA;AACrC,CAAA;AAEO,SAAS,QAAW,GAAuC,EAAA;AAChE,EAAO,OAAA,GAAA,CAAI,OAAO,QAAQ,CAAA,CAAA;AAC5B,CAAA;AAEO,SAAS,cAAiB,GAA8D,EAAA;AAC7F,EAAA,OAAO,MAAO,CAAA,WAAA,CAAY,MAAO,CAAA,OAAA,CAAQ,GAAG,CAAE,CAAA,MAAA,CAAO,CAAC,GAAG,KAAK,CAAA,KAAM,QAAS,CAAA,KAAK,CAAC,CAAC,CAAA,CAAA;AACtF,CAAA;AAIO,SAAS,OAAO,KAA2B,EAAA;AAChD,EAAI,IAAA;AACF,IAAA,OAAO,KAAiB,YAAA,IAAA,CAAA;AAAA,WACjB,KAAO,EAAA;AAEd,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,SAAS,KAA8C,EAAA;AACrE,EAAA,OACE,QAAQ,KAAK,CAAA,IAAK,OAAO,KAAA,KAAU,YAAY,CAAC,KAAA,CAAM,OAAQ,CAAA,KAAK,KAAK,EAAE,KAAA,YAAiB,IAAS,CAAA,IAAA,CAAC,OAAO,KAAK,CAAA,CAAA;AAErH,CAAA;AAEO,SAAS,UAAa,KAAyC,EAAA;AACpE,EAAO,OAAA,KAAA,KAAU,QAAQ,KAAU,KAAA,KAAA,CAAA,CAAA;AACrC,CAAA;AAEO,SAAS,SAAS,KAA6B,EAAA;AACpD,EAAA,OAAO,SAAU,CAAA,KAAK,CAAK,IAAA,OAAO,KAAU,KAAA,QAAA,CAAA;AAC9C,CAAA;AAEO,SAAS,cAAc,KAA+B,EAAA;AAC3D,EAAO,OAAA,SAAA,CAAU,KAAK,CAAK,IAAA,KAAA,CAAM,QAAQ,KAAK,CAAA,IAAK,KAAM,CAAA,KAAA,CAAM,QAAQ,CAAA,CAAA;AACzE,CAAA;AAEO,SAAS,SAAS,KAA6B,EAAA;AACpD,EAAA,OAAO,SAAU,CAAA,KAAK,CAAK,IAAA,OAAO,KAAU,KAAA,QAAA,CAAA;AAC9C,CAAA;AAEO,SAAS,YAAY,KAAgC,EAAA;AAC1D,EAAI,IAAA,QAAA,CAAS,KAAK,CAAG,EAAA;AACnB,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAEA,EAAI,IAAA,QAAA,CAAS,KAAK,CAAG,EAAA;AACnB,IAAM,MAAA,MAAA,GAAS,OAAO,KAAK,CAAA,CAAA;AAC3B,IAAA,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,MAAM,CAAG,EAAA;AACzB,MAAO,OAAA,MAAA,CAAA;AAAA,KACT;AAAA,GACF;AAEA,EAAO,OAAA,KAAA,CAAA,CAAA;AACT,CAAA;AAEO,SAAS,SAAS,KAAuB,EAAA;AAC9C,EAAI,IAAA;AACF,IAAA,OAAO,KAAK,KAAK,CAAA,CAAA;AAAA,WACV,GAAK,EAAA;AACZ,IAAA,MAAM,GAAM,GAAA,MAAA,CAAA;AACZ,IAAA,OAAO,GAAI,CAAA,IAAA,CAAK,KAAK,CAAA,CAAE,SAAS,QAAQ,CAAA,CAAA;AAAA,GAC1C;AACF,CAAA;AAEgB,SAAA,SAAA,CAAwE,GAAM,CAAM,EAAA;AAClG,EAAM,MAAA,MAAA,GAA8B,EAAE,GAAG,CAAE,EAAA,CAAA;AAE3C,EAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,CAAC,CAAG,EAAA;AAC5C,IAAA,IAAI,SAAS,KAAK,CAAA,IAAK,SAAS,MAAO,CAAA,GAAG,CAAC,CAAG,EAAA;AAC5C,MAAA,MAAA,CAAO,GAAG,CAAI,GAAA,SAAA,CAAU,MAAO,CAAA,GAAG,GAAG,KAAK,CAAA,CAAA;AAAA,KACrC,MAAA;AACL,MAAA,MAAA,CAAO,GAAG,CAAI,GAAA,KAAA,CAAA;AAAA,KAChB;AAAA,GACF;AAEA,EAAO,OAAA,MAAA,CAAA;AACT,CAAA;AAgBgB,SAAA,KAAA,CAAS,OAAY,SAA0B,EAAA;AAC7D,EAAA,MAAM,SAAS,EAAC,CAAA;AAEhB,EAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,MAAA,EAAQ,KAAK,SAAW,EAAA;AAChD,IAAA,MAAA,CAAO,KAAK,KAAM,CAAA,KAAA,CAAM,CAAG,EAAA,CAAA,GAAI,SAAS,CAAC,CAAA,CAAA;AAAA,GAC3C;AAEA,EAAO,OAAA,MAAA,CAAA;AACT,CAAA;AAEA,eAAsB,QAAQ,EAAY,EAAA;AACxC,EAAA,OAAO,IAAI,OAAQ,CAAA,CAAC,YAAY,UAAW,CAAA,OAAA,EAAS,EAAE,CAAC,CAAA,CAAA;AACzD,CAAA;AAEO,SAAS,kBAAkB,EAAY,EAAA;AAC5C,EAAI,IAAA,SAAA,CAAA;AAEJ,EAAA,MAAM,OAAU,GAAA,IAAI,OAAc,CAAA,CAAC,OAAY,KAAA;AAC7C,IAAA,SAAA,GAAY,WAAW,MAAM;AAC3B,MAAQ,OAAA,EAAA,CAAA;AAAA,OACP,EAAE,CAAA,CAAA;AAAA,GACN,CAAA,CAAA;AAED,EAAO,OAAA;AAAA,IACL,MAAA,EAAQ,MAAM,YAAA,CAAa,SAAS,CAAA;AAAA,IACpC,OAAA;AAAA,GACF,CAAA;AACF,CAAA;AAGgB,SAAA,UAAA,CAAiB,aAAkB,MAAgD,EAAA;AACjG,EAAA,MAAM,OAAU,GAAA,CAAC,IAAoB,EAAA,UAAA,KACnC,IAAK,CAAA,IAAA;AAAA,IAAK,CAAC,GACT,KAAA,MAAA,CAAO,UAAU,CAAE,CAAA,IAAA,CAAK,CAAC,MAAW,KAAA;AAClC,MAAA,GAAA,CAAI,KAAK,MAAM,CAAA,CAAA;AACf,MAAO,OAAA,GAAA,CAAA;AAAA,KACR,CAAA;AAAA,GACH,CAAA;AAEF,EAAA,OAAO,YAAY,MAAO,CAAA,OAAA,EAAS,QAAQ,OAAQ,CAAA,EAAE,CAAC,CAAA,CAAA;AACxD;;ACtHO,SAAS,cAA8B,GAAA;AAE5C,EAAI,IAAA;AAEF,IAAA,IAAI,UAAU,OAAO,CAAA,IAAK,SAAU,CAAA,OAAA,CAAQ,GAAG,CAAG,EAAA;AAChD,MAAO,OAAA;AAAA,QACL,MAAQ,EAAA,OAAA,CAAQ,GAAI,CAAA,YAAA,IAAgB,eAAgB,EAAA;AAAA,QACpD,WAAa,EAAA,OAAA,CAAQ,GAAI,CAAA,iBAAA,IAAqB,oBAAqB,EAAA;AAAA,QACnE,MAAQ,EAAA,OAAA,CAAQ,GAAI,CAAA,WAAA,IAAe,eAAgB,EAAA;AAAA,QACnD,aAAA,EAAe,QAAQ,GAAI,CAAA,YAAA;AAAA,QAC3B,mBAAA,EAAqB,QAAQ,GAAI,CAAA,mBAAA;AAAA,QACjC,kBAAA,EAAoB,QAAQ,GAAI,CAAA,qBAAA;AAAA,QAChC,kBAAA,EAAoB,QAAQ,GAAI,CAAA,qBAAA;AAAA,OAClC,CAAA;AAAA,KACF;AAAA,WACO,GAAK,EAAA;AAAA,GAEd;AAGA,EAAI,IAAA;AACF,IAAA,IAAI,SAAS,IAAI,CAAA,IAAK,QAAS,CAAA,IAAA,CAAK,GAAG,CAAG,EAAA;AACxC,MAAO,OAAA;AAAA,QACL,QAAQ,IAAK,CAAA,GAAA,CAAI,GAAI,CAAA,cAAc,KAAK,eAAgB,EAAA;AAAA,QACxD,aAAa,IAAK,CAAA,GAAA,CAAI,GAAI,CAAA,mBAAmB,KAAK,oBAAqB,EAAA;AAAA,QACvE,QAAQ,IAAK,CAAA,GAAA,CAAI,GAAI,CAAA,aAAa,KAAK,eAAgB,EAAA;AAAA,QACvD,aAAe,EAAA,IAAA,CAAK,GAAI,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,QAC1C,mBAAqB,EAAA,IAAA,CAAK,GAAI,CAAA,GAAA,CAAI,qBAAqB,CAAA;AAAA,QACvD,kBAAoB,EAAA,IAAA,CAAK,GAAI,CAAA,GAAA,CAAI,uBAAuB,CAAA;AAAA,QACxD,kBAAoB,EAAA,IAAA,CAAK,GAAI,CAAA,GAAA,CAAI,uBAAuB,CAAA;AAAA,OAC1D,CAAA;AAAA,KACF;AAAA,WACO,GAAK,EAAA;AAAA,GAEd;AAEA,EAAO,OAAA;AAAA,IACL,QAAQ,eAAgB,EAAA;AAAA,IACxB,aAAa,oBAAqB,EAAA;AAAA,IAClC,QAAQ,eAAgB,EAAA;AAAA,IACxB,aAAe,EAAA,KAAA,CAAA;AAAA,IACf,mBAAqB,EAAA,KAAA,CAAA;AAAA,IACrB,kBAAoB,EAAA,KAAA,CAAA;AAAA,IACpB,kBAAoB,EAAA,KAAA,CAAA;AAAA,GACtB,CAAA;AACF,CAAA;AAEO,SAAS,wBAA2B,GAAA;AACzC,EAAI,IAAA;AACF,IAAI,IAAA,QAAA,CAAS,OAAO,CAAA,IAAK,QAAS,CAAA,OAAA,CAAQ,GAAG,CAAK,IAAA,OAAA,CAAQ,GAAI,CAAA,mBAAA,KAAwB,KAAW,CAAA,EAAA;AAC/F,MAAO,OAAA,OAAA,CAAQ,IAAI,mBAAwB,KAAA,MAAA,CAAA;AAAA,KAC7C;AAAA,WACO,GAAK,EAAA;AAAA,GAEd;AAEA,EAAI,IAAA;AACF,IAAA,IAAI,QAAS,CAAA,IAAI,CAAK,IAAA,QAAA,CAAS,IAAK,CAAA,GAAG,CAAK,IAAA,IAAA,CAAK,GAAI,CAAA,GAAA,CAAI,qBAAqB,CAAA,KAAM,KAAW,CAAA,EAAA;AAC7F,MAAA,OAAO,IAAK,CAAA,GAAA,CAAI,GAAI,CAAA,qBAAqB,CAAM,KAAA,MAAA,CAAA;AAAA,KACjD;AAAA,WACO,GAAK,EAAA;AAAA,GAEd;AAEA,EAAI,IAAA;AACF,IAAO,OAAA,mBAAA,KAAwB,QAAQ,mBAAwB,KAAA,MAAA,CAAA;AAAA,WACxD,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEA,SAAS,eAAsC,GAAA;AAC7C,EAAI,IAAA;AACF,IAAO,OAAA,YAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEA,SAAS,oBAA2C,GAAA;AAClD,EAAI,IAAA;AACF,IAAO,OAAA,iBAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEA,SAAS,eAAsC,GAAA;AAC7C,EAAI,IAAA;AACF,IAAO,OAAA,WAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,cAAiB,GAAA;AAC/B,EAAI,IAAA;AACF,IAAM,MAAA,EAAE,WAAY,EAAA,GAAI,cAAe,EAAA,CAAA;AACvC,IAAO,OAAA,WAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,SAAY,GAAA;AAC1B,EAAI,IAAA;AACF,IAAM,MAAA,EAAE,MAAO,EAAA,GAAI,cAAe,EAAA,CAAA;AAClC,IAAO,OAAA,MAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,SAAY,GAAA;AAC1B,EAAI,IAAA;AACF,IAAM,MAAA,EAAE,MAAO,EAAA,GAAI,cAAe,EAAA,CAAA;AAClC,IAAO,OAAA,MAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,sBAAuB,CAAA,EAAE,GAAK,EAAA,MAAA,EAA2C,EAAA;AACvF,EAAO,OAAA,CAAA,QAAA,EAAW,GAAG,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,CAAA;AACjC,CAAA;AAEO,SAAS,gBAAmB,GAAA;AACjC,EAAI,IAAA;AACF,IAAA,MAAM,EAAE,aAAe,EAAA,mBAAA,EAAqB,kBAAoB,EAAA,kBAAA,KAAuB,cAAe,EAAA,CAAA;AACtG,IAAI,IAAA,mBAAA;AAAqB,MAAO,OAAA,mBAAA,CAAA;AAEhC,IAAA,QAAQ,aAAe;AAAA,MACrB,KAAK,QAAU,EAAA;AACb,QAAI,IAAA,CAAC,kBAAsB,IAAA,CAAC,kBAAoB,EAAA;AAC9C,UAAA,OAAA,CAAQ,KAAK,qFAAqF,CAAA,CAAA;AAClG,UAAO,OAAA,KAAA,CAAA,CAAA;AAAA,SACT;AAEA,QAAA,OAAO,uBAAuB,EAAE,GAAA,EAAK,kBAAoB,EAAA,MAAA,EAAQ,oBAAoB,CAAA,CAAA;AAAA,OACvF;AAAA,KACF;AAEA,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAO,OAAA,KAAA,CAAA,CAAA;AAAA,GACT;AACF;;;;;;;;;;;;;;;;;;;;;;;;ACrKA,IAAA,MAAA,EAAA,MAAA,EAAA,YAAA,EAAA,QAAA,EAAA,UAAA,CAAA;AAEA,MAAM,eAAA,GAAkB,IAAI,EAAK,GAAA,GAAA,CAAA;AAmB1B,SAAS,uBAAuB,SAAuB,EAAA;AAE5D,EAAA,MAAM,WAAc,GAAA,OAAO,KAAU,KAAA,WAAA,GAAc,KAAQ,GAAA,KAAA,CAAA,CAAA;AAE3D,EAAA,MAAM,eAAkB,GAAA,OAAO,UAAe,KAAA,WAAA,GAAc,WAAW,KAAQ,GAAA,KAAA,CAAA,CAAA;AAC/E,EAAM,MAAA,SAAA,GAAoC,aAAsB,WAAwB,IAAA,eAAA,CAAA;AACxF,EAAA,IAAI,CAAC,SAAW,EAAA;AAEd,IAAM,MAAA,IAAI,MAAM,CAA2E,yEAAA,CAAA,CAAA,CAAA;AAAA,GAC7F;AACA,EAAO,OAAA,SAAA,CAAA;AACT,CAAA;AAEO,MAAM,cAAe,CAAA;AAAA,EAQ1B,WAAA,CAAY,cAAc,EAAI,EAAA;AAmD9B,IAAAA,cAAA,CAAA,IAAA,EAAA,QAAA,CAAA,CAAA;AA1DA,IAAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,YAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAME,IAAAC,cAAA,CAAA,IAAA,EAAK,QAAS,EAAC,CAAA,CAAA;AACf,IAAAA,cAAA,CAAA,IAAA,EAAK,YAAe,EAAA,WAAA,CAAA,CAAA;AAEpB,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AACf,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AAAA,GACjB;AAAA,EAEA,SAASC,MAAkB,EAAA;AACzB,IAAAD,cAAA,CAAA,IAAA,EAAK,MAASC,EAAAA,MAAAA,CAAAA,CAAAA;AAAA,GAChB;AAAA,EAEA,QAAsB,GAAA;AACpB,IAAI,IAAA,CAACC,qBAAK,MAAQ,CAAA,EAAA;AAChB,MAAM,MAAA,IAAI,MAAM,eAAe,CAAA,CAAA;AAAA,KACjC;AAEA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAAA,GACd;AAAA,EAEA,OAAA,CAAQ,KAAa,OAA0C,EAAA;AAC7D,IAAM,MAAA,KAAA,uBAAY,IAAK,EAAA,CAAA;AACvB,IAAM,MAAA,SAAA,GAAY,KAAK,QAAS,EAAA,CAAA;AAEhC,IAAM,MAAA,UAAA,GAAa,OAAO,OAAA,GAAU,KAA6B,KAAA;AAE/D,MAAA,MAAM,EAAE,OAAA,EAAS,MAAO,EAAA,GAAI,kBAAkB,eAAe,CAAA,CAAA;AAC7D,MAAA,MAAM,WAAW,MAAM,OAAA,CAAQ,IAAK,CAAA,CAAC,UAAU,GAAK,EAAA,OAAO,CAAG,EAAA,OAAA,CAAQ,KAAK,MAAM,IAAI,CAAC,CAAC,CAAA,CAAE,QAAQ,MAAM,CAAA,CAAA;AACvG,MAAA,IAAI,CAAC,QAAU,EAAA;AACb,QAAM,MAAA,IAAI,MAAM,mBAAmB,CAAA,CAAA;AAAA,OACrC;AAEA,MAAI,IAAA,QAAA,CAAS,WAAW,GAAK,EAAA;AAC3B,QAAA,MAAM,iBAAiB,WAAY,CAAA,QAAA,CAAS,SAAS,GAAI,CAAA,mBAAmB,CAAC,CAAK,IAAA,CAAA,CAAA;AAElF,QAAM,MAAA,OAAA,CAAQ,iBAAiB,GAAI,CAAA,CAAA;AACnC,QAAO,OAAA,MAAM,WAAW,IAAI,CAAA,CAAA;AAAA,OAC9B;AAEA,MAAA,IAAI,OAAS,EAAA;AACX,QAAA,MAAM,+BAAkB,IAAA,IAAA,IAAO,OAAQ,EAAA,GAAI,MAAM,OAAQ,EAAA,CAAA;AACzD,QAAQ,OAAA,CAAA,IAAA,CAAK,CAAyE,sEAAA,EAAA,WAAW,CAAI,EAAA,CAAA,CAAA,CAAA;AAAA,OACvG;AAEA,MAAO,OAAA,QAAA,CAAA;AAAA,KACT,CAAA;AAEA,IAAO,OAAAC,iBAAA,CAAA,IAAA,EAAK,QAAL,EAAA,UAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAc,YAAY;AAC/B,MAAA,OAAO,MAAM,UAAW,EAAA,CAAA;AAAA,KAC1B,CAAA,CAAA;AAAA,GACF;AA4BF,CAAA;AArFE,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,YAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAwDA,QAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,UAAA,GAAgB,SAAC,IAA8C,EAAA;AAC7D,EAAA,MAAM,OAAU,GAAA,IAAI,OAAgB,CAAA,CAAC,OAAY,KAAAD,cAAA,CAAA,IAAA,EAAK,MAAO,CAAA,CAAA,IAAA,CAAK,OAAO,CAAC,CACvE,CAAA,OAAA,CAAQ,MAAM;AACb,IAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AACL,IAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AAAA,GACN,EACA,IAAK,CAAA,MAAM,MAAM,CAAA,CACjB,QAAQ,MAAM;AACb,IAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AAEL,IAAM,MAAA,IAAA,GAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,KAAM,EAAA,CAAA;AAC/B,IAAA,IAAI,SAAS,KAAW,CAAA,EAAA;AACtB,MAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AACL,MAAK,IAAA,EAAA,CAAA;AAAA,KACP;AAAA,GACD,CAAA,CAAA;AAEH,EAAA,IAAI,IAAK,CAAA,OAAA,GAAU,IAAK,CAAA,OAAA,GAAUA,qBAAK,YAAc,CAAA,EAAA;AACnD,IAAM,MAAA,IAAA,GAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,KAAM,EAAA,CAAA;AAC/B,IAAA,IAAI,SAAS,KAAW,CAAA,EAAA;AACtB,MAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AACL,MAAK,IAAA,EAAA,CAAA;AAAA,KACP;AAAA,GACF;AAEA,EAAO,OAAA,OAAA,CAAA;AACT,CAAA;;ACvHK,SAAS,YAAe,GAAA;AAC7B,EAAA,OAAO,sCAAuC,CAAA,OAAA,CAAQ,OAAS,EAAA,SAAU,CAAG,EAAA;AAC1E,IAAM,MAAA,CAAA,GAAK,IAAK,CAAA,MAAA,EAAW,GAAA,EAAA,GAAM,CAC/B,EAAA,CAAA,GAAI,CAAK,IAAA,GAAA,GAAM,CAAK,GAAA,CAAA,GAAI,CAAO,GAAA,CAAA,CAAA;AACjC,IAAO,OAAA,CAAA,CAAE,SAAS,EAAE,CAAA,CAAA;AAAA,GACrB,CAAA,CAAA;AACH;;ACsBA,eAAe,QAAA,CAAS,QAAa,OAAoC,EAAA;AACvE,EAAM,MAAA,MAAA,GAAS,OAAO,SAAU,EAAA,CAAA;AAChC,EAAI,IAAA,MAAA,CAAA;AACJ,EAAA,OAAO,EAAE,MAAS,GAAA,MAAM,MAAO,CAAA,IAAA,IAAQ,IAAM,EAAA;AAC3C,IAAA,OAAA,CAAQ,OAAO,KAAK,CAAA,CAAA;AAAA,GACtB;AACF,CAAA;AAeA,SAAS,SAAS,MAAyD,EAAA;AACzE,EAAI,IAAA,MAAA,CAAA;AACJ,EAAI,IAAA,QAAA,CAAA;AACJ,EAAI,IAAA,WAAA,CAAA;AACJ,EAAA,IAAI,sBAAyB,GAAA,KAAA,CAAA;AAG7B,EAAO,OAAA,SAAS,QAAQ,GAAiB,EAAA;AACvC,IAAA,IAAI,WAAW,KAAW,CAAA,EAAA;AACxB,MAAS,MAAA,GAAA,GAAA,CAAA;AACT,MAAW,QAAA,GAAA,CAAA,CAAA;AACX,MAAc,WAAA,GAAA,CAAA,CAAA,CAAA;AAAA,KACT,MAAA;AAEL,MAAS,MAAA,GAAA,MAAA,CAAO,QAAQ,GAAG,CAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,MAAM,YAAY,MAAO,CAAA,MAAA,CAAA;AACzB,IAAA,IAAI,SAAY,GAAA,CAAA,CAAA;AAChB,IAAA,OAAO,WAAW,SAAW,EAAA;AAC3B,MAAA,IAAI,sBAAwB,EAAA;AAC1B,QAAI,IAAA,MAAA,CAAO,QAAQ,CAAA,KAAM,EAAsB,gBAAA;AAC7C,UAAA,SAAA,GAAY,EAAE,QAAA,CAAA;AAAA,SAChB;AAEA,QAAyB,sBAAA,GAAA,KAAA,CAAA;AAAA,OAC3B;AAGA,MAAA,IAAI,OAAU,GAAA,CAAA,CAAA,CAAA;AACd,MAAA,OAAO,QAAW,GAAA,SAAA,IAAa,OAAY,KAAA,CAAA,CAAA,EAAI,EAAE,QAAU,EAAA;AACzD,QAAQ,QAAA,MAAA,CAAO,QAAQ,CAAG;AAAA,UACxB,KAAK,EAAA;AACH,YAAA,IAAI,gBAAgB,CAAI,CAAA,EAAA;AAEtB,cAAA,WAAA,GAAc,QAAW,GAAA,SAAA,CAAA;AAAA,aAC3B;AACA,YAAA,MAAA;AAAA,UAEF,KAAK,EAAA;AACH,YAAyB,sBAAA,GAAA,IAAA,CAAA;AAAA,UAC3B,KAAK,EAAA;AACH,YAAU,OAAA,GAAA,QAAA,CAAA;AACV,YAAA,MAAA;AAAA,SACJ;AAAA,OACF;AAEA,MAAA,IAAI,YAAY,CAAI,CAAA,EAAA;AAGlB,QAAA,MAAA;AAAA,OACF;AAGA,MAAA,MAAA,CAAO,MAAO,CAAA,QAAA,CAAS,SAAW,EAAA,OAAO,GAAG,WAAW,CAAA,CAAA;AACvD,MAAY,SAAA,GAAA,QAAA,CAAA;AACZ,MAAc,WAAA,GAAA,CAAA,CAAA,CAAA;AAAA,KAChB;AAEA,IAAA,IAAI,cAAc,SAAW,EAAA;AAC3B,MAAS,MAAA,GAAA,KAAA,CAAA,CAAA;AAAA,KACX,MAAA,IAAW,cAAc,CAAG,EAAA;AAG1B,MAAS,MAAA,GAAA,MAAA,CAAO,SAAS,SAAS,CAAA,CAAA;AAClC,MAAY,QAAA,IAAA,SAAA,CAAA;AAAA,KACd;AAAA,GACF,CAAA;AACF,CAAA;AASA,SAAS,WAAA,CACP,IACA,EAAA,OAAA,EACA,SACA,EAAA;AACA,EAAA,IAAI,UAAU,UAAW,EAAA,CAAA;AACzB,EAAM,MAAA,OAAA,GAAU,IAAI,WAAY,EAAA,CAAA;AAGhC,EAAO,OAAA,SAAS,MAAO,CAAA,IAAA,EAAkB,WAAqB,EAAA;AAC5D,IAAI,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA;AAErB,MAAA,SAAA,GAAY,OAAO,CAAA,CAAA;AACnB,MAAA,OAAA,GAAU,UAAW,EAAA,CAAA;AAAA,KACvB,MAAA,IAAW,cAAc,CAAG,EAAA;AAI1B,MAAA,MAAM,QAAQ,OAAQ,CAAA,MAAA,CAAO,KAAK,QAAS,CAAA,CAAA,EAAG,WAAW,CAAC,CAAA,CAAA;AAC1D,MAAA,MAAM,cAAc,WAAe,IAAA,IAAA,CAAK,cAAc,CAAC,CAAA,KAAM,iBAAqB,CAAI,GAAA,CAAA,CAAA,CAAA;AACtF,MAAA,MAAM,QAAQ,OAAQ,CAAA,MAAA,CAAO,IAAK,CAAA,QAAA,CAAS,WAAW,CAAC,CAAA,CAAA;AAEvD,MAAA,QAAQ,KAAO;AAAA,QACb,KAAK,MAAA;AAGH,UAAA,OAAA,CAAQ,OAAO,OAAQ,CAAA,IAAA,GAAO,OAAQ,CAAA,IAAA,GAAO,OAAO,KAAQ,GAAA,KAAA,CAAA;AAC5D,UAAA,MAAA;AAAA,QACF,KAAK,OAAA;AACH,UAAA,OAAA,CAAQ,KAAQ,GAAA,KAAA,CAAA;AAChB,UAAA,MAAA;AAAA,QACF,KAAK,IAAA;AACH,UAAM,IAAA,CAAA,OAAA,CAAQ,KAAK,KAAM,CAAA,CAAA;AACzB,UAAA,MAAA;AAAA,QACF,KAAK,OAAA;AACH,UAAM,MAAA,KAAA,GAAQ,QAAS,CAAA,KAAA,EAAO,EAAE,CAAA,CAAA;AAChC,UAAI,IAAA,CAAC,KAAM,CAAA,KAAK,CAAG,EAAA;AAEjB,YAAS,OAAA,CAAA,OAAA,CAAQ,QAAQ,KAAM,CAAA,CAAA;AAAA,WACjC;AACA,UAAA,MAAA;AAAA,OACJ;AAAA,KACF;AAAA,GACF,CAAA;AACF,CAAA;AAEA,SAAS,MAAA,CAAO,GAAe,CAAe,EAAA;AAC5C,EAAA,MAAM,MAAM,IAAI,UAAA,CAAW,CAAE,CAAA,MAAA,GAAS,EAAE,MAAM,CAAA,CAAA;AAC9C,EAAA,GAAA,CAAI,IAAI,CAAC,CAAA,CAAA;AACT,EAAI,GAAA,CAAA,GAAA,CAAI,CAAG,EAAA,CAAA,CAAE,MAAM,CAAA,CAAA;AACnB,EAAO,OAAA,GAAA,CAAA;AACT,CAAA;AAEA,SAAS,UAAiC,GAAA;AAKxC,EAAO,OAAA;AAAA,IACL,IAAM,EAAA,EAAA;AAAA,IACN,KAAO,EAAA,EAAA;AAAA,IACP,EAAI,EAAA,EAAA;AAAA,IACJ,KAAO,EAAA,KAAA,CAAA;AAAA,GACT,CAAA;AACF,CAAA;AAEO,MAAM,sBAAyB,GAAA,mBAAA,CAAA;AAEtC,MAAM,WAAc,GAAA,eAAA,CAAA;AA2Cb,SAAS,iBACd,KACA,EAAA;AAAA,EACE,MAAQ,EAAA,WAAA;AAAA,EACR,OAAS,EAAA,YAAA;AAAA,EACT,MAAQ,EAAA,WAAA;AAAA,EACR,SAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA,KAAO,EAAA,UAAA;AAAA,EACP,GAAG,IAAA;AACL,CACA,EAAA;AACA,EAAA,OAAO,IAAI,OAAA,CAAc,CAAC,OAAA,EAAS,MAAW,KAAA;AAE5C,IAAM,MAAA,OAAA,GAAU,EAAE,GAAG,YAAa,EAAA,CAAA;AAClC,IAAI,IAAA,CAAC,QAAQ,MAAQ,EAAA;AACnB,MAAA,OAAA,CAAQ,MAAS,GAAA,sBAAA,CAAA;AAAA,KACnB;AAEA,IAAI,IAAA,oBAAA,CAAA;AAEJ,IAAA,SAAS,OAAU,GAAA;AACjB,MAAA,oBAAA,CAAqB,KAAM,EAAA,CAAA;AAAA,KAC7B;AAGA,IAAa,WAAA,EAAA,gBAAA,CAAiB,SAAS,MAAM;AAC3C,MAAQ,OAAA,EAAA,CAAA;AACR,MAAQ,OAAA,EAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAGD,IAAA,MAAM,YAAY,UAAc,IAAA,KAAA,CAAA;AAChC,IAAA,MAAM,SAAS,WAAe,IAAA,aAAA,CAAA;AAC9B,IAAA,eAAe,MAAS,GAAA;AACtB,MAAA,oBAAA,GAAuB,IAAI,eAAgB,EAAA,CAAA;AAC3C,MAAI,IAAA;AACF,QAAM,MAAA,QAAA,GAAgB,MAAM,SAAA,CAAU,KAAO,EAAA;AAAA,UAC3C,GAAG,IAAA;AAAA,UACH,OAAA;AAAA,UACA,QAAQ,oBAAqB,CAAA,MAAA;AAAA,SAC9B,CAAA,CAAA;AAED,QAAA,MAAM,OAAO,QAAQ,CAAA,CAAA;AAErB,QAAM,MAAA,QAAA;AAAA,UACJ,QAAS,CAAA,IAAA;AAAA,UACT,QAAA;AAAA,YACE,WAAA;AAAA,cACE,CAAC,EAAO,KAAA;AACN,gBAAA,IAAI,EAAI,EAAA;AAEN,kBAAA,OAAA,CAAQ,WAAW,CAAI,GAAA,EAAA,CAAA;AAAA,iBAClB,MAAA;AAEL,kBAAA,OAAO,QAAQ,WAAW,CAAA,CAAA;AAAA,iBAC5B;AAAA,eACF;AAAA,cACA,CAAC,MAAW,KAAA;AAAA,eAAC;AAAA,cACb,SAAA;AAAA,aACF;AAAA,WACF;AAAA,SACF,CAAA;AAEA,QAAU,OAAA,IAAA,CAAA;AACV,QAAQ,OAAA,EAAA,CAAA;AACR,QAAQ,OAAA,EAAA,CAAA;AAAA,eACD,GAAK,EAAA;AAAA,OAAC;AAAA,KACjB;AAEA,IAAO,MAAA,EAAA,CAAA;AAAA,GACR,CAAA,CAAA;AACH,CAAA;AAEA,SAAS,cAAc,QAAoB,EAAA;AACzC,EAAA,MAAM,WAAc,GAAA,QAAA,CAAS,OAAS,EAAA,GAAA,CAAI,cAAc,CAAA,CAAA;AACxD,EAAA,IAAI,CAAC,WAAA,EAAa,UAAW,CAAA,sBAAsB,CAAG,EAAA;AACpD,IAAA,MAAM,IAAI,KAAM,CAAA,CAAA,4BAAA,EAA+B,sBAAsB,CAAA,UAAA,EAAa,WAAW,CAAE,CAAA,CAAA,CAAA;AAAA,GACjG;AACF;;AC7TO,MAAM,OAAU,GAAA,QAAA;;ACIvB,MAAM,uBAAuB,KAAM,CAAA;AAAA,EAGjC,WAAA,CAAY,SAAkB,OAA6B,EAAA;AAEzD,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA,CAAA;AAAA,GACxB;AACF,CAAA;AAEO,MAAM,qBAAqB,cAAe,CAAA;AAAA,EAK/C,WAAA,CAAY,MAAgB,EAAA,IAAA,EAAgB,SAAoB,EAAA;AAC9D,IAAM,KAAA,CAAA,UAAA,CAAW,IAAI,CAAC,CAAA,CAAA;AAEtB,IAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AACd,IAAA,IAAA,CAAK,MAAS,GAAA,WAAA,CAAY,IAAI,CAAA,GAAI,IAAK,CAAA,MAAA,GAAS,CAAC,EAAE,OAAS,EAAA,UAAA,CAAW,IAAI,CAAA,EAAG,QAAQ,CAAA,CAAA;AACtF,IAAA,IAAA,CAAK,SAAY,GAAA,SAAA,CAAA;AAEjB,IAAA,IAAI,gBAAgB,KAAO,EAAA;AACzB,MAAA,IAAA,CAAK,QAAQ,IAAK,CAAA,KAAA,CAAA;AAClB,MAAA,IAAA,CAAK,QAAS,IAAwB,CAAA,KAAA,CAAA;AAAA,KACxC;AAAA,GACF;AAAA,EAEA,QAAW,GAAA;AACT,IAAM,MAAA,KAAA,GAAQ,MAAM,QAAS,EAAA,CAAA;AAE7B,IAAO,OAAA,CAAA,CAAA,EAAI,KAAK,MAAM,CAAA,GAAA,EAAM,KAAK,SAAa,IAAA,SAAS,MAAM,KAAK,CAAA,CAAA,CAAA;AAAA,GACpE;AACF,CAAA;AAQA,SAAS,YAAY,KAA0C,EAAA;AAC7D,EAAA,OAAO,SAAS,KAAK,CAAA,IAAK,KAAM,CAAA,OAAA,CAAQ,MAAM,MAAM,CAAA,CAAA;AACtD,CAAA;AAEA,SAAS,mBACP,KACkF,EAAA;AAClF,EAAA,OAAO,QAAS,CAAA,KAAK,CAAK,IAAA,QAAA,CAAS,MAAM,OAAO,CAAA,CAAA;AAClD,CAAA;AAEA,SAAS,WAAW,IAAwB,EAAA;AAC1C,EAAA,IAAI,gBAAgB,KAAO,EAAA;AACzB,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GACd,MAAA,IAAW,QAAS,CAAA,IAAI,CAAG,EAAA;AACzB,IAAO,OAAA,IAAA,CAAA;AAAA,GACT,MAAA,IAAW,kBAAmB,CAAA,IAAI,CAAG,EAAA;AACnC,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GACd,MAAA,IAAW,WAAY,CAAA,IAAI,CAAG,EAAA;AAC5B,IAAO,OAAA,uBAAA,CAAA;AAAA,GACF,MAAA;AACL,IAAO,OAAA,kBAAA,CAAA;AAAA,GACT;AACF;;AC1DA,MAAM,IAAA,GAAO,IAAI,cAAe,EAAA,CAAA;AAEhC,MAAM,UAAA,GAAa,CACjB,GACA,EAAA,WAAA,GAAmC,EACnC,EAAA,UAAA,GAAuD,EACpD,KAAA;AAEH,EAAM,MAAA,gBAAA,GAAmB,MAAO,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAE,MAAO,CAAA,CAAC,GAAK,EAAA,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AACjF,IAAI,IAAA,KAAA,KAAU,UAAa,KAAU,KAAA,IAAA;AAAM,MAAO,OAAA,GAAA,CAAA;AAClD,IAAA,OAAO,EAAE,GAAG,GAAA,EAAK,CAAC,GAAG,GAAG,KAAM,EAAA,CAAA;AAAA,GAChC,EAAG,EAAyB,CAAA,CAAA;AAE5B,EAAA,MAAM,KAAQ,GAAA,IAAI,eAAgB,CAAA,gBAAgB,EAAE,QAAS,EAAA,CAAA;AAC7D,EAAA,MAAM,cAAc,KAAM,CAAA,MAAA,GAAS,CAAI,GAAA,CAAA,CAAA,EAAI,KAAK,CAAK,CAAA,GAAA,EAAA,CAAA;AAIrD,EAAM,MAAA,eAAA,GAAkB,MAAO,CAAA,OAAA,CAAQ,UAAU,CAAA,CAAE,MAAO,CAAA,CAAC,GAAK,EAAA,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AAC/E,IAAA,OAAO,EAAE,GAAG,GAAK,EAAA,CAAC,GAAG,GAAG,kBAAA,CAAmB,MAAO,CAAA,KAAA,IAAS,EAAE,CAAC,CAAA,CAAE,OAAQ,CAAA,KAAA,EAAO,GAAG,CAAE,EAAA,CAAA;AAAA,GACtF,EAAG,EAA4B,CAAA,CAAA;AAE/B,EAAA,OAAO,GAAI,CAAA,OAAA,CAAQ,UAAY,EAAA,CAAC,GAAQ,KAAA,eAAA,CAAgB,GAAI,CAAA,KAAA,CAAM,CAAG,EAAA,CAAA,CAAE,CAAC,CAAC,CAAI,GAAA,WAAA,CAAA;AAC/E,CAAA,CAAA;AAgCA,SAAS,YAAa,CAAA;AAAA,EACpB,QAAA;AAAA,EACA,IAAA;AAAA,EACA,gBAAA;AAAA,EACA,MAAA;AAAA,EACA,aAAa,EAAC;AAChB,CAMW,EAAA;AACT,EAAA,IAAI,aAAa,WAAa,EAAA;AAC5B,IAAM,MAAA,GAAA,GAAM,QAAS,CAAA,gBAAgB,CAAI,GAAA,CAAA,EAAG,gBAAgB,CAAA,EAAG,IAAI,CAAA,CAAA,GAAK,gBAAiB,CAAA,IAAA,EAAM,UAAU,CAAA,CAAA;AAEzG,IAAA,MAAM,gBAAmB,GAAA,QAAA,CAAS,UAAW,CAAA,SAAS,CAClD,GAAA,GAAA,CAAI,OAAQ,CAAA,eAAA,EAAiB,MAAO,CAAA,UAAA,CAAW,SAAS,CAAC,CACzD,GAAA,GAAA,CAAA;AAEJ,IAAO,OAAA,QAAA,CAAS,UAAW,CAAA,MAAM,CAC7B,GAAA,gBAAA,CAAiB,OAAQ,CAAA,UAAA,EAAY,MAAO,CAAA,UAAA,CAAW,MAAM,CAAC,CAC9D,GAAA,gBAAA,CAAA;AAAA,GACN;AAEA,EAAO,OAAA,CAAA,EAAG,MAAM,CAAA,EAAG,IAAI,CAAA,CAAA,CAAA;AACzB,CAAA;AAIA,SAAS,WAAW,GAAgC,EAAA;AAClD,EAAA,MAAM,OAAU,GAAA,yBAAA,CAAA;AAChB,EAAA,MAAM,EAAE,MAAO,EAAA,GAAI,QAAQ,IAAK,CAAA,GAAG,KAAK,EAAC,CAAA;AAEzC,EAAA,OAAO,QAAQ,IAAO,GAAA,EAAE,MAAM,MAAO,CAAA,IAAA,KAAS,EAAC,CAAA;AACjD,CAAA;AAEA,eAAe,SAAA,CAAa,MAAU,OAAiD,EAAA;AACrF,EAAI,IAAA,CAAC,UAAU,IAAI,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA,CAAA;AAG7B,EAAA,IAAI,OAAO,IAAI,CAAA,IAAK,OAAQ,IAAA,CAAa,SAAS,UAAY,EAAA;AAC5D,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AAEA,EAAA,MAAM,EAAE,cAAA,EAAgB,WAAY,EAAA,GAAI,WAAW,EAAC,CAAA;AACpD,EAAI,IAAA,MAAA,CAAO,WAAW,CAAE,CAAA,WAAA,OAAkB,kBAAsB,IAAA,QAAA,CAAS,IAAI,CAAG,EAAA;AAC9E,IAAO,OAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,GAC5B;AAEA,EAAO,OAAA,IAAA,CAAA;AACT,CAAA;AAEA,MAAM,kBAAkB,YAAa,EAAA,CAAA;AAErC,eAAsBD,OAOpB,CAAA;AAAA,EACA,GAAK,EAAA,IAAA;AAAA,EACL,MAAA;AAAA,EACA,IAAA;AAAA,EACA,OAAS,EAAA,aAAA;AAAA,EACT,UAAA;AAAA,EACA,WAAA;AAAA,EACA,KAAAA,EAAAA,MAAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,gBAAA;AAAA,EACA,KAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA;AAAA,EACA,SAAA;AAAA,EACA,UAAA;AAAA,EACA,cAAA;AAAA,EACA,eAAe,EAAC;AAAA,EAChB,WAAc,GAAA,KAAA;AAChB,CAAmG,EAAA;AACjG,EAAA,IAAA,CAAK,SAASA,MAAK,CAAA,CAAA;AAEnB,EAAA,OAAO,MAAM,KAAA;AAAA,IACX,CAAG,EAAA,MAAA,CAAO,WAAY,EAAC,IAAI,IAAI,CAAA,CAAA;AAAA,IAC/B,OAAO,EAAE,aAAA,EAAoB,KAAA;AAC3B,MAAM,MAAA,OAAA,GAAU,aAAa,EAAE,QAAA,EAAU,MAAM,gBAAkB,EAAA,UAAA,EAAY,QAAQ,CAAA,CAAA;AACrF,MAAA,MAAM,OAAU,GAAA,UAAA,CAAW,OAAS,EAAA,WAAA,EAAa,UAAU,CAAA,CAAA;AAI3D,MAAM,MAAA,GAAA,GAAM,QAAQ,QAAS,CAAA,WAAW,IAAI,OAAQ,CAAA,OAAA,CAAQ,UAAY,EAAA,SAAS,CAAI,GAAA,OAAA,CAAA;AACrF,MAAc,aAAA,CAAA;AAAA,QACZ,CAAC,eAAgB,CAAA,QAAQ,GAAG,GAAA;AAAA,QAC5B,CAAC,eAAgB,CAAA,WAAW,GAAG,UAAW,CAAA,IAAA,EAAM,aAAa,UAAU,CAAA;AAAA,OACxE,CAAA,CAAA;AAED,MAAA,MAAM,YAAY,OAAQ,CAAA;AAAA,QACxB,CAAC,UAAU,QAAQ,CAAA;AAAA,QACnB,CAAC,WAAW,OAAO,CAAA;AAAA,QACnB,UAAU,UAAU,CAAA,GAAI,CAAC,SAAA,EAAW,UAAU,CAAI,GAAA,KAAA,CAAA;AAAA,QAClD,GAAG,MAAA,CAAO,OAAQ,CAAA,cAAA,IAAkB,EAAE,CAAA;AAAA,OACvC,CAAA,CACE,GAAI,CAAA,CAAC,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA,CAAA,EAAG,GAAG,CAAI,CAAA,EAAA,KAAK,CAAE,CAAA,CAAA,CACvC,KAAK,IAAI,CAAA,CAAA;AAEZ,MAAA,MAAM,UAAU,aAAc,CAAA;AAAA,QAC5B,iBAAmB,EAAA,UAAA;AAAA,QACnB,cAAgB,EAAA,kBAAA;AAAA,QAChB,oBAAoB,QAAY,IAAA,eAAA;AAAA,QAChC,mBAAA,EAAqB,aAAa,YAAa,EAAA;AAAA,QAC/C,cAAgB,EAAA,SAAA;AAAA,QAChB,GAAG,aAAA;AAAA,QACH,GAAG,WAAW,OAAO,CAAA;AAAA,QACrB,aAAA,EAAe,UAAU,MAAM,CAAA,CAAA;AAAA,OAChC,CAAA,CAAA;AAED,MAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,OAAA,CAAQ,GAAK,EAAA;AAAA,QACvC,GAAG,YAAA;AAAA,QACH,MAAA,EAAQ,OAAO,WAAY,EAAA;AAAA,QAC3B,IAAM,EAAA,MAAM,SAAU,CAAA,IAAA,EAAM,OAAO,CAAA;AAAA,QACnC,OAAA;AAAA,QACA,MAAA;AAAA,OACD,CAAA,CAAA;AAED,MAAA,MAAM,EAAE,IAAM,EAAA,QAAA,EAAa,GAAA,QAAA,CAAS,SAAS,GAAG,CAAA,CAAA;AAChD,MAAA,MAAM,SAAY,GAAA,QAAA,CAAS,OAAS,EAAA,GAAA,CAAI,cAAc,CAAK,IAAA,KAAA,CAAA,CAAA;AAC3D,MAAc,aAAA,CAAA;AAAA,QACZ,CAAC,eAAgB,CAAA,IAAI,GAAG,MAAA;AAAA,QACxB,CAAC,eAAgB,CAAA,eAAe,GAAG,SAAA;AAAA,QACnC,CAAC,eAAA,CAAgB,gBAAgB,GAAG,QAAS,CAAA,MAAA;AAAA,QAC7C,CAAC,eAAgB,CAAA,SAAS,GAAG,IAAA;AAAA,QAC7B,CAAC,eAAgB,CAAA,WAAW,GAAG,QAAU,EAAA,OAAA,CAAQ,KAAK,EAAE,CAAA;AAAA,QACxD,CAAC,gBAAgB,iBAAiB,GAAG,SAAS,OAAS,EAAA,GAAA,CAAI,QAAQ,CAAK,IAAA,KAAA,CAAA;AAAA,OACzE,CAAA,CAAA;AAED,MAAA,MAAM,OAAU,GAAA,QAAA,CAAS,OAAS,EAAA,GAAA,CAAI,gBAAgB,CAAA,CAAA;AACtD,MAAI,IAAA,OAAA;AAAS,QAAA,OAAA,CAAQ,KAAK,OAAO,CAAA,CAAA;AAGjC,MAAI,IAAA,QAAA,CAAS,WAAW,GAAK,EAAA;AAC3B,QAAA,OAAO,EAAC,CAAA;AAAA,OACV;AAGA,MAAI,IAAA,QAAA,CAAS,WAAW,GAAK,EAAA;AAC3B,QAAA,MAAM,IAAI,YAAA,CAAa,QAAS,CAAA,MAAA,EAAQ,uBAAuB,SAAS,CAAA,CAAA;AAAA,OAC1E;AAEA,MAAI,IAAA;AACF,QAAM,MAAA,YAAA,GAAe,cAAc,MAAM,QAAA,CAAS,MAAS,GAAA,MAAM,SAAS,IAAK,EAAA,CAAA;AAE/E,QAAA,IAAI,SAAS,EAAI,EAAA;AACf,UAAO,OAAA,YAAA,CAAA;AAAA,SACT;AAEA,QAAA,MAAM,IAAI,YAAA,CAAa,QAAS,CAAA,MAAA,EAAQ,cAAmC,SAAS,CAAA,CAAA;AAAA,eAC7E,KAAO,EAAA;AACd,QAAA,MAAM,IAAI,YAAA,CAAa,QAAS,CAAA,MAAA,EAAQ,OAAO,SAAS,CAAA,CAAA;AAAA,OAC1D;AAAA,KACF;AAAA,IACA,EAAE,CAAC,eAAgB,CAAA,WAAW,GAAG,MAAA,CAAO,WAAY,EAAA,EAAG,CAAC,eAAA,CAAgB,UAAU,GAAG,IAAK,EAAA;AAAA,GAC5F,CAAA;AACF,CAAA;AAEO,SAAS,eAOd,CAAA;AAAA,EACA,GAAK,EAAA,IAAA;AAAA,EACL,MAAA;AAAA,EACA,IAAA;AAAA,EACA,OAAS,EAAA,aAAA;AAAA,EACT,UAAA;AAAA,EACA,WAAA;AAAA,EACA,KAAAA,EAAAA,MAAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,gBAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA;AAAA,EACA,SAAA;AAAA,EACA,UAAA;AAAA,EACA,cAAA;AACF,CAKW,EAAA;AACT,EAAM,MAAA,OAAA,GAAU,aAAa,EAAE,QAAA,EAAU,MAAM,gBAAkB,EAAA,UAAA,EAAY,QAAQ,CAAA,CAAA;AACrF,EAAA,MAAM,OAAU,GAAA,UAAA,CAAW,OAAS,EAAA,WAAA,EAAa,UAAU,CAAA,CAAA;AAI3D,EAAM,MAAA,GAAA,GAAM,QAAQ,QAAS,CAAA,WAAW,IAAI,OAAQ,CAAA,OAAA,CAAQ,UAAY,EAAA,SAAS,CAAI,GAAA,OAAA,CAAA;AAErF,EAAA,KAAK,iBAAiB,GAAK,EAAA;AAAA,IACzB,MAAA;AAAA,IACA,IAAA,EAAM,IAAK,CAAA,SAAA,CAAU,IAAI,CAAA;AAAA,IACzB,KAAAA,EAAAA,MAAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAS,EAAA;AAAA,MACP,oBAAoB,QAAY,IAAA,eAAA;AAAA,MAChC,mBAAA,EAAqB,aAAa,YAAa,EAAA;AAAA,MAC/C,gBAAgB,OAAQ,CAAA;AAAA,QACtB,CAAC,UAAU,QAAQ,CAAA;AAAA,QACnB,CAAC,WAAW,OAAO,CAAA;AAAA,QACnB,UAAU,UAAU,CAAA,GAAI,CAAC,SAAA,EAAW,UAAU,CAAI,GAAA,KAAA,CAAA;AAAA,QAClD,GAAG,MAAA,CAAO,OAAQ,CAAA,cAAA,IAAkB,EAAE,CAAA;AAAA,OACvC,CAAA,CACE,GAAI,CAAA,CAAC,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA,CAAA,EAAG,GAAG,CAAI,CAAA,EAAA,KAAK,CAAE,CAAA,CAAA,CACvC,KAAK,IAAI,CAAA;AAAA,MACZ,GAAG,aAAA;AAAA,MACH,aAAA,EAAe,UAAU,MAAM,CAAA,CAAA;AAAA,MAC/B,cAAgB,EAAA,kBAAA;AAAA,KAClB;AAAA,IACA,UAAU,EAAI,EAAA;AACZ,MAAA,SAAA,GAAY,IAAK,CAAA,KAAA,CAAM,EAAG,CAAA,IAAI,CAAC,CAAA,CAAA;AAAA,KACjC;AAAA,IACA,QAAQ,EAAI,EAAA;AACV,MAAA,OAAA,GAAU,IAAK,CAAA,KAAA,CAAM,EAAG,CAAA,IAAI,CAAC,CAAA,CAAA;AAAA,KAC/B;AAAA,IACA,OAAU,GAAA;AACR,MAAU,OAAA,IAAA,CAAA;AAAA,KACZ;AAAA,GACD,CAAA,CAAA;AACH,CAAA;AAEA,SAAS,SAAS,GAAmD,EAAA;AACnE,EAAI,IAAA;AACF,IAAA,MAAM,EAAE,IAAM,EAAA,QAAA,EAAa,GAAA,IAAI,IAAI,GAAG,CAAA,CAAA;AAEtC,IAAO,OAAA,EAAE,MAAM,QAAS,EAAA,CAAA;AAAA,WACjB,KAAO,EAAA;AACd,IAAA,OAAO,EAAC,CAAA;AAAA,GACV;AACF;;ACtRa,MAAA,cAAA,GAAiB,OAQ5B,OAEA,KAAAA,OAAA,CAAiE,EAAE,GAAG,OAAA,EAAS,QAAU,EAAA,WAAA,EAAa,CAAA;;ACDjG,MAAM,aAAgB,GAAA,CAAC,SAAmC,EAAA,MAAA,KAC/D,cAA6G,CAAA;AAAA,EAC3G,GAAK,EAAA,eAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA8BI,MAAM,gBAAmB,GAAA,CAAC,SAAsC,EAAA,MAAA,KACrE,cAAuG,CAAA;AAAA,EACrG,GAAK,EAAA,oBAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA4DI,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAOE,CAAA,EAAE,GAAK,EAAA,oBAAA,EAAsB,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAyC/D,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAAmG,CAAA;AAAA,EACjG,GAAK,EAAA,oBAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkCI,MAAM,SAAY,GAAA,CAAC,SAA+B,EAAA,MAAA,KACvD,cAA0F,CAAA;AAAA,EACxF,GAAK,EAAA,2BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAuCI,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,cAA+G,CAAA;AAAA,EAC7G,GAAK,EAAA,yBAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkCI,MAAM,oBAAuB,GAAA,CAAC,SAA0C,EAAA,MAAA,KAC7E,cAAqH,CAAA;AAAA,EACnH,GAAK,EAAA,6BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA8BI,MAAM,iBAAoB,GAAA,CAAC,SAAuC,EAAA,MAAA,KACvE,cAA+G,CAAA;AAAA,EAC7G,GAAK,EAAA,6BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA6CI,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAAyG,CAAA;AAAA,EACvG,GAAK,EAAA,0BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkDI,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,cAOE,CAAA,EAAE,GAAK,EAAA,2BAAA,EAA6B,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AA4DtE,MAAM,mBAAsB,GAAA,CAAC,SAAyC,EAAA,MAAA,KAC3E,cAOE,CAAA,EAAE,GAAK,EAAA,2BAAA,EAA6B,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA2CvE,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,2BAAA,EAA6B,MAAQ,EAAA,QAAA,EAAU,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuEzE,MAAM,aAAgB,GAAA,CAAC,SAAmC,EAAA,MAAA,KAC/D,cAOE,CAAA,EAAE,GAAK,EAAA,6BAAA,EAA+B,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAyCxE,MAAM,yBAA4B,GAAA,CAAC,SAA+C,EAAA,MAAA,KACvF,cAOE,CAAA,EAAE,GAAK,EAAA,+BAAA,EAAiC,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkC1E,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,oCAAA,EAAsC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuChF,MAAM,0BAA6B,GAAA,CAAC,SAAgD,EAAA,MAAA,KACzF,cAOE,CAAA,EAAE,GAAK,EAAA,uCAAA,EAAyC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA2CnF,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,gCAAA,EAAkC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAsD5E,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,0BAAA,EAA4B,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkCtE,MAAM,mBAAsB,GAAA,CAAC,SAAyC,EAAA,MAAA,KAC3E,cAAqH,CAAA;AAAA,EACnH,GAAK,EAAA,qCAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkDI,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,qCAAA,EAAuC,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AAoElF,MAAM,4BAA+B,GAAA,CAAC,SAAkD,EAAA,MAAA,KAC7F,cAOE,CAAA,EAAE,GAAK,EAAA,6CAAA,EAA+C,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkCzF,MAAM,uBAA0B,GAAA,CAAC,SAA6C,EAAA,MAAA,KACnF,cAOE,CAAA,EAAE,GAAK,EAAA,6CAAA,EAA+C,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAsCzF,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,cAOE,CAAA,EAAE,GAAK,EAAA,2CAAA,EAA6C,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkCtF,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,cAAiH,CAAA;AAAA,EAC/G,GAAK,EAAA,2CAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAoEI,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,mCAAA,EAAqC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAqC/E,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,cAOE,CAAA,EAAE,GAAK,EAAA,mCAAA,EAAqC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAwC/E,MAAM,oBAAuB,GAAA,CAAC,SAA0C,EAAA,MAAA,KAC7E,cAOE,CAAA,EAAE,GAAK,EAAA,gDAAA,EAAkD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA+B5F,MAAM,kBAAqB,GAAA,CAAC,SAAwC,EAAA,MAAA,KACzE,cAOE,CAAA,EAAE,GAAK,EAAA,kCAAA,EAAoC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAwC9E,MAAM,uBAA0B,GAAA,CAAC,SAA6C,EAAA,MAAA,KACnF,cAOE,CAAA,EAAE,GAAK,EAAA,mCAAA,EAAqC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAmC/E,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,cAOE,CAAA,EAAE,GAAK,EAAA,iCAAA,EAAmC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA+C7E,MAAM,oBAAuB,GAAA,CAAC,SAA0C,EAAA,MAAA,KAC7E,cAOE,CAAA,EAAE,GAAK,EAAA,gCAAA,EAAkC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkD5E,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAAgG,CAAA;AAAA,EAC9F,GAAK,EAAA,uCAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAqCI,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAAgG,CAAA;AAAA,EAC9F,GAAK,EAAA,uCAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA2DI,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAOE,CAAA,EAAE,GAAK,EAAA,uCAAA,EAAyC,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AAsCpF,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAAyG,CAAA;AAAA,EACvG,GAAK,EAAA,8CAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA2CI,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAOE,CAAA,EAAE,GAAK,EAAA,8CAAA,EAAgD,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AA0CzF,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,cAA4G,CAAA;AAAA,EAC1G,GAAK,EAAA,+CAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAsCU,MAAA,cAAA,GAAiB,CAAC,SAAA,EAAoC,MACjE,KAAA,cAAA;AAAA,EACE,EAAE,GAAK,EAAA,+CAAA,EAAiD,QAAQ,MAAQ,EAAA,GAAG,WAAW,MAAO,EAAA;AAC/F,EAAA;AAyCK,MAAM,SAAY,GAAA,CAAC,SAA+B,EAAA,MAAA,KACvD,cAAuF,CAAA;AAAA,EACrF,GAAK,EAAA,4DAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAiDI,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAOE,CAAA,EAAE,GAAK,EAAA,4DAAA,EAA8D,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AAyCzG,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAA6G,CAAA;AAAA,EAC3G,GAAK,EAAA,4DAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAuCI,MAAM,iBAAoB,GAAA,CAAC,SAAuC,EAAA,MAAA,KACvE,cAOE,CAAA,EAAE,GAAK,EAAA,gCAAA,EAAkC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA8C5E,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAOE,CAAA,EAAE,GAAK,EAAA,4CAAA,EAA8C,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAiDxF,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAAiF,CAAA;AAAA,EAC/E,GAAK,EAAA,yFAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAsDI,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAAiG,CAAA;AAAA,EAC/F,GAAK,EAAA,yFAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAiDI,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAA4G,CAAA;AAAA,EAC1G,GAAK,EAAA,yFAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA6CI,MAAM,OAAU,GAAA,CAAC,SAA6B,EAAA,MAAA,KACnD,cAAyE,CAAA;AAAA,EACvE,GAAK,EAAA,gFAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkDI,MAAM,OAAU,GAAA,CAAC,SAA6B,EAAA,MAAA,KACnD,cAAyF,CAAA;AAAA,EACvF,GAAK,EAAA,gFAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA6CI,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,cAAoG,CAAA;AAAA,EAClG,GAAK,EAAA,gFAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAiDI,MAAM,SAAY,GAAA,CAAC,SAA+B,EAAA,MAAA,KACvD,cAAmH,CAAA;AAAA,EACjH,GAAK,EAAA,uDAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAwDI,MAAM,kBAAqB,GAAA,CAAC,SAAwC,EAAA,MAAA,KACzE,cAOE,CAAA,EAAE,GAAK,EAAA,uDAAA,EAAyD,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAoDlG,MAAM,kBAAqB,GAAA,CAAC,SAAwC,EAAA,MAAA,KACzE,cAOE,CAAA,EAAE,GAAK,EAAA,uDAAA,EAAyD,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AAoDpG,MAAM,kBAAqB,GAAA,CAAC,SAAwC,EAAA,MAAA,KACzE,cAOE,CAAA,EAAE,GAAK,EAAA,uDAAA,EAAyD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA8CnG,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAOE,CAAA,EAAE,GAAK,EAAA,uDAAA,EAAyD,MAAQ,EAAA,QAAA,EAAU,GAAG,SAAA,EAAW,QAAQ,EAAA;AAsDrG,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,cAOE,CAAA,EAAE,GAAK,EAAA,4CAAA,EAA8C,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAm1BxF,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,cAA8G,CAAA;AAAA,EAC5G,GAAK,EAAA,6CAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAkEI,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,cAAqH,CAAA;AAAA,EACnH,GAAK,EAAA,2BAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA0DI,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,cAAkH,CAAA;AAAA,EAChH,GAAK,EAAA,8CAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAqEI,MAAM,iBAAoB,GAAA,CAAC,SAAuC,EAAA,MAAA,KACvE,cAOE,CAAA,EAAE,GAAK,EAAA,oDAAA,EAAsD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAmGhG,MAAM,QAAW,GAAA,CAAC,SAA8B,EAAA,MAAA,KACrD,cAAiG,CAAA;AAAA,EAC/F,GAAK,EAAA,2CAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAmEI,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,cAOE,CAAA,EAAE,GAAK,EAAA,uDAAA,EAAyD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA4HnG,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAOE,CAAA,EAAE,GAAK,EAAA,iDAAA,EAAmD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAkD7F,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,cAOE,CAAA,EAAE,GAAK,EAAA,iDAAA,EAAmD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAyC7F,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,cAAkG,CAAA;AAAA,EAChG,GAAK,EAAA,gBAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAyDI,MAAM,QAAW,GAAA,CAAC,SAA8B,EAAA,MAAA,KACrD,cAAsG,CAAA;AAAA,EACpG,GAAK,EAAA,wBAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAEI,MAAMG,iBAAkB,GAAA;AAAA,EAC7B,MAAQ,EAAA;AAAA,IACN,aAAA;AAAA,IACA,gBAAA;AAAA,IACA,YAAA;AAAA,IACA,YAAA;AAAA,IACA,UAAA;AAAA,IACA,oBAAA;AAAA,IACA,iBAAA;AAAA,IACA,cAAA;AAAA,IACA,qBAAA;AAAA,IACA,mBAAA;AAAA,IACA,sBAAA;AAAA,IACA,aAAA;AAAA,GACF;AAAA,EACA,UAAY,EAAA;AAAA,IACV,SAAA;AAAA,IACA,yBAAA;AAAA,IACA,sBAAA;AAAA,IACA,0BAAA;AAAA,IACA,sBAAA;AAAA,IACA,2BAAA;AAAA,IACA,oBAAA;AAAA,IACA,kBAAA;AAAA,IACA,uBAAA;AAAA,IACA,qBAAA;AAAA,IACA,oBAAA;AAAA,GACF;AAAA,EACA,iBAAmB,EAAA;AAAA,IACjB,sBAAA;AAAA,IACA,sBAAA;AAAA,IACA,mBAAA;AAAA,IACA,sBAAA;AAAA,IACA,4BAAA;AAAA,IACA,uBAAA;AAAA,IACA,2BAAA;AAAA,IACA,qBAAA;AAAA,GACF;AAAA,EACA,KAAO,EAAA;AAAA,IACL,WAAA;AAAA,IACA,WAAA;AAAA,IACA,WAAA;AAAA,IACA,cAAA;AAAA,IACA,cAAA;AAAA,IACA,eAAA;AAAA,IACA,cAAA;AAAA,IACA,SAAA;AAAA,IACA,YAAA;AAAA,IACA,YAAA;AAAA,GACF;AAAA,EACA,OAAS,EAAA;AAAA,IACP,iBAAA;AAAA,IACA,YAAA;AAAA,IACA,SAAA;AAAA,IACA,kBAAA;AAAA,IACA,kBAAA;AAAA,IACA,kBAAA;AAAA,IACA,YAAA;AAAA,IACA,sBAAA;AAAA,GACF;AAAA,EACA,KAAA,EAAO,EAAE,WAAa,EAAA,WAAA,EAAa,gBAAgB,OAAS,EAAA,OAAA,EAAS,YAAY,UAAW,EAAA;AAAA,EAC5F,eAAiB,EAAA;AAAA,IACf,UAAA;AAAA,IACA,YAAA;AAAA,IACA,WAAA;AAAA,IACA,iBAAA;AAAA,IACA,QAAA;AAAA,IACA,eAAA;AAAA,IACA,cAAA;AAAA,IACA,cAAA;AAAA,GACF;AAAA,EACA,GAAA,EAAK,EAAE,QAAS,EAAA;AAClB,CAAA;;ACp2Ia,MAAA,iBAAA,GAAoB,OAQ/B,OAEA,KAAAH,OAAA,CAAiE,EAAE,GAAG,OAAA,EAAS,QAAU,EAAA,cAAA,EAAgB,CAAA;;ACIpG,MAAM,oBAAuB,GAAA,CAAC,SAA0C,EAAA,MAAA,KAC7E,iBAOE,CAAA,EAAE,GAAK,EAAA,kBAAA,EAAoB,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AA4B7D,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,iBAOE,CAAA,EAAE,GAAK,EAAA,kBAAA,EAAoB,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAsB9D,MAAM,OAAU,GAAA,CAAC,SAA6B,EAAA,MAAA,KACnD,iBAA2E,CAAA;AAAA,EACzE,GAAK,EAAA,OAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAwBI,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,iBAAiF,CAAA;AAAA,EAC/E,GAAK,EAAA,OAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAsBI,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,iBAAqE,CAAA;AAAA,EACnE,GAAK,EAAA,OAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA6BI,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,iBAAsF,CAAA;AAAA,EACpF,GAAK,EAAA,YAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAqCI,MAAM,gBAAmB,GAAA,CAAC,SAAsC,EAAA,MAAA,KACrE,iBAAkH,CAAA;AAAA,EAChH,GAAK,EAAA,sBAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA+BI,MAAM,gBAAmB,GAAA,CAAC,SAAsC,EAAA,MAAA,KACrE,iBAAmG,CAAA;AAAA,EACjG,GAAK,EAAA,sBAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA0BI,MAAM,mBAAsB,GAAA,CAAC,SAAyC,EAAA,MAAA,KAC3E,iBAAgG,CAAA;AAAA,EAC9F,GAAK,EAAA,qBAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA4BI,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,iBAA6G,CAAA;AAAA,EAC3G,GAAK,EAAA,gCAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AA0BI,MAAM,wBAA2B,GAAA,CAAC,SAA8C,EAAA,MAAA,KACrF,iBAA0G,CAAA;AAAA,EACxG,GAAK,EAAA,oBAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAgCI,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,iBAA+G,CAAA;AAAA,EAC7G,GAAK,EAAA,4BAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAwCI,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,iBAOE,CAAA,EAAE,GAAK,EAAA,4BAAA,EAA8B,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AA+BzE,MAAM,iBAAoB,GAAA,CAAC,SAAuC,EAAA,MAAA,KACvE,iBAA4F,CAAA;AAAA,EAC1F,GAAK,EAAA,aAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAwBI,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,iBAA8F,CAAA;AAAA,EAC5F,GAAK,EAAA,aAAA;AAAA,EACL,MAAQ,EAAA,MAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAmCI,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,iBAAmG,CAAA;AAAA,EACjG,GAAK,EAAA,2BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAoCI,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,iBAAqH,CAAA;AAAA,EACnH,GAAK,EAAA,2BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAmCI,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,iBAAiG,CAAA;AAAA,EAC/F,GAAK,EAAA,2BAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAmCI,MAAM,uBAA0B,GAAA,CAAC,SAA6C,EAAA,MAAA,KACnF,iBAOE,CAAA,EAAE,GAAK,EAAA,mCAAA,EAAqC,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AA4C9E,MAAM,yBAA4B,GAAA,CAAC,SAA+C,EAAA,MAAA,KACvF,iBAOE,CAAA,EAAE,GAAK,EAAA,4CAAA,EAA8C,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuCvF,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,iBAA6G,CAAA;AAAA,EAC3G,GAAK,EAAA,4CAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAgDI,MAAM,qBAAwB,GAAA,CAAC,SAA2C,EAAA,MAAA,KAC/E,iBAOE,CAAA,EAAE,GAAK,EAAA,mCAAA,EAAqC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAgD/E,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,iBAOE,CAAA,EAAE,GAAK,EAAA,8CAAA,EAAgD,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuC3F,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,iBAOE,CAAA,EAAE,GAAK,EAAA,8CAAA,EAAgD,MAAQ,EAAA,QAAA,EAAU,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuC5F,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,iBAOE,CAAA,EAAE,GAAK,EAAA,sDAAA,EAAwD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuClG,MAAM,2BAA8B,GAAA,CAAC,SAAiD,EAAA,MAAA,KAC3F,iBAOE,CAAA,EAAE,GAAK,EAAA,qDAAA,EAAuD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA2BjG,MAAM,YAAe,GAAA,CAAC,SAAkC,EAAA,MAAA,KAC7D,iBAA8G,CAAA;AAAA,EAC5G,GAAK,EAAA,oCAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAiCI,MAAM,aAAgB,GAAA,CAAC,SAAmC,EAAA,MAAA,KAC/D,iBAOE,CAAA,EAAE,GAAK,EAAA,oCAAA,EAAsC,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AA+BhF,MAAM,UAAa,GAAA,CAAC,SAAgC,EAAA,MAAA,KACzD,iBAAqG,CAAA;AAAA,EACnG,GAAK,EAAA,gDAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAgCI,MAAM,aAAgB,GAAA,CAAC,SAAmC,EAAA,MAAA,KAC/D,iBAOE,CAAA,EAAE,GAAK,EAAA,gDAAA,EAAkD,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AA2B7F,MAAM,eAAkB,GAAA,CAAC,SAAqC,EAAA,MAAA,KACnE,iBAAqH,CAAA;AAAA,EACnH,GAAK,EAAA,+BAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAgEI,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,iBAOE,CAAA,EAAE,GAAK,EAAA,wCAAA,EAA0C,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAuCnF,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,iBAA4G,CAAA;AAAA,EAC1G,GAAK,EAAA,wCAAA;AAAA,EACL,MAAQ,EAAA,QAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAmCI,MAAM,mBAAsB,GAAA,CAAC,SAAyC,EAAA,MAAA,KAC3E,iBAOE,CAAA,EAAE,GAAK,EAAA,wCAAA,EAA0C,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AA6CnF,MAAM,sBAAyB,GAAA,CAAC,SAA4C,EAAA,MAAA,KACjF,iBAOE,CAAA,EAAE,GAAK,EAAA,wCAAA,EAA0C,MAAQ,EAAA,OAAA,EAAS,GAAG,SAAA,EAAW,QAAQ,EAAA;AA+CrF,MAAM,cAAiB,GAAA,CAAC,SAAoC,EAAA,MAAA,KACjE,iBAOE,CAAA,EAAE,GAAK,EAAA,+CAAA,EAAiD,MAAQ,EAAA,MAAA,EAAQ,GAAG,SAAA,EAAW,QAAQ,EAAA;AAmC3F,MAAM,yBAA4B,GAAA,CAAC,SAA+C,EAAA,MAAA,KACvF,iBAOE,CAAA,EAAE,GAAK,EAAA,+CAAA,EAAiD,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAwC1F,MAAM,4BAA+B,GAAA,CAAC,SAAkD,EAAA,MAAA,KAC7F,iBAOE,CAAA,EAAE,GAAK,EAAA,+CAAA,EAAiD,MAAQ,EAAA,KAAA,EAAO,GAAG,SAAA,EAAW,QAAQ,EAAA;AAmC1F,MAAM,4BAA+B,GAAA,CAAC,SAAkD,EAAA,MAAA,KAC7F,iBAOE,CAAA,EAAE,GAAK,EAAA,+CAAA,EAAiD,MAAQ,EAAA,QAAA,EAAU,GAAG,SAAA,EAAW,QAAQ,EAAA;AA2B7F,MAAM,WAAc,GAAA,CAAC,SAAiC,EAAA,MAAA,KAC3D,iBAA2G,CAAA;AAAA,EACzG,GAAK,EAAA,mCAAA;AAAA,EACL,MAAQ,EAAA,KAAA;AAAA,EACR,GAAG,SAAA;AAAA,EACH,MAAA;AACF,CAAC,EAAA;AAEI,MAAMG,iBAAkB,GAAA;AAAA,EAC7B,KAAO,EAAA;AAAA,IACL,oBAAA;AAAA,IACA,sBAAA;AAAA,IACA,mBAAA;AAAA,IACA,qBAAA;AAAA,IACA,wBAAA;AAAA,IACA,sBAAA;AAAA,IACA,sBAAA;AAAA,GACF;AAAA,EACA,KAAO,EAAA,EAAE,OAAS,EAAA,UAAA,EAAY,UAAW,EAAA;AAAA,EACzC,cAAgB,EAAA,EAAE,cAAgB,EAAA,gBAAA,EAAkB,gBAAiB,EAAA;AAAA,EACrE,UAAY,EAAA;AAAA,IACV,iBAAA;AAAA,IACA,eAAA;AAAA,IACA,YAAA;AAAA,IACA,eAAA;AAAA,IACA,eAAA;AAAA,IACA,uBAAA;AAAA,IACA,yBAAA;AAAA,IACA,qBAAA;AAAA,GACF;AAAA,EACA,OAAS,EAAA;AAAA,IACP,qBAAA;AAAA,IACA,2BAAA;AAAA,IACA,2BAAA;AAAA,IACA,2BAAA;AAAA,IACA,2BAAA;AAAA,GACF;AAAA,EACA,cAAgB,EAAA,EAAE,YAAc,EAAA,aAAA,EAAe,YAAY,aAAc,EAAA;AAAA,EACzE,SAAW,EAAA;AAAA,IACT,eAAA;AAAA,IACA,cAAA;AAAA,IACA,cAAA;AAAA,IACA,mBAAA;AAAA,IACA,sBAAA;AAAA,IACA,cAAA;AAAA,IACA,yBAAA;AAAA,IACA,4BAAA;AAAA,IACA,4BAAA;AAAA,IACA,WAAA;AAAA,GACF;AACF,CAAA;;AChrDa,MAAA,eAAA,GAAkB,SAAU,CAAAC,iBAAA,EAAqBC,iBAAsB;;ACFpE,SAAA,UAAA,CAAW,UAAwB,IAAqC,EAAA;AACtF,EAAI,IAAA,mBAAA,CAAoB,QAAQ,CAAG,EAAA;AACjC,IAAO,OAAA,SAAA,CAAU,QAAQ,CAAA,CAAE,IAAI,CAAA,CAAA;AAAA,GACjC,MAAA,IAAW,qBAAsB,CAAA,QAAQ,CAAG,EAAA;AAC1C,IAAA,OAAO,SAAS,IAAI,CAAA,CAAA;AAAA,GACtB;AAEA,EAAM,MAAA,IAAI,MAAM,sBAAsB,CAAA,CAAA;AACxC,CAAA;AAEA,MAAM,SAAkD,GAAA;AAAA,EACtD,UAAY,EAAA;AAAA,IACV,IAAM,EAAA,qBAAA;AAAA,IACN,UAAY,EAAA,wCAAA;AAAA,GACd;AAAA,EACA,OAAS,EAAA;AAAA,IACP,IAAM,EAAA,8BAAA;AAAA,IACN,UAAY,EAAA,iDAAA;AAAA,GACd;AAAA,EACA,GAAK,EAAA;AAAA,IACH,IAAM,EAAA,0BAAA;AAAA,IACN,UAAY,EAAA,6CAAA;AAAA,GACd;AACF,CAAA,CAAA;AAEO,SAAS,oBAAoB,KAAoD,EAAA;AACtF,EAAO,OAAA,QAAA,CAAS,KAAK,CAAK,IAAA,MAAA,CAAO,KAAK,SAAS,CAAA,CAAE,SAAS,KAAK,CAAA,CAAA;AACjE,CAAA;AAEO,SAAS,sBAAsB,OAAmD,EAAA;AACvF,EAAO,OAAA,QAAA,CAAS,OAAO,CAAK,IAAA,QAAA,CAAS,QAAQ,IAAI,CAAA,IAAK,QAAS,CAAA,OAAA,CAAQ,UAAU,CAAA,CAAA;AACnF,CAAA;AAEgB,SAAA,mBAAA,CAAoB,WAAW,YAAmC,EAAA;AAChF,EAAI,IAAA,mBAAA,CAAoB,QAAQ,CAAG,EAAA;AACjC,IAAO,OAAA,QAAA,CAAA;AAAA,GACT;AAEA,EAAA,MAAM,CAAC,IAAM,EAAA,UAAU,CAAI,GAAA,QAAA,CAAS,MAAM,GAAG,CAAA,CAAA;AAC7C,EAAI,IAAA,CAAC,QAAQ,CAAC,UAAA;AAAY,IAAO,OAAA,IAAA,CAAA;AACjC,EAAO,OAAA,EAAE,MAAM,UAAW,EAAA,CAAA;AAC5B,CAAA;AAEO,SAAS,oBAAoB,QAAgC,EAAA;AAClE,EAAA,IAAI,oBAAoB,QAAQ,CAAA;AAAG,IAAO,OAAA,QAAA,CAAA;AAC1C,EAAA,OAAO,CAAG,EAAA,QAAA,CAAS,IAAI,CAAA,CAAA,EAAI,SAAS,UAAU,CAAA,CAAA,CAAA;AAChD,CAAA;AAEO,SAAS,wBAAwB,GAA2D,EAAA;AACjG,EAAI,IAAA,CAAC,SAAS,GAAG,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAE3B,EAAA,MAAM,KAAQ,GAAA,iDAAA,CAAA;AACd,EAAA,MAAM,QAAW,GAAA,sDAAA,CAAA;AACjB,EAAA,MAAM,YAAe,GAAA,0DAAA,CAAA;AACrB,EAAA,MAAM,gBAAmB,GAAA,mDAAA,CAAA;AAEzB,EAAA,MAAM,KAAQ,GAAA,GAAA,CAAI,KAAM,CAAA,KAAK,KAAK,GAAI,CAAA,KAAA,CAAM,QAAQ,CAAA,IAAK,IAAI,KAAM,CAAA,YAAY,CAAK,IAAA,GAAA,CAAI,MAAM,gBAAgB,CAAA,CAAA;AAC9G,EAAA,IAAI,CAAC,KAAA;AAAO,IAAO,OAAA,IAAA,CAAA;AAEnB,EAAO,OAAA,EAAE,WAAW,KAAM,CAAA,CAAC,GAAG,MAAQ,EAAA,KAAA,CAAM,CAAC,CAAE,EAAA,CAAA;AACjD;;;;;;;;;;;;;;;;;;;;AClEA,IAAA,WAAA,EAAA,WAAA,CAAA;AAuBO,MAAM,aAAc,CAAA;AAAA,EAiBzB,WAAA,CAAY,OAAgC,GAAA,EAAI,EAAA;AAhBhD,IAAAP,cAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,WAAA,EAaK,EAAC,CAAA,CAAA;AAGJ,IAAM,MAAA,QAAA,GAAW,QAAQ,IAAQ,IAAA,YAAA,CAAA;AACjC,IAAM,MAAA,MAAA,GAAS,OAAQ,CAAA,MAAA,IAAU,SAAU,EAAA,CAAA;AAC3C,IAAM,MAAA,KAAA,GAAQ,QAAQ,KAAS,IAAA,YAAA,CAAA;AAC/B,IAAA,MAAM,WAAW,YAAa,EAAA,CAAA;AAE9B,IAAA,IAAI,CAAC,MAAQ,EAAA;AACX,MAAM,MAAA,IAAI,MAAM,kCAAkC,CAAA,CAAA;AAAA,KACpD;AAEA,IAAAC,cAAA,CAAA,IAAA,EAAK,WAAc,EAAA;AAAA,MACjB,MAAA,EAAQ,UAAW,CAAA,QAAA,EAAU,MAAM,CAAA;AAAA,MACnC,gBAAA,EAAkB,UAAW,CAAA,QAAA,EAAU,YAAY,CAAA;AAAA,MACnD,KAAA,EAAO,sBAAuB,CAAA,OAAA,CAAQ,KAAK,CAAA;AAAA,MAC3C,MAAA;AAAA,MACA,KAAA;AAAA,MACA,YAAY,OAAQ,CAAA,UAAA;AAAA,MACpB,gBAAgB,OAAQ,CAAA,cAAA;AAAA,MACxB,QAAA;AAAA,KACF,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,IAAW,IAAO,GAAA;AAChB,IAAI,IAAA,CAACE,qBAAK,WAAY,CAAA,CAAA,IAAA;AAAM,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,IAAA,GAAO,IAAI,OAAA,CAAQA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAChF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,IAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,cAAiB,GAAA;AAC1B,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,cAAA;AAAgB,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,cAAA,GAAiB,IAAI,iBAAA,CAAkBA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAC9G,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,cAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,UAAa,GAAA;AACtB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,UAAA;AAAY,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,UAAA,GAAa,IAAI,YAAA,CAAaA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACjG,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,UAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,OAAU,GAAA;AACnB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,OAAA;AAAS,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,OAAA,GAAU,IAAI,UAAA,CAAWA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACzF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,OAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,QAAW,GAAA;AACpB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,QAAA;AAAU,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,QAAA,GAAW,IAAI,WAAA,CAAYA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAC5F,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,QAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,QAAW,GAAA;AACpB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,QAAA;AAAU,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,QAAA,GAAW,IAAI,SAAA,CAAUA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAC1F,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,QAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,UAAa,GAAA;AACtB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,UAAA;AAAY,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,UAAA,GAAa,IAAI,aAAA,CAAcA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAClG,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,UAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,iBAAoB,GAAA;AAC7B,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,iBAAA;AACpB,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,iBAAA,GAAoB,IAAI,oBAAA,CAAqBA,qBAAK,WAAW,CAAA,CAAA,CAAA;AAChF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,iBAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,MAAS,GAAA;AAClB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,MAAA;AAAQ,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,MAAA,GAAS,IAAI,QAAA,CAASA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACrF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,MAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,OAAU,GAAA;AACnB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,OAAA;AAAS,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,OAAA,GAAU,IAAI,UAAA,CAAWA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACzF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,OAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,KAAQ,GAAA;AACjB,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,KAAA;AAAO,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,KAAA,GAAQ,IAAI,QAAA,CAASA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACnF,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,KAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAW,eAAkB,GAAA;AAC3B,IAAI,IAAA,CAACA,qBAAK,WAAY,CAAA,CAAA,eAAA;AAAiB,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,eAAA,GAAkB,IAAI,kBAAA,CAAmBA,qBAAK,WAAW,CAAA,CAAA,CAAA;AACjH,IAAA,OAAOA,qBAAK,WAAY,CAAA,CAAA,eAAA,CAAA;AAAA,GAC1B;AACF,CAAA;AAlGE,WAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,WAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAmGF,MAAM,OAAQ,CAAA;AAAA,EACZ,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,OAAuC,GAAA;AAC5C,IAAA,OAAO,gBAAgB,KAAM,CAAA,OAAA,CAAQ,EAAE,GAAG,IAAA,CAAK,YAAY,CAAA,CAAA;AAAA,GAC7D;AAAA,EAEO,UAAA,CAAW,EAAE,IAAA,EAA6D,EAAA;AAC/E,IAAO,OAAA,eAAA,CAAgB,MAAM,UAAW,CAAA,EAAE,MAAM,IAAM,EAAA,GAAG,IAAK,CAAA,UAAA,EAAY,CAAA,CAAA;AAAA,GAC5E;AAAA,EAEO,UAA4B,GAAA;AACjC,IAAA,OAAO,gBAAgB,KAAM,CAAA,UAAA,CAAW,EAAE,GAAG,IAAA,CAAK,YAAY,CAAA,CAAA;AAAA,GAChE;AACF,CAAA;AAEA,MAAM,iBAAkB,CAAA;AAAA,EACtB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,cAAwD,GAAA;AAC7D,IAAA,OAAO,gBAAgB,cAAe,CAAA,cAAA,CAAe,EAAE,GAAG,IAAA,CAAK,YAAY,CAAA,CAAA;AAAA,GAC7E;AAAA,EAEO,gBAAA,CAAiB,EAAE,IAAA,EAA+E,EAAA;AACvG,IAAO,OAAA,eAAA,CAAgB,eAAe,gBAAiB,CAAA;AAAA,MACrD,UAAA,EAAY,EAAE,OAAA,EAAS,IAAK,EAAA;AAAA,MAC5B,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,gBAAA,CAAiB,EAAE,IAAA,EAAqD,EAAA;AAC7E,IAAO,OAAA,eAAA,CAAgB,eAAe,gBAAiB,CAAA;AAAA,MACrD,UAAA,EAAY,EAAE,OAAA,EAAS,IAAK,EAAA;AAAA,MAC5B,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,YAAa,CAAA;AAAA,EACjB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,iBAA8D,GAAA;AACnE,IAAA,OAAO,gBAAgB,UAAW,CAAA,iBAAA,CAAkB,EAAE,GAAG,IAAA,CAAK,YAAY,CAAA,CAAA;AAAA,GAC5E;AAAA,EAEO,eAAA,CAAgB,EAAE,IAAA,EAAqE,EAAA;AAC5F,IAAO,OAAA,eAAA,CAAgB,WAAW,eAAgB,CAAA;AAAA,MAChD,IAAM,EAAA,IAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAA,CAAa,EAAE,SAAA,EAA6E,EAAA;AACjG,IAAO,OAAA,eAAA,CAAgB,WAAW,YAAa,CAAA;AAAA,MAC7C,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,eAAgB,CAAA;AAAA,IACrB,SAAA;AAAA,IACA,MAAA;AAAA,GAI6B,EAAA;AAC7B,IAAO,OAAA,eAAA,CAAgB,WAAW,eAAgB,CAAA;AAAA,MAChD,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,eAAA,CAAgB,EAAE,SAAA,EAAgE,EAAA;AACvF,IAAO,OAAA,eAAA,CAAgB,WAAW,eAAgB,CAAA;AAAA,MAChD,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,uBAAA,CAAwB,EAAE,SAAA,EAAoF,EAAA;AACnH,IAAO,OAAA,eAAA,CAAgB,WAAW,uBAAwB,CAAA;AAAA,MACxD,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,yBAA0B,CAAA;AAAA,IAC/B,SAAA;AAAA,IACA,IAAA;AAAA,IACA,IAAA;AAAA,GAKgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,WAAW,yBAA0B,CAAA;AAAA,MAC1D,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,IAAK,EAAA;AAAA,MACnD,IAAA,EAAM,EAAE,IAAK,EAAA;AAAA,MACb,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,qBAAsB,CAAA;AAAA,IAC3B,SAAA;AAAA,IACA,IAAA;AAAA,GAIgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,WAAW,qBAAsB,CAAA;AAAA,MACtD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,IAAK,EAAA;AAAA,MACnD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,UAAW,CAAA;AAAA,EACf,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,qBAAsB,CAAA;AAAA,IAC3B,SAAA;AAAA,IACA,KAAA;AAAA,IACA,IAAA;AAAA,GAKmC,EAAA;AACnC,IAAO,OAAA,eAAA,CAAgB,QAAQ,qBAAsB,CAAA;AAAA,MACnD,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,IAAA,EAAM,EAAE,KAAA,EAAO,IAAK,EAAA;AAAA,MACpB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAKmC,EAAA;AACnC,IAAO,OAAA,eAAA,CAAgB,QAAQ,2BAA4B,CAAA;AAAA,MACzD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,UAAU,MAAO,EAAA;AAAA,MACvD,IAAA,EAAM,EAAE,IAAK,EAAA;AAAA,MACb,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,MAAA;AAAA,GAIgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,QAAQ,2BAA4B,CAAA;AAAA,MACzD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,UAAU,MAAO,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,GAAA;AAAA,GAIgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,QAAQ,2BAA4B,CAAA;AAAA,MACzD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,WAAW,GAAI,EAAA;AAAA,MACrD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,MAAA;AAAA,GAIgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,QAAQ,2BAA4B,CAAA;AAAA,MACzD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,UAAU,MAAO,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,SAAU,CAAA;AAAA,EACd,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,aAAc,CAAA;AAAA,IACnB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,GAKwC,EAAA;AACxC,IAAO,OAAA,eAAA,CAAgB,OAAO,aAAc,CAAA;AAAA,MAC1C,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,gBAAiB,CAAA;AAAA,IACtB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,GAM4B,EAAA;AAC5B,IAAO,OAAA,eAAA,CAAgB,OAAO,gBAAiB,CAAA;AAAA,MAC7C,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,IACA,QAAA;AAAA,GAQsC,EAAA;AACtC,IAAO,OAAA,eAAA,CAAgB,OAAO,YAAa,CAAA;AAAA,MACzC,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,IAAA,EAAM,QAAS,EAAA;AAAA,MACvB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,GAM2C,EAAA;AAC3C,IAAO,OAAA,eAAA,CAAgB,OAAO,YAAa,CAAA;AAAA,MACzC,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,UAAW,CAAA;AAAA,IAChB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,iBAAA;AAAA,IACA,KAAA;AAAA,GAQoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,OAAO,UAAW,CAAA;AAAA,MACvC,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,iBAAA,EAAmB,KAAM,EAAA;AAAA,MACjC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,oBAAqB,CAAA;AAAA,IAC1B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,GAOgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,OAAO,oBAAqB,CAAA;AAAA,MACjD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,QAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,iBAAkB,CAAA;AAAA,IACvB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,GAMkC,EAAA;AAClC,IAAO,OAAA,eAAA,CAAgB,OAAO,iBAAkB,CAAA;AAAA,MAC9C,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,GAMwC,EAAA;AACxC,IAAO,OAAA,eAAA,CAAgB,OAAO,cAAe,CAAA;AAAA,MAC3C,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,qBAAsB,CAAA;AAAA,IAC3B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,GAK2C,EAAA;AAC3C,IAAO,OAAA,eAAA,CAAgB,OAAO,qBAAsB,CAAA;AAAA,MAClD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,mBAAoB,CAAA;AAAA,IACzB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,IACA,UAAA;AAAA,GAO6C,EAAA;AAC7C,IAAO,OAAA,eAAA,CAAgB,OAAO,mBAAoB,CAAA;AAAA,MAChD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,IAAA,EAAM,EAAE,SAAA,EAAW,UAAW,EAAA;AAAA,MAC9B,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,GAMgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,OAAO,sBAAuB,CAAA;AAAA,MACnD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,WAAA,EAAa,EAAE,SAAU,EAAA;AAAA,MACzB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,aAAc,CAAA;AAAA,IACnB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,IACA,cAAA;AAAA,GAOuC,EAAA;AACvC,IAAO,OAAA,eAAA,CAAgB,OAAO,aAAc,CAAA;AAAA,MAC1C,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,WAAA,EAAa,EAAE,SAAA,EAAW,cAAe,EAAA;AAAA,MACzC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,QAAS,CAAA;AAAA,EACb,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,GAOqC,EAAA;AACrC,IAAO,OAAA,eAAA,CAAgB,MAAM,WAAY,CAAA;AAAA,MACvC,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,GAO0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,WAAY,CAAA;AAAA,MACvC,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,GAQ0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,WAAY,CAAA;AAAA,MACvC,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,GAOwC,EAAA;AACxC,IAAO,OAAA,eAAA,CAAgB,MAAM,cAAe,CAAA;AAAA,MAC1C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,GAQ0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,cAAe,CAAA;AAAA,MAC1C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,eAAgB,CAAA;AAAA,IACrB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,GAOyC,EAAA;AACzC,IAAO,OAAA,eAAA,CAAgB,MAAM,eAAgB,CAAA;AAAA,MAC3C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,GAQ0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,cAAe,CAAA;AAAA,MAC1C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,SAAU,CAAA;AAAA,IACf,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,GAQ0B,EAAA;AAC1B,IAAO,OAAA,eAAA,CAAgB,MAAM,SAAU,CAAA;AAAA,MACrC,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,YAAY,MAAO,EAAA;AAAA,MAC7G,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GAS0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,YAAa,CAAA;AAAA,MACxC,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,YAAY,MAAO,EAAA;AAAA,MAC7G,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,GAQ0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,MAAM,YAAa,CAAA;AAAA,MACxC,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,YAAY,MAAO,EAAA;AAAA,MAC7G,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,UAAW,CAAA;AAAA,EACf,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,GAS0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,QAAQ,YAAa,CAAA;AAAA,MAC1C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,MACvB,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,SAAU,CAAA;AAAA,IACf,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,EAAA;AAAA,IACA,OAAA;AAAA,GAS8B,EAAA;AAC9B,IAAO,OAAA,eAAA,CAAgB,QAAQ,SAAU,CAAA;AAAA,MACvC,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,UAAU,EAAG,EAAA;AAAA,MACvG,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,MACvB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,kBAAmB,CAAA;AAAA,IACxB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,EAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA,UAAA;AAAA,IACA,SAAA;AAAA,GAY0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,QAAQ,kBAAmB,CAAA;AAAA,MAChD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,UAAU,EAAG,EAAA;AAAA,MACvG,WAAa,EAAA,EAAE,OAAS,EAAA,UAAA,EAAY,SAAU,EAAA;AAAA,MAC9C,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,kBAAmB,CAAA;AAAA,IACxB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,EAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,GAW0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,QAAQ,kBAAmB,CAAA;AAAA,MAChD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,UAAU,EAAG,EAAA;AAAA,MACvG,WAAA,EAAa,EAAE,OAAA,EAAS,SAAU,EAAA;AAAA,MAClC,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,kBAAmB,CAAA;AAAA,IACxB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,EAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,GAW0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,QAAQ,kBAAmB,CAAA;AAAA,MAChD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,UAAU,EAAG,EAAA;AAAA,MACvG,WAAA,EAAa,EAAE,OAAA,EAAS,SAAU,EAAA;AAAA,MAClC,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,EAAA;AAAA,IACA,OAAA;AAAA,GAS0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,QAAQ,YAAa,CAAA;AAAA,MAC1C,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,UAAU,EAAG,EAAA;AAAA,MACvG,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,MACvB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA;AAAA,GASwC,EAAA;AACxC,IAAO,OAAA,eAAA,CAAgB,QAAQ,sBAAuB,CAAA;AAAA,MACpD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,MACvB,IAAA,EAAM,EAAE,OAAQ,EAAA;AAAA,MAChB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,iBAAkB,CAAA;AAAA,IACvB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,UAAA;AAAA,GAOsC,EAAA;AACtC,IAAO,OAAA,eAAA,CAAgB,QAAQ,iBAAkB,CAAA;AAAA,MAC/C,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,UAAW,EAAA;AAAA,MACnB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,QAAS,CAAA;AAAA,EACb,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GAUe,EAAA;AACf,IAAO,OAAA,eAAA,CAAgB,MAAM,WAAY,CAAA;AAAA,MACvC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,QACZ,MAAA;AAAA,OACF;AAAA,MACA,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAWqC,EAAA;AACrC,IAAO,OAAA,eAAA,CAAgB,MAAM,WAAY,CAAA;AAAA,MACvC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,QACZ,MAAA;AAAA,OACF;AAAA;AAAA,MAEA,IAAM,EAAA,IAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GAUqC,EAAA;AACrC,IAAO,OAAA,eAAA,CAAgB,MAAM,cAAe,CAAA;AAAA,MAC1C,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,QACZ,MAAA;AAAA,OACF;AAAA,MACA,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,OAAQ,CAAA;AAAA,IACb,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GASe,EAAA;AACf,IAAO,OAAA,eAAA,CAAgB,MAAM,OAAQ,CAAA;AAAA,MACnC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,OACd;AAAA,MACA,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,OAAQ,CAAA;AAAA,IACb,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAUqC,EAAA;AACrC,IAAO,OAAA,eAAA,CAAgB,MAAM,OAAQ,CAAA;AAAA,MACnC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,OACd;AAAA,MACA,IAAM,EAAA,IAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,UAAW,CAAA;AAAA,IAChB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GASqC,EAAA;AACrC,IAAO,OAAA,eAAA,CAAgB,MAAM,UAAW,CAAA;AAAA,MACtC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAAA,QACnC,SAAW,EAAA,KAAA;AAAA,QACX,QAAU,EAAA,MAAA;AAAA,QACV,UAAY,EAAA,MAAA;AAAA,OACd;AAAA,MACA,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,UAAW,CAAA;AAAA,IAChB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GAMe,EAAA;AACf,IAAO,OAAA,eAAA,CAAgB,MAAM,UAAW,CAAA;AAAA,MACtC,UAAY,EAAA;AAAA,QACV,SAAA;AAAA,QACA,MAAA;AAAA,QACA,MAAA;AAAA,OACF;AAAA,MACA,WAAA,EAAa,EAAE,MAAO,EAAA;AAAA,MACtB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,kBAAmB,CAAA;AAAA,EACvB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,UAAW,CAAA;AAAA,IAChB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAA;AAAA,IACA,WAAA;AAAA,GAYmC,EAAA;AACnC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,UAAW,CAAA;AAAA,MAChD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,MAAM,EAAE,MAAA,EAAQ,IAAM,EAAA,IAAA,EAAM,SAAS,WAAY,EAAA;AAAA,MACjD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,WAAY,CAAA;AAAA,IACjB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,KAAA;AAAA,IACA,SAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,SAAA;AAAA,IACA,QAAA;AAAA,GAcoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,WAAY,CAAA;AAAA,MACjD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAA,EAAM,EAAE,KAAO,EAAA,SAAA,EAAW,QAAQ,MAAQ,EAAA,MAAA,EAAQ,WAAW,QAAS,EAAA;AAAA,MACtE,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,YAAa,CAAA;AAAA,IAClB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,SAAA;AAAA,IACA,MAAA;AAAA,IACA,SAAA;AAAA,GAmBoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,YAAa,CAAA;AAAA,MAClD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,MAAM,EAAE,MAAA,EAAQ,KAAO,EAAA,SAAA,EAAW,QAAQ,SAAU,EAAA;AAAA,MACpD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,iBAAkB,CAAA;AAAA,IACvB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,WAAA;AAAA,IACA,MAAA;AAAA,IACA,kBAAA;AAAA,IACA,IAAA;AAAA,IACA,MAAA;AAAA,GAYoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,iBAAkB,CAAA;AAAA,MACvD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,MAAM,EAAE,WAAA,EAAa,MAAQ,EAAA,kBAAA,EAAoB,MAAM,MAAO,EAAA;AAAA,MAC9D,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,QAAS,CAAA;AAAA,IACd,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,OAAA;AAAA,GAQuC,EAAA;AACvC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,QAAS,CAAA;AAAA,MAC9C,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAA,EAAM,EAAE,GAAG,OAAQ,EAAA;AAAA,MACnB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,eAAgB,CAAA;AAAA,IACrB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,SAAA;AAAA,IACA,OAAA;AAAA,GAS8C,EAAA;AAC9C,IAAO,OAAA,eAAA,CAAgB,gBAAgB,eAAgB,CAAA;AAAA,MACrD,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,YAAc,EAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,EAAI,SAAW,EAAA,KAAA,EAAO,SAAU,EAAA;AAAA,MACpG,IAAA,EAAM,EAAE,OAAQ,EAAA;AAAA,MAChB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,IACA,IAAA;AAAA,IACA,eAAA;AAAA,IACA,IAAA;AAAA,IACA,WAAA;AAAA,GAcuC,EAAA;AACvC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,cAAe,CAAA;AAAA,MACpD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAA,EAAM,EAAE,MAAQ,EAAA,OAAA,EAAS,WAAW,IAAM,EAAA,eAAA,EAAiB,MAAM,WAAY,EAAA;AAAA,MAC7E,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GASiC,EAAA;AACjC,IAAO,OAAA,eAAA,CAAgB,gBAAgB,cAAe,CAAA;AAAA,MACpD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,SAAA,EAAW,KAAM,EAAA;AAAA,MACzF,IAAA,EAAM,EAAE,MAAA,EAAQ,IAAK,EAAA;AAAA,MACrB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,oBAAqB,CAAA;AAAA,EACzB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAA;AAAA,GASqD,EAAA;AACrD,IAAO,OAAA,eAAA,CAAgB,kBAAkB,sBAAuB,CAAA;AAAA,MAC9D,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,IAAM,EAAA,EAAE,MAAQ,EAAA,IAAA,EAAM,MAAM,OAAQ,EAAA;AAAA,MACpC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,GAMqD,EAAA;AACrD,IAAO,OAAA,eAAA,CAAgB,kBAAkB,sBAAuB,CAAA;AAAA,MAC9D,UAAY,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,QAAQ,QAAS,EAAA;AAAA,MAClD,IAAM,EAAA,SAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,mBAAoB,CAAA;AAAA,IACzB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,GAMoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,kBAAkB,mBAAoB,CAAA;AAAA,MAC3D,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,IACA,MAAA;AAAA,GAOgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,kBAAkB,sBAAuB,CAAA;AAAA,MAC9D,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,4BAA6B,CAAA;AAAA,IAClC,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,IACA,IAAA;AAAA,GAO2D,EAAA;AAC3D,IAAO,OAAA,eAAA,CAAgB,kBAAkB,4BAA6B,CAAA;AAAA,MACpE,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,IAAA,EAAM,EAAE,IAAK,EAAA;AAAA,MACb,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,uBAAwB,CAAA;AAAA,IAC7B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,GAM2C,EAAA;AAC3C,IAAO,OAAA,eAAA,CAAgB,kBAAkB,uBAAwB,CAAA;AAAA,MAC/D,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,GAM0D,EAAA;AAC1D,IAAO,OAAA,eAAA,CAAgB,kBAAkB,2BAA4B,CAAA;AAAA,MACnE,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,qBAAsB,CAAA;AAAA,IAC3B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,gBAAA;AAAA,GAM4B,EAAA;AAC5B,IAAO,OAAA,eAAA,CAAgB,kBAAkB,qBAAsB,CAAA;AAAA,MAC7D,YAAY,EAAE,SAAA,EAAW,QAAQ,MAAQ,EAAA,QAAA,EAAU,UAAU,gBAAiB,EAAA;AAAA,MAC9E,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,aAAc,CAAA;AAAA,EAClB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,yBAA0B,CAAA;AAAA,IAC/B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,SAAA;AAAA,GAQmD,EAAA;AACnD,IAAO,OAAA,eAAA,CAAgB,WAAW,yBAA0B,CAAA;AAAA,MAC1D,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,KAAA,EAAO,SAAU,EAAA;AAAA,MACzB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,GAOyC,EAAA;AACzC,IAAO,OAAA,eAAA,CAAgB,WAAW,sBAAuB,CAAA;AAAA,MACvD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,MAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,0BAA2B,CAAA;AAAA,IAChC,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAO0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,WAAW,0BAA2B,CAAA;AAAA,MAC3D,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,IAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAOgD,EAAA;AAChD,IAAO,OAAA,eAAA,CAAgB,WAAW,sBAAuB,CAAA;AAAA,MACvD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,IAAK,EAAA;AAAA,MACb,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,2BAA4B,CAAA;AAAA,IACjC,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,MAAA;AAAA,IACA,gBAAA;AAAA,IACA,gBAAA;AAAA,GAS2C,EAAA;AAC3C,IAAO,OAAA,eAAA,CAAgB,WAAW,2BAA4B,CAAA;AAAA,MAC5D,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,EAAE,MAAQ,EAAA,gBAAA,EAAkB,gBAAiB,EAAA;AAAA,MACnD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,oBAAqB,CAAA;AAAA,IAC1B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA;AAAA,IACA,sBAAA;AAAA,IACA,sBAAA;AAAA,GAS2C,EAAA;AAC3C,IAAO,OAAA,eAAA,CAAgB,WAAW,oBAAqB,CAAA;AAAA,MACrD,UAAA,EAAY,EAAE,SAAA,EAAW,MAAQ,EAAA,YAAA,EAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAI,CAAA,EAAA,UAAA,EAAY,OAAQ,EAAA;AAAA,MAC5F,IAAA,EAAM,EAAE,sBAAA,EAAwB,sBAAuB,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,kBAAmB,CAAA;AAAA,IACxB,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,SAAA;AAAA,GAO0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,WAAW,kBAAmB,CAAA;AAAA,MACnD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,SAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,uBAAwB,CAAA;AAAA,IAC7B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,IAAA;AAAA,GAOsD,EAAA;AACtD,IAAO,OAAA,eAAA,CAAgB,WAAW,uBAAwB,CAAA;AAAA,MACxD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAM,EAAA,IAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,qBAAsB,CAAA;AAAA,IAC3B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,GAO0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,WAAW,qBAAsB,CAAA;AAAA,MACtD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,KAAM,EAAA;AAAA,MACd,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,oBAAqB,CAAA;AAAA,IAC1B,SAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,UAAA;AAAA,GAO0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,WAAW,oBAAqB,CAAA;AAAA,MACrD,UAAA,EAAY,EAAE,SAAW,EAAA,MAAA,EAAQ,cAAc,CAAG,EAAA,QAAQ,CAAI,CAAA,EAAA,MAAM,CAAG,CAAA,EAAA;AAAA,MACvE,IAAA,EAAM,EAAE,UAAW,EAAA;AAAA,MACnB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,WAAY,CAAA;AAAA,EAChB,YAAoB,UAA2B,EAAA;AAA3B,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA;AAAA,GAA4B;AAAA,EAEzC,eAAA,CAAgB,EAAE,SAAA,EAAyF,EAAA;AAChH,IAAO,OAAA,eAAA,CAAgB,UAAU,eAAgB,CAAA;AAAA,MAC/C,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,QAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAA;AAAA,GAM6C,EAAA;AAC7C,IAAO,OAAA,eAAA,CAAgB,UAAU,cAAe,CAAA;AAAA,MAC9C,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,IAAM,EAAA,IAAA;AAAA,MACN,OAAA;AAAA,MACA,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,QAAA;AAAA,GAI6C,EAAA;AAC7C,IAAO,OAAA,eAAA,CAAgB,UAAU,cAAe,CAAA;AAAA,MAC9C,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,mBAAoB,CAAA;AAAA,IACzB,SAAA;AAAA,IACA,QAAA;AAAA,GAIoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,UAAU,mBAAoB,CAAA;AAAA,MACnD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,sBAAuB,CAAA;AAAA,IAC5B,SAAA;AAAA,IACA,QAAA;AAAA,IACA,QAAA;AAAA,GAKoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,UAAU,sBAAuB,CAAA;AAAA,MACtD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,IAAM,EAAA,QAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,cAAe,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,QAAA;AAAA,IACA,OAAA;AAAA,GAKoC,EAAA;AACpC,IAAO,OAAA,eAAA,CAAgB,UAAU,cAAe,CAAA;AAAA,MAC9C,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,IAAA,EAAM,EAAE,OAAQ,EAAA;AAAA,MAChB,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,yBAA0B,CAAA;AAAA,IAC/B,SAAA;AAAA,IACA,QAAA;AAAA,GAI0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,UAAU,yBAA0B,CAAA;AAAA,MACzD,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,4BAA6B,CAAA;AAAA,IAClC,SAAA;AAAA,IACA,QAAA;AAAA,IACA,QAAA;AAAA,GAK0C,EAAA;AAC1C,IAAO,OAAA,eAAA,CAAgB,UAAU,4BAA6B,CAAA;AAAA,MAC5D,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,IAAM,EAAA,QAAA;AAAA,MACN,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,4BAA6B,CAAA;AAAA,IAClC,SAAA;AAAA,IACA,QAAA;AAAA,GAIgB,EAAA;AAChB,IAAO,OAAA,eAAA,CAAgB,UAAU,4BAA6B,CAAA;AAAA,MAC5D,UAAY,EAAA,EAAE,WAAa,EAAA,SAAA,EAAW,QAAQ,QAAS,EAAA;AAAA,MACvD,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AAAA,EAEO,WAAA,CAAY,EAAE,SAAA,EAAuF,EAAA;AAC1G,IAAO,OAAA,eAAA,CAAgB,UAAU,WAAY,CAAA;AAAA,MAC3C,UAAA,EAAY,EAAE,WAAA,EAAa,SAAU,EAAA;AAAA,MACrC,GAAG,IAAK,CAAA,UAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACH;AACF;;ACv3DO,MAAM,aAAoC,CAAA;AAAA,EAC/C,MAAM,OAA4B,EAAA;AAChC,IAAO,OAAA,IAAI,cAAc,OAAO,CAAA,CAAA;AAAA,GAClC;AACF;;AChBO,MAAe,UAAW,CAAA;AAEjC;;ACoKO,SAAS,qBAAqB,eAAiD,EAAA;AACpF,EAAA,OAAO,eACJ,CAAA,OAAA;AAAA,IAAQ,CAAC,CACR,KAAA,MAAA,CAAO,OAAQ,CAAA,CAAC,CAAE,CAAA,GAAA,CAAI,CAAC,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AAEtC,MAAA,IAAI,QAAQ,MAAQ,EAAA;AAClB,QAAM,MAAA,EAAE,OAAO,CAAG,EAAA,GAAA,GAAM,GAAG,KAAQ,GAAA,CAAA,EAAG,MAAS,GAAA,CAAA,EAAM,GAAA,KAAA,CAAA;AACrD,QAAO,OAAA,CAAA,EAAG,GAAG,CAAA,CAAA,EAAI,CAAC,GAAA,EAAK,KAAO,EAAA,MAAA,EAAQ,IAAI,CAAA,CAAE,IAAK,CAAA,GAAG,CAAC,CAAA,CAAA,CAAA;AAAA,OACvD;AAGA,MAAA,IAAI,GAAQ,KAAA,SAAA,IAAa,OAAO,KAAA,KAAU,QAAU,EAAA;AAClD,QAAA,MAAM,EAAE,CAAA,GAAI,GAAK,EAAA,CAAA,GAAI,KAAQ,GAAA,KAAA,CAAA;AAC7B,QAAO,OAAA,CAAA,EAAG,GAAG,CAAI,CAAA,EAAA,CAAC,GAAG,CAAC,CAAA,CAAE,IAAK,CAAA,GAAG,CAAC,CAAA,CAAA,CAAA;AAAA,OACnC;AAEA,MAAO,OAAA,CAAA,EAAG,GAAG,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAA;AAAA,KACvB,CAAA;AAAA,GACH,CACC,KAAK,GAAG,CAAA,CAAA;AACb,CAAA;AAIgB,SAAA,cAAA,CAAe,QAA4B,eAAyC,EAAA;AAClG,EAAI,IAAA,CAAC,UAAU,GAAG,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA,CAAA;AAE5B,EAAM,MAAA,kBAAA,GAAqB,qBAAqB,eAAe,CAAA,CAAA;AAE/D,EAAA,MAAM,EAAE,QAAU,EAAA,QAAA,EAAU,QAAW,GAAA,IAAI,IAAI,GAAG,CAAA,CAAA;AAGlD,EAAM,MAAA,SAAA,GAAY,QAAS,CAAA,KAAA,CAAM,GAAG,CAAA,CAAA;AACpC,EAAA,MAAM,iBAAiB,SAAU,CAAA,SAAA,CAAU,CAAC,IAAA,KAAS,SAAS,WAAW,CAAA,CAAA;AACzE,EAAM,MAAA,YAAA,GAAe,kBAAkB,CAAI,GAAA,SAAA,CAAU,OAAO,cAAgB,EAAA,CAAC,IAAI,EAAC,CAAA;AAGlF,EAAA,MAAM,SAAY,GAAA,CAAA,WAAA,EAAc,CAAC,YAAA,CAAa,CAAC,CAAA,EAAG,kBAAkB,CAAA,CAAE,MAAO,CAAA,SAAS,CAAE,CAAA,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA;AACjG,EAAM,MAAA,IAAA,GAAO,SAAU,CAAA,IAAA,CAAK,GAAG,CAAA,CAAA;AAE/B,EAAA,OAAO,WAAW,QAAQ,CAAA,EAAG,SAAS,CAAG,EAAA,IAAI,GAAG,MAAM,CAAA,CAAA,CAAA;AACxD;;ACpMO,MAAM,QAAS,CAAA;AAAA,EA8CpB,YAAY,IAAyB,EAAA;AACnC,IAAA,IAAA,CAAK,KAAK,IAAK,CAAA,EAAA,CAAA;AACf,IAAK,IAAA,CAAA,IAAA,GAAO,KAAK,IAAQ,IAAA,EAAA,CAAA;AACzB,IAAK,IAAA,CAAA,SAAA,GAAY,KAAK,SAAa,IAAA,0BAAA,CAAA;AACnC,IAAA,IAAA,CAAK,gBAAgB,IAAK,CAAA,aAAA,CAAA;AAC1B,IAAK,IAAA,CAAA,eAAA,GAAkB,KAAK,eAAmB,IAAA,KAAA,CAAA;AAC/C,IAAK,IAAA,CAAA,gBAAA,GAAmB,KAAK,gBAAoB,IAAA,GAAA,CAAA;AACjD,IAAK,IAAA,CAAA,IAAA,GAAO,KAAK,IAAQ,IAAA,CAAA,CAAA;AACzB,IAAK,IAAA,CAAA,OAAA,GAAU,KAAK,OAAW,IAAA,CAAA,CAAA;AAC/B,IAAK,IAAA,CAAA,GAAA,GAAM,KAAK,GAAO,IAAA,EAAA,CAAA;AACvB,IAAA,IAAA,CAAK,YAAY,IAAK,CAAA,SAAA,CAAA;AACtB,IAAK,IAAA,CAAA,UAAA,GAAa,IAAK,CAAA,UAAA,IAAc,EAAC,CAAA;AAAA,GACxC;AAAA,EAEA,OAAO,UAAA,CAAW,MAAgB,EAAA,OAAA,GAAkC,EAAc,EAAA;AAChF,IAAM,MAAA,aAAA,GAAgB,MAAO,CAAA,QAAA,CAAS,QAAQ,CAAA,CAAA;AAC9C,IAAA,OAAO,IAAI,QAAS,CAAA,EAAE,GAAG,OAAA,EAAS,eAAe,CAAA,CAAA;AAAA,GACnD;AAAA,EAEO,QAAmB,GAAA;AACxB,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAA,OAAO,MAAO,CAAA,IAAA,CAAK,IAAK,CAAA,aAAA,EAAe,QAAQ,CAAA,CAAA;AAAA,GACjD;AAAA,EAEA,OAAO,eAAA,CAAgB,WAA0B,EAAA,OAAA,GAAkC,EAAI,EAAA;AACrF,IAAM,MAAA,UAAA,GAAa,IAAI,UAAA,CAAW,WAAW,CAAA,CAAA;AAC7C,IAAO,OAAA,IAAA,CAAK,cAAe,CAAA,UAAA,EAAY,OAAO,CAAA,CAAA;AAAA,GAChD;AAAA,EAEO,aAA6B,GAAA;AAClC,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAM,MAAA,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,aAAa,CAAA,CAAA;AACtC,IAAO,OAAA,IAAI,WAAY,CAAA,MAAA,CAAO,MAAM,CAAA,CAAA;AAAA,GACtC;AAAA,EAEA,OAAO,cAAA,CAAe,UAAwB,EAAA,OAAA,GAAkC,EAAI,EAAA;AAClF,IAAA,IAAI,MAAS,GAAA,EAAA,CAAA;AAEb,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,CAAW,YAAY,CAAK,EAAA,EAAA;AAC9C,MAAA,MAAA,IAAU,MAAO,CAAA,YAAA,CAAa,UAAW,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,KAC7C;AAEA,IAAM,MAAA,aAAA,GAAgB,KAAK,MAAM,CAAA,CAAA;AACjC,IAAA,OAAO,IAAI,QAAS,CAAA,EAAE,GAAG,OAAA,EAAS,eAAe,CAAA,CAAA;AAAA,GACnD;AAAA,EAEO,YAA2B,GAAA;AAChC,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAM,MAAA,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,aAAa,CAAA,CAAA;AACtC,IAAA,MAAM,UAAa,GAAA,IAAI,UAAW,CAAA,MAAA,CAAO,MAAM,CAAA,CAAA;AAE/C,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AACtC,MAAA,UAAA,CAAW,CAAC,CAAA,GAAI,MAAO,CAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAAA,KACrC;AAEA,IAAO,OAAA,UAAA,CAAA;AAAA,GACT;AAAA,EAEA,aAAa,QAAA,CAAS,IAAY,EAAA,OAAA,GAAkC,EAAI,EAAA;AAEtE,IAAM,MAAA,IAAA,GAAO,OAAQ,CAAA,IAAA,IAAQ,IAAK,CAAA,IAAA,CAAA;AAClC,IAAA,MAAM,YAAY,IAAK,CAAA,IAAA,CAAA;AACvB,IAAM,MAAA,WAAA,GAAc,MAAM,IAAA,CAAK,WAAY,EAAA,CAAA;AAE3C,IAAO,OAAA,IAAA,CAAK,gBAAgB,WAAa,EAAA,EAAE,GAAG,OAAS,EAAA,IAAA,EAAM,WAAW,CAAA,CAAA;AAAA,GAC1E;AAAA,EAEO,MAAe,GAAA;AACpB,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAM,MAAA,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,aAAa,CAAA,CAAA;AACtC,IAAA,MAAM,UAAa,GAAA,IAAI,UAAW,CAAA,MAAA,CAAO,MAAM,CAAA,CAAA;AAE/C,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AACtC,MAAA,UAAA,CAAW,CAAC,CAAA,GAAI,MAAO,CAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAAA,KACrC;AAEA,IAAO,OAAA,IAAI,KAAK,CAAC,UAAU,GAAG,EAAE,IAAA,EAAM,IAAK,CAAA,SAAA,EAAW,CAAA,CAAA;AAAA,GACxD;AAAA,EAEA,OAAO,UAAA,CAAW,MAAgB,EAAA,OAAA,GAAkC,EAAc,EAAA;AAChF,IAAM,MAAA,aAAA,GAAgB,KAAK,MAAM,CAAA,CAAA;AACjC,IAAA,OAAO,IAAI,QAAS,CAAA,EAAE,GAAG,OAAA,EAAS,eAAe,CAAA,CAAA;AAAA,GACnD;AAAA,EAEO,QAAmB,GAAA;AACxB,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAO,OAAA,IAAA,CAAK,KAAK,aAAa,CAAA,CAAA;AAAA,GAChC;AAAA,EAEA,OAAO,UAAA,CAAW,aAAuB,EAAA,OAAA,GAAkC,EAAc,EAAA;AACvF,IAAA,OAAO,IAAI,QAAS,CAAA,EAAE,GAAG,OAAA,EAAS,eAAe,CAAA,CAAA;AAAA,GACnD;AAAA,EAEO,QAAmB,GAAA;AACxB,IAAI,IAAA,CAAC,KAAK,aAAe,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,CAA8F,4FAAA,CAAA,CAAA,CAAA;AAAA,KAChH;AAEA,IAAA,OAAO,IAAK,CAAA,aAAA,CAAA;AAAA,GACd;AAAA,EAEO,aAAa,OAAiC,EAAA;AACnD,IAAO,OAAA;AAAA,MACL,GAAK,EAAA,cAAA,CAAe,IAAK,CAAA,GAAA,EAAK,GAAG,OAAO,CAAA;AAAA,MACxC,SAAW,EAAA,cAAA,CAAe,IAAK,CAAA,SAAA,EAAW,GAAG,OAAO,CAAA;AAAA,MACpD,WAAA,EAAa,eAAe,IAAK,CAAA,GAAA,EAAK,GAAG,OAAS,EAAA,EAAE,MAAQ,EAAA,MAAA,EAAQ,CAAA;AAAA,MACpE,iBAAA,EAAmB,eAAe,IAAK,CAAA,SAAA,EAAW,GAAG,OAAS,EAAA,EAAE,MAAQ,EAAA,MAAA,EAAQ,CAAA;AAAA,KAClF,CAAA;AAAA,GACF;AACF,CAAA;AAIa,MAAA,mBAAA,GAAsB,OAAO,KAAyD,KAAA;AACjG,EAAI,IAAA,CAAC,UAAU,KAAK,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAE9B,EAAM,MAAA,EAAE,IAAI,IAAM,EAAA,SAAA,EAAW,eAAe,eAAiB,EAAA,gBAAA,KAAqB,MAAM,KAAA,CAAA;AACxF,EAAA,OAAO,aAAc,CAAA;AAAA,IACnB,EAAA;AAAA;AAAA,IAEA,IAAA,EAAM,OAAO,IAAO,GAAA,KAAA,CAAA;AAAA,IACpB,SAAA;AAAA,IACA,aAAA;AAAA,IACA,eAAA;AAAA,IACA,gBAAA;AAAA,GACD,CAAA,CAAA;AACH,CAAA;;ACnEO,SAAS,YAAY,MAAkD,EAAA;AAC5E,EAAI,IAAA,CAAC,UAAU,MAAM,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA,CAAA;AAC/B,EAAI,IAAA,CAAC,SAAS,MAAM,CAAA;AAAG,IAAO,OAAA,MAAA,CAAA;AAE9B,EAAA,MAAM,SAAS,MAAO,CAAA,WAAA;AAAA,IACpB,MAAA,CAAO,OAAQ,CAAA,MAAM,CAAE,CAAA,MAAA,CAAO,CAAC,GAAK,EAAA,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AAEnD,MAAI,IAAA,CAAC,UAAU,KAAK,CAAA;AAAG,QAAO,OAAA,GAAA,CAAA;AAE9B,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;AAExB,QAAA,MAAM,KAAQ,GAAA,KAAA,CAAM,GAAI,CAAA,CAAC,SAAS,WAAY,CAAA,IAAI,CAAC,CAAA,CAAE,MAAO,CAAA,CAAC,IAAS,KAAA,SAAA,CAAU,IAAI,CAAC,CAAA,CAAA;AAGrF,QAAA,IAAI,MAAM,MAAW,KAAA,CAAA;AAAG,UAAO,OAAA,GAAA,CAAA;AAE/B,QAAA,OAAO,CAAC,GAAG,GAAA,EAAK,CAAC,GAAA,EAAK,KAAK,CAAC,CAAA,CAAA;AAAA,OAC9B;AAEA,MAAI,IAAA,QAAA,CAAS,KAAK,CAAG,EAAA;AAEnB,QAAM,MAAA,KAAA,GAAQ,YAAY,KAAK,CAAA,CAAA;AAC/B,QAAI,IAAA,CAAC,UAAU,KAAK,CAAA;AAAG,UAAO,OAAA,GAAA,CAAA;AAE9B,QAAA,OAAO,CAAC,GAAG,GAAA,EAAK,CAAC,GAAA,EAAK,KAAK,CAAC,CAAA,CAAA;AAAA,OAC9B;AAEA,MAAA,OAAO,CAAC,GAAG,GAAA,EAAK,CAAC,GAAA,EAAK,KAAK,CAAC,CAAA,CAAA;AAAA,KAC9B,EAAG,EAAqB,CAAA;AAAA,GAC1B,CAAA;AAEA,EAAA,OAAO,OAAO,IAAK,CAAA,MAAM,CAAE,CAAA,MAAA,GAAS,IAAI,MAAS,GAAA,KAAA,CAAA,CAAA;AACnD;;AC7JO,SAAS,cAAc,KAAY,EAAA;AACxC,EAAI,IAAA,CAAC,UAAU,KAAK,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA;AAC9B,EAAA,IAAI,SAAS,KAAK,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA;AAE5B,EAAI,IAAA;AACF,IAAO,OAAA,IAAA,CAAK,UAAU,KAAK,CAAA,CAAA;AAAA,WACpB,CAAG,EAAA;AACV,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEO,SAAS,UAAU,KAAe,EAAA;AACvC,EAAI,IAAA;AACF,IAAO,OAAA,IAAA,CAAK,MAAM,KAAK,CAAA,CAAA;AAAA,WAChB,CAAG,EAAA;AACV,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AACF;;;;;;;;;;;;;;;;;;;;AC1BA,IAAA,MAAA,EAAA,KAAA,CAAA;AAsBO,MAAM,IAAyG,CAAA;AAAA,EAWpH,WAAY,CAAA,KAAA,EAA8B,IAA2B,EAAA,OAAA,GAAoB,EAAI,EAAA;AAV7F,IAAAH,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAWE,IAAAC,cAAA,CAAA,IAAA,EAAK,MAAS,EAAA,KAAA,CAAA,CAAA;AACd,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AACZ,IAAA,IAAA,CAAK,OAAU,GAAA,IAAI,WAAY,CAAA,IAAA,EAAM,OAAO,CAAA,CAAA;AAAA,GAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,QAAS,CAAA,IAAA,EAAe,MAAgD,EAAA;AAC5E,IAAA,OAAOE,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,YAAa,CAAA,EAAE,YAAY,EAAE,IAAA,EAAM,MAAQ,EAAA,KAAA,EAAO,IAAK,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,IAAU,CAAA,CAAA;AAAA,GAChG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,YAAa,CAAA,IAAA,EAAe,MAAgD,EAAA;AAChF,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,YAAa,CAAA,EAAE,YAAY,EAAE,IAAA,EAAM,MAAQ,EAAA,MAAA,EAAQ,IAAK,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,IAAU,CAAA,CAAA;AAAA,GACjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,SAAU,CAAA,IAAA,EAAe,MAAgD,EAAA;AAC7E,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,YAAa,CAAA,EAAE,YAAY,EAAE,IAAA,EAAM,MAAQ,EAAA,KAAA,EAAO,IAAK,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,IAAU,CAAA,CAAA;AAAA,GAChG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,OAAQ,CAAA,IAAA,EAAe,MAAgD,EAAA;AAC3E,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAO,YAAa,CAAA,EAAE,YAAY,EAAE,IAAA,EAAM,MAAQ,EAAA,GAAA,EAAK,IAAK,CAAA,IAAA,CAAK,IAAK,CAAA,MAAA,IAAU,CAAA,CAAA;AAAA,GAC9F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAuB,GAAA;AACrB,IAAO,OAAA,IAAA,CAAK,KAAK,IAAK,CAAA,IAAA,CAAA;AAAA,GACxB;AACF,CAAA;AA/DE,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAoEK,MAAM,mBAAsB,GAAA,IAAA;AAC5B,MAAM,uBAA0B,GAAA,GAAA;AAChC,MAAM,qBAAwB,GAAA,KAAA;AAC9B,MAAM,yBAA4B,GAAA,EAAA;AAElC,SAAS,0BACd,OACoC,EAAA;AACpC,EAAA,OACE,UAAU,OAAO,CAAA,KAChB,SAAU,CAAA,OAAA,CAAQ,KAAK,CAAK,IAAA,SAAA,CAAU,OAAQ,CAAA,GAAG,KAAK,SAAU,CAAA,OAAA,CAAQ,KAAK,CAAK,IAAA,SAAA,CAAU,QAAQ,MAAM,CAAA,CAAA,CAAA;AAE/G,CAAA;AAEO,MAAM,YAAA,GAAN,MAAM,YAAA,SAA+C,KAAc,CAAA;AAAA,EAIxE,eAAe,IAAa,EAAA;AAC1B,IAAA,KAAA,CAAM,GAAG,YAAA,CAAY,sBAAuB,CAAA,GAAG,IAAI,CAAC,CAAA,CAAA;AAJtD,IAAAH,cAAA,CAAA,IAAA,EAAA,KAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAOE,IAAKC,cAAA,CAAA,IAAA,EAAA,KAAA,EAAQ,SAAS,IAAK,CAAA,CAAC,GAAG,IAAI,CAAA,GAAI,IAAK,CAAA,CAAC,CAAI,GAAA,EAAE,MAAM,EAAE,IAAA,EAAM,EAAE,MAAA,EAAQ,EAAI,EAAA,IAAA,EAAM,OAAQ,EAAA,EAAG,OAAS,EAAA,EAAG,EAAA,CAAA,CAAA;AAAA,GAC9G;AAAA,EAEA,OAAO,0BAA0B,IAAa,EAAA;AAE5C,IAAA,IAAI,KAAK,MAAW,KAAA,CAAA,IAAK,OAAO,IAAK,CAAA,CAAC,MAAM,QAAU,EAAA;AACpD,MAAA,OAAO,IAAI,KAAA,CAAM,IAAK,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,KAC1B;AAGA,IAAA,IAAI,KAAK,MAAU,IAAA,CAAA,IAAK,QAAS,CAAA,IAAA,CAAK,CAAC,CAAG,EAAA,IAAI,CAAK,IAAA,KAAA,CAAM,QAAQ,IAAK,CAAA,CAAC,CAAK,IAAA,EAAE,CAAG,EAAA;AAC/E,MAAM,MAAA,MAAA,GAAS,KAAK,CAAC,CAAA,IAAK,KAAK,CAAC,CAAA,CAAE,WAAW,EAAC,CAAA;AAC9C,MAAO,OAAA,IAAI,KAAM,CAAA,GAAG,MAAM,CAAA,CAAA;AAAA,KAC5B;AAGA,IAAO,OAAA,IAAI,KAAM,CAAA,GAAG,IAAI,CAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,OAAoB,GAAA;AAClB,IAAO,OAAA,IAAI,KAAM,CAAA,GAAG,IAAI,CAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,cAAqC,GAAA;AACnC,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,QAAA,EAAU,CAAA,CAAA;AAAA,GACnC;AAAA,EAEA,QAAmB,GAAA;AACjB,IAAA,OAAO,IAAK,CAAA,SAAA,CAAU,IAAK,CAAA,OAAA,EAAS,CAAA,CAAA;AAAA,GACtC;AAAA,EAEA,GAAA,CAAO,YAAkE,OAAoB,EAAA;AAC3F,IAAA,OAAO,IAAK,CAAA,OAAA,EAAU,CAAA,GAAA,CAAI,YAAY,OAAO,CAAA,CAAA;AAAA,GAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAS,CAAA,IAAA,EAAe,MAA+C,EAAA;AAC3E,IAAA,MAAM,UAAU,MAAME,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,QAAA,CAAS,MAAM,MAAM,CAAA,CAAA;AACtD,IAAO,OAAA,IAAI,aAAY,OAAO,CAAA,CAAA;AAAA,GAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAa,CAAA,IAAA,EAAe,MAA+C,EAAA;AAC/E,IAAA,MAAM,UAAU,MAAMA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,YAAA,CAAa,MAAM,MAAM,CAAA,CAAA;AAC1D,IAAO,OAAA,IAAI,aAAY,OAAO,CAAA,CAAA;AAAA,GAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAU,CAAA,IAAA,EAAe,MAA+C,EAAA;AAC5E,IAAA,MAAM,UAAU,MAAMA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,SAAA,CAAU,MAAM,MAAM,CAAA,CAAA;AACvD,IAAO,OAAA,IAAI,aAAY,OAAO,CAAA,CAAA;AAAA,GAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAQ,CAAA,IAAA,EAAe,MAA+C,EAAA;AAC1E,IAAA,MAAM,UAAU,MAAMA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,OAAA,CAAQ,MAAM,MAAM,CAAA,CAAA;AACrD,IAAO,OAAA,IAAI,aAAY,OAAO,CAAA,CAAA;AAAA,GAChC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAuB,GAAA;AACrB,IAAO,OAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAA;AAAA,GAC9B;AACF,CAAA,CAAA;AAxFE,KAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AADK,IAAM,WAAN,GAAA;;;;;;;;;;;;;;;;;;;;;;;;ACzGP,IAAAK,QAAA,EAAA,WAAA,EAAA,KAAA,EAAA,sBAAA,EAAA,wBAAA,CAAA;AAiDO,MAAM,MAAA,GAAN,MAAM,MAA0G,CAAA;AAAA,EASrH,WACE,CAAA,UAAA,EACA,KACA,EAAA,IAAA,EACA,SACA,EAAA;AAqIF,IAAAR,cAAA,CAAA,IAAA,EAAA,sBAAA,CAAA,CAAA;AAlJA,IAAAA,cAAA,CAAA,IAAA,EAAAQ,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAR,cAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAA8BA,cAAA,CAAA,IAAA,EAAA,KAAA,EAAA,EAAE,MAAQ,EAAA,EAAG,EAAA,CAAA,CAAA;AAG3C;AAAA,IAAS,IAAA,CAAA,IAAA,GAA4B,EAAE,IAAA,EAAM,EAAE,MAAA,EAAQ,SAAS,IAAM,EAAA,IAAA,EAAM,IAAM,EAAA,uBAAA,EAA0B,EAAA,CAAA;AAC5G,IAAA,IAAA,CAAS,OAA+B,GAAA,IAAI,WAAoB,CAAA,IAAA,EAAM,EAAE,CAAA,CAAA;AAQtE,IAAAC,cAAA,CAAA,IAAA,EAAKO,QAAS,EAAA,KAAA,CAAA,CAAA;AAEd,IAAA,IAAI,UAAY,EAAA;AACd,MAAAP,cAAA,CAAA,IAAA,EAAK,WAAc,EAAA,UAAA,CAAA,CAAA;AAAA,KACd,MAAA;AACL,MAAAA,cAAA,CAAA,IAAA,EAAK,WAAc,EAAA,IAAA,CAAA,CAAA;AAAA,KACrB;AAGA,IAAM,MAAA,MAAA,GAAS,WAAY,CAAA,IAAA,EAAM,SAAS,CAAA,CAAA;AAE1C,IAAAE,cAAA,CAAA,IAAA,EAAK,OAAM,MAAS,GAAA,IAAA,CAAK,MAAU,IAAA,MAAA,EAAQ,UAAU,EAAC,CAAA;AACtD,IAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,MAAO,CAAA,IAAA,GAAO,KAAK,MAAQ,EAAA,IAAA,IAAQ,QAAQ,MAAQ,EAAA,IAAA,CAAA;AAC9D,IAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,MAAO,CAAA,IAAA,GAAO,KAAK,MAAQ,EAAA,IAAA,IAAQ,QAAQ,MAAQ,EAAA,IAAA,CAAA;AAC9D,IAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,MAAO,CAAA,IAAA,GAAO,KAAK,MAAQ,EAAA,IAAA,IAAQ,QAAQ,MAAQ,EAAA,IAAA,CAAA;AAC9D,IAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,MAAO,CAAA,KAAA,GAAQ,KAAK,MAAQ,EAAA,KAAA,IAAS,QAAQ,MAAQ,EAAA,KAAA,CAAA;AAChE,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,IAAA,GAAQ,IAAK,CAAA,IAAA,IAAQ,MAAQ,EAAA,IAAA,CAAA;AACxC,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,OAAA,GAAU,IAAK,CAAA,OAAA,IAAW,MAAQ,EAAA,OAAA,CAAA;AAC7C,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,WAAA,GAAc,IAAK,CAAA,WAAA,IAAe,MAAQ,EAAA,WAAA,CAAA;AACrD,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,UAAA,GAAa,IAAK,CAAA,UAAA,IAAc,MAAQ,EAAA,UAAA,CAAA;AACnD,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,KAAA,GAAQ,IAAK,CAAA,KAAA,IAAS,MAAQ,EAAA,KAAA,CAAA;AACzC,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,YAAA,GAAe,IAAK,CAAA,YAAA,IAAgB,MAAQ,EAAA,YAAA,CAAA;AAEvD,IAAA,IAAA,CAAK,GAAM,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,GAAM,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,GAAM,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AACnC,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAC/B,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAE/B,IAAA,MAAA,CAAO,eAAe,IAAM,EAAA,OAAA,EAAS,EAAE,UAAA,EAAY,OAAO,CAAA,CAAA;AAC1D,IAAA,MAAA,CAAO,eAAe,IAAM,EAAA,YAAA,EAAc,EAAE,UAAA,EAAY,OAAO,CAAA,CAAA;AAAA,GACjE;AAAA,EAEA,eAAwC,GAAA;AACtC,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,KAAA,CAAA,CAAA;AAAA,GACd;AAAA,EAEA,GAAc,GAAA;AACZ,IAAA,MAAM,EAAE,OAAA,GAAU,EAAC,EAAG,SAAS,EAAC,EAAG,IAAO,GAAA,EAAI,EAAA,UAAA,GAAa,EAAC,KAAMA,cAAK,CAAA,IAAA,EAAA,KAAA,CAAA,CAAA;AACvE,IAAM,MAAA,GAAA,GAAM,KAAK,SAAU,CAAA,EAAE,SAAS,MAAQ,EAAA,IAAA,EAAM,YAAY,CAAA,CAAA;AAChE,IAAA,OAAO,SAAS,GAAG,CAAA,CAAA;AAAA,GACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,OAAsD,EAAA;AAC3D,IAAM,MAAA,IAAA,GAAO,OAAQ,CAAA,GAAA,CAAI,CAAC,KAAA,KAAU,MAAM,eAAgB,EAAA,CAAE,MAAU,IAAA,EAAE,CAAA,CAAA;AACxE,IAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,IAAA,EAAO,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,OAAsD,EAAA;AAC3D,IAAM,MAAA,IAAA,GAAO,OAAQ,CAAA,GAAA,CAAI,CAAC,KAAA,KAAU,MAAM,eAAgB,EAAA,CAAE,MAAU,IAAA,EAAE,CAAA,CAAA;AACxE,IAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,IAAA,EAAO,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,OAAsD,EAAA;AAC3D,IAAM,MAAA,IAAA,GAAO,OAAQ,CAAA,GAAA,CAAI,CAAC,KAAA,KAAU,MAAM,eAAgB,EAAA,CAAE,MAAU,IAAA,EAAE,CAAA,CAAA;AACxE,IAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,IAAA,EAAO,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,OAAsD,EAAA;AAC5D,IAAM,MAAA,KAAA,GAAQ,OAAQ,CAAA,GAAA,CAAI,CAAC,KAAA,KAAU,MAAM,eAAgB,EAAA,CAAE,MAAU,IAAA,EAAE,CAAA,CAAA;AACzE,IAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,KAAA,EAAQ,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GACnG;AAAA,EAkCA,MAAA,CAAO,GAAQ,CAAgC,EAAA;AAC7C,IAAI,IAAA,SAAA,CAAU,WAAW,CAAG,EAAA;AAC1B,MAAA,MAAM,WAAc,GAAA,MAAA,CAAO,OAAQ,CAAA,CAAA,IAAK,EAAE,CAAE,CAAA,GAAA,CAAI,CAAC,CAAC,MAAQ,EAAA,UAAU,CAAO,MAAA;AAAA,QACzE,CAAC,MAAM,GAAGC,iBAAK,CAAA,IAAA,EAAA,sBAAA,EAAA,wBAAA,CAAA,CAAL,WAA4B,MAAQ,EAAA,UAAA,CAAA;AAAA,OAC9C,CAAA,CAAA,CAAA;AACF,MAAA,MAAM,IAAO,GAAA,OAAA,CAAQ,CAACD,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAE,IAAK,EAAA,CAAE,MAAO,CAAA,WAAW,CAAC,CAAA,CAAA;AAEzE,MAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,IAAA,EAAO,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,KAC3F,MAAA;AACL,MAAA,MAAM,cAAc,SAAU,CAAA,CAAC,KAAK,SAAU,CAAA,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAGC,iBAAK,CAAA,IAAA,EAAA,sBAAA,EAAA,wBAAA,CAAA,CAAL,WAA4B,CAAG,EAAA,CAAA,CAAA,EAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClG,MAAA,MAAM,IAAO,GAAA,OAAA,CAAQ,CAACD,cAAA,CAAA,IAAA,EAAK,KAAM,CAAA,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAE,IAAK,EAAA,CAAE,MAAO,CAAA,WAAW,CAAC,CAAA,CAAA;AAEzE,MAAA,OAAO,IAAI,MAAA,CAAsBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,EAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,EAAE,MAAA,EAAQ,EAAE,IAAA,EAAO,EAAA,EAAGL,qBAAK,KAAK,CAAA,CAAA,CAAA;AAAA,KAClG;AAAA,GACF;AAAA,EA0BA,IAAA,CAAK,MAAgB,EAAA,SAAA,GAAY,KAA8B,EAAA;AAC7D,IAAM,MAAA,YAAA,GAAe,CAACA,cAAK,CAAA,IAAA,EAAA,KAAA,CAAA,CAAM,QAAQ,EAAE,EAAE,IAAK,EAAA,CAAA;AAClD,IAAA,MAAM,OAAO,CAAC,GAAG,cAAc,EAAE,MAAA,EAAQ,WAAW,CAAA,CAAA;AACpD,IAAO,OAAA,IAAI,MAAsB,CAAAA,cAAA,CAAA,IAAA,EAAK,WAAa,CAAA,EAAAA,cAAA,CAAA,IAAA,EAAKK,WAAQ,EAAE,IAAA,EAAQ,EAAAL,cAAA,CAAA,IAAA,EAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GACtF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAA6D,OAAc,EAAA;AACzE,IAAA,OAAO,IAAI,MAAA;AAAA,MACTA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA;AAAA,MACLA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA;AAAA,MACL,EAAE,OAAQ,EAAA;AAAA,MACVL,cAAK,CAAA,IAAA,EAAA,KAAA,CAAA;AAAA,KACP,CAAA;AAAA,GACF;AAAA,EA2BA,YAAA,CAAwC,OAAgC,GAAA,EAAmC,EAAA;AACzG,IAAM,MAAA,KAAA,GAAQ,IAAI,MAAsB,CAAAA,cAAA,CAAA,IAAA,EAAK,cAAaA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA,EAAQ,OAAS,EAAAL,cAAA,CAAA,IAAA,EAAK,KAAK,CAAA,CAAA,CAAA;AAC1F,IAAO,OAAAA,cAAA,CAAA,IAAA,EAAK,WAAY,CAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAA;AAAA,GACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,MAAO,CAAA,aAAa,CAAmC,GAAA;AAC7D,IAAiB,WAAA,MAAA,CAAC,MAAM,CAAK,IAAA,IAAA,CAAK,YAAY,EAAE,SAAA,EAAW,CAAE,EAAC,CAAG,EAAA;AAC/D,MAAM,MAAA,MAAA,CAAA;AAAA,KACR;AAAA,GACF;AAAA,EA6BA,OAAO,WAAA,CACL,OAAyD,GAAA,EAC/B,EAAA;AAC1B,IAAM,MAAA,EAAE,SAAY,GAAA,CAAA,EAAM,GAAA,OAAA,CAAA;AAE1B,IAAA,IAAI,IAAO,GAAA,MAAM,IAAK,CAAA,YAAA,CAAa,EAAE,GAAG,OAAA,EAAS,UAAY,EAAA,EAAE,IAAM,EAAA,SAAA,EAAW,MAAQ,EAAA,CAAA,IAAK,CAAA,CAAA;AAC7F,IAAI,IAAA,IAAA,GAAO,KAAK,WAAY,EAAA,CAAA;AAE5B,IAAA,MAAM,IAAK,CAAA,OAAA,CAAA;AAEX,IAAA,OAAO,IAAM,EAAA;AACX,MAAO,IAAA,GAAA,MAAM,KAAK,QAAS,EAAA,CAAA;AAC3B,MAAA,IAAA,GAAO,KAAK,WAAY,EAAA,CAAA;AAExB,MAAA,MAAM,IAAK,CAAA,OAAA,CAAA;AAAA,KACb;AAAA,GACF;AAAA,EAwBA,MAAM,OAAA,CAAmC,OAAgC,GAAA,EAAkC,EAAA;AACzG,IAAA,MAAM,EAAE,UAAa,GAAA,EAAI,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;AACrC,IAAA,MAAM,EAAE,IAAA,GAAO,uBAAyB,EAAA,MAAA,EAAW,GAAA,UAAA,CAAA;AACnD,IAAM,MAAA,SAAA,GAAY,IAAQ,IAAA,mBAAA,GAAsB,IAAO,GAAA,mBAAA,CAAA;AAEvD,IAAA,IAAI,IAAO,GAAA,MAAM,IAAK,CAAA,YAAA,CAAa,EAAE,GAAG,IAAM,EAAA,UAAA,EAAY,EAAE,IAAA,EAAM,SAAW,EAAA,MAAA,IAAU,CAAA,CAAA;AACvF,IAAA,MAAM,OAAU,GAAA,CAAC,GAAG,IAAA,CAAK,OAAO,CAAA,CAAA;AAEhC,IAAA,OAAO,IAAK,CAAA,WAAA,EAAiB,IAAA,OAAA,CAAQ,SAAS,IAAM,EAAA;AAClD,MAAO,IAAA,GAAA,MAAM,KAAK,QAAS,EAAA,CAAA;AAC3B,MAAQ,OAAA,CAAA,IAAA,CAAK,GAAG,IAAA,CAAK,OAAO,CAAA,CAAA;AAAA,KAC9B;AAEA,IAAA,IAAI,KAAK,WAAY,EAAA,IAAK,OAAQ,CAAA,UAAA,EAAY,SAAS,KAAW,CAAA,EAAA;AAChE,MAAA,OAAA,CAAQ,MAAM,0FAA0F,CAAA,CAAA;AAAA,KAC1G;AAEA,IAAM,MAAA,KAAA,GAAQ,IAAI,WAAY,CAAA,IAAA,EAAM,QAAQ,KAAM,CAAA,CAAA,EAAG,IAAI,CAAC,CAAA,CAAA;AAG1D,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAAA,EA2BA,MAAM,MAAA,CACJ,OAAyD,GAAA,EACtC,EAAA;AACnB,IAAA,MAAM,EAAE,SAAA,GAAY,mBAAqB,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;AACrD,IAAA,MAAM,UAAU,EAAC,CAAA;AAEjB,IAAiB,WAAA,MAAA,IAAA,IAAQ,KAAK,WAAY,CAAA,EAAE,GAAG,IAAM,EAAA,SAAA,EAAW,CAAG,EAAA;AACjE,MAAQ,OAAA,CAAA,IAAA,CAAK,GAAG,IAAI,CAAA,CAAA;AAAA,KACtB;AAGA,IAAO,OAAA,OAAA,CAAA;AAAA,GACT;AAAA,EAwBA,MAAM,QAAA,CAAoC,OAAgC,GAAA,EAA4B,EAAA;AACpG,IAAA,MAAM,OAAU,GAAA,MAAM,IAAK,CAAA,OAAA,CAAQ,EAAE,GAAG,OAAS,EAAA,UAAA,EAAY,EAAE,IAAA,EAAM,CAAE,EAAA,EAAG,CAAA,CAAA;AAG1E,IAAQ,OAAA,OAAA,CAAQ,CAAC,CAA2B,IAAA,IAAA,CAAA;AAAA,GAC9C;AAAA,EA2BA,MAAM,eAAA,CAA2C,OAAgC,GAAA,EAAqB,EAAA;AACpG,IAAA,MAAM,OAAU,GAAA,MAAM,IAAK,CAAA,OAAA,CAAQ,EAAE,GAAG,OAAS,EAAA,UAAA,EAAY,EAAE,IAAA,EAAM,CAAE,EAAA,EAAG,CAAA,CAAA;AAC1E,IAAI,IAAA,OAAA,CAAQ,CAAC,CAAM,KAAA,KAAA,CAAA;AAAW,MAAM,MAAA,IAAI,MAAM,mBAAmB,CAAA,CAAA;AAGjE,IAAA,OAAO,QAAQ,CAAC,CAAA,CAAA;AAAA,GAClB;AAAA,EAEA,MAAM,SAAA,CAGJ,MAAuD,GAAA,EAA2D,EAAA;AAClH,IAAA,MAAM,EAAE,SAAA,EAAW,eAAiB,EAAA,GAAG,SAAY,GAAA,MAAA,CAAA;AACnD,IAAA,MAAM,QAAQ,IAAI,MAAA;AAAA,MAChBA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA;AAAA,MACLA,cAAK,CAAA,IAAA,EAAAK,QAAA,CAAA;AAAA,MACL,OAAA;AAAA,MACAL,cAAK,CAAA,IAAA,EAAA,KAAA,CAAA;AAAA,KACP,CAAA;AAEA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,WAAA,CAAA,CAAY,cAAe,CAAA,KAAA,EAAO,WAAW,eAA2C,CAAA,CAAA;AAAA,GACtG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,GAAoC,EAAA;AACxC,IAAO,OAAA,IAAI,MAAsB,CAAAA,cAAA,CAAA,IAAA,EAAK,WAAa,CAAA,EAAAA,cAAA,CAAA,IAAA,EAAKK,QAAQ,CAAA,EAAA,EAAE,KAAO,EAAA,GAAA,EAAO,EAAAL,cAAA,CAAA,IAAA,EAAK,KAAK,CAAA,CAAA,CAAA;AAAA,GAC5F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAA,CAAS,MAAe,MAAgD,EAAA;AACtE,IAAO,OAAA,IAAA,CAAK,SAAU,CAAA,IAAA,EAAM,MAAM,CAAA,CAAA;AAAA,GACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAA,CAAa,MAAe,MAAgD,EAAA;AAC1E,IAAO,OAAA,IAAA,CAAK,SAAU,CAAA,IAAA,EAAM,MAAM,CAAA,CAAA;AAAA,GACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAA,CAAU,MAAe,MAAgD,EAAA;AACvE,IAAO,OAAA,IAAA,CAAK,aAAa,EAAE,UAAA,EAAY,EAAE,IAAM,EAAA,MAAA,IAAU,CAAA,CAAA;AAAA,GAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAA,CAAQ,MAAe,MAAgD,EAAA;AACrE,IAAO,OAAA,IAAA,CAAK,YAAa,CAAA,EAAE,UAAY,EAAA,EAAE,MAAM,MAAQ,EAAA,MAAA,EAAQ,KAAM,EAAA,EAAG,CAAA,CAAA;AAAA,GAC1E;AAAA;AAAA;AAAA;AAAA,EAKA,WAAuB,GAAA;AACrB,IAAO,OAAA,IAAA,CAAK,KAAK,IAAK,CAAA,IAAA,CAAA;AAAA,GACxB;AACF,CAAA,CAAA;AAzeEK,QAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,WAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,KAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAgJA,sBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,wBAAyB,GAAA,SAAC,QAAgB,KAAU,EAAA;AAClD,EAAA,MAAM,UAAa,GAAAL,cAAA,CAAA,IAAA,EAAKK,QAAO,CAAA,CAAA,MAAA,EAAQ,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAE,IAAK,EAAA,KAAM,IAAS,KAAA,MAAM,CAAG,EAAA,IAAA,CAAA;AAGpF,EAAA,IAAI,eAAe,UAAe,KAAA,QAAA,CAAS,KAAK,CAAK,IAAA,aAAA,CAAc,KAAK,CAAI,CAAA,EAAA;AAC1E,IAAO,OAAA,EAAE,WAAW,KAAM,EAAA,CAAA;AAAA,GAC5B;AAEA,EAAI,IAAA,UAAA,KAAe,UAAU,QAAS,CAAA,KAAK,KAAK,QAAS,CAAA,KAAA,CAAM,EAAE,CAAG,EAAA;AAClE,IAAA,OAAO,KAAM,CAAA,EAAA,CAAA;AAAA,GACf;AAEA,EAAO,OAAA,KAAA,CAAA;AACT,CAAA,CAAA;AAhKK,IAAM,KAAN,GAAA,OAAA;AA8eP,SAAS,WAAA,CACP,MACA,MACA,EAAA;AACA,EAAI,IAAA,yBAAA,CAA0B,IAAK,CAAA,UAAU,CAAG,EAAA;AAC9C,IAAA,OAAO,EAAE,GAAG,MAAA,EAAQ,IAAM,EAAA,KAAA,CAAA,EAAW,QAAQ,KAAU,CAAA,EAAA,CAAA;AAAA,GACzD;AAEA,EAAO,OAAA,MAAA,CAAA;AACT;;ACniBO,MAAM,iBAAoB,GAAA;AAAA,EAC/B,MAAA;AAAA,EACA,KAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,OAAA;AAAA,EACA,UAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA;AAAA,EACA,UAAA;AAAA,EACA,QAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,MAAA;AACF,EAAA;AA4IO,SAAS,eAAe,CAAqD,EAAA;AAClF,EAAA,OAAO,QAAS,CAAA,CAAC,CAAK,IAAA,QAAA,CAAU,GAA6B,EAAE,CAAA,CAAA;AACjE,CAAA;AAEO,SAAS,aAAa,CAAmD,EAAA;AAC9E,EAAA,MAAM,MAAS,GAAA,CAAA,CAAA;AACf,EAAM,MAAA,QAAA,GAAW,QAAQ,WAAY,EAAA,CAAA;AAErC,EAAO,OAAA,cAAA,CAAe,CAAC,CAAK,IAAA,QAAA,CAAS,QAAQ,CAAK,IAAA,OAAO,SAAS,OAAY,KAAA,QAAA,CAAA;AAChF;;ACxIO,SAAS,sBAAsB,MAA+C,EAAA;AACnF,EAAA,OAAO,QAAS,CAAA,MAAM,CAAK,IAAA,QAAA,CAAS,OAAO,IAAI,CAAA,CAAA;AACjD,CAAA;AAEO,SAAS,yBAAyB,OAAkD,EAAA;AACzF,EAAA,IAAI,CAAC,KAAA,CAAM,OAAQ,CAAA,OAAO,CAAG,EAAA;AAC3B,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAEA,EAAO,OAAA,OAAA,CAAQ,KAAM,CAAA,CAAC,MAAW,KAAA;AAC/B,IAAI,IAAA,OAAO,WAAW,QAAU,EAAA;AAC9B,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAEA,IAAI,IAAA,OAAO,WAAW,QAAU,EAAA;AAC9B,MAAA,OAAO,sBAAsB,MAAM,CAAA,CAAA;AAAA,KACrC;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACR,CAAA,CAAA;AACH;;ACjBO,SAAS,mBAAyC,KAAqC,EAAA;AAC5F,EAAA,OAAO,SAAS,KAAK,CAAA,CAAA;AACvB,CAAA;AAEO,SAAS,iBAAuC,MAAyD,EAAA;AAC9G,EAAA,OACE,QAAS,CAAA,MAAM,CACf,IAAA,MAAA,CAAO,OAAQ,CAAA,MAAM,CAAE,CAAA,KAAA,CAAM,CAAC,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AAE7C,IAAA,IAAI,GAAQ,KAAA,GAAA;AAAK,MAAA,OAAO,KAAU,KAAA,QAAA,CAAA;AAElC,IAAO,OAAA,KAAA,KAAU,SAAS,KAAU,KAAA,MAAA,CAAA;AAAA,GACrC,CAAA,CAAA;AAEL,CAAA;AAEO,SAAS,mBAAyC,MAA6D,EAAA;AACpH,EAAO,OAAA,QAAA,CAAS,MAAM,CAAK,IAAA,CAAC,iBAAiB,MAAM,CAAA,IAAK,OAAO,MAAW,KAAA,KAAA,CAAA,CAAA;AAC5E,CAAA;AAEO,SAAS,gBACd,MACuB,EAAA;AACvB,EAAI,IAAA,kBAAA,CAAmB,MAAM,CAAG,EAAA;AAC9B,IAAA,OAAO,EAAE,CAAC,MAAM,GAAG,KAAM,EAAA,CAAA;AAAA,GAChB,MAAA,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CAAG,EAAA;AAChC,IAAA,OAAO,OAAO,GAAI,CAAA,CAAC,IAAS,KAAA,eAAA,CAAgB,IAAI,CAAC,CAAA,CAAA;AAAA,GACnD,MAAA,IAAW,gBAAiB,CAAA,MAAM,CAAG,EAAA;AACnC,IAAO,OAAA,MAAA,CAAA;AAAA,GACT,MAAA,IAAW,kBAAmB,CAAA,MAAM,CAAG,EAAA;AACrC,IAAA,OAAO,EAAE,CAAC,MAAA,CAAO,MAAM,GAAG,MAAA,CAAO,aAAa,KAAM,EAAA,CAAA;AAAA,GAC/C,MAAA;AACL,IAAA,MAAM,IAAI,KAAA,CAAM,CAAwB,qBAAA,EAAA,MAAM,CAAE,CAAA,CAAA,CAAA;AAAA,GAClD;AACF;;;;;;;;;;;;;;;;;;;;;;;;ACtEA,IAAA,MAAA,EAAA,cAAA,EAAA,GAAA,EAAA,MAAA,EAAAC,eAAA,EAAA,MAAA,EAAA,sBAAA,EAAA,wBAAA,EAAA,mBAAA,EAAA,qBAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,mBAAA,EAAA,qBAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,mBAAA,EAAA,qBAAA,EAAA,aAAA,EAAA,eAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,cAAA,EAAA,gBAAA,EAAAC,kBAAA,EAAAC,oBAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA;AAwDA,MAAM,uBAA0B,GAAA,GAAA,CAAA;AAKzB,MAAe,mBAA8C,KAGlE,CAAA;AAwuBF,CAAA;AAEO,MAAM,uBACH,KAEV,CAAA;AAAA,EAQE,YAAY,OAKT,EAAA;AACD,IAAA,KAAA;AAAA,MACE,IAAA;AAAA,MACA,EAAE,IAAA,EAAM,OAAQ,CAAA,KAAA,EAAO,QAAQ,OAAQ,CAAA,YAAA,EAAc,IAAK,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,IAAS,KAAA,OAAA,CAAQ,KAAK,CAAE,EAAA;AAAA,MACnG,EAAC;AAAA,KACH,CAAA;AA0GF,IAAMX,cAAA,CAAA,IAAA,EAAA,sBAAA,CAAA,CAAA;AAmBN,IAAMA,cAAA,CAAA,IAAA,EAAA,mBAAA,CAAA,CAAA;AA2BN,IAAMA,cAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AA2UN,IAAMA,cAAA,CAAA,IAAA,EAAA,mBAAA,CAAA,CAAA;AAoCN,IAAMA,cAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AA2HN,IAAMA,cAAA,CAAA,IAAA,EAAA,mBAAA,CAAA,CAAA;AAuON,IAAMA,cAAA,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA;AA2BN,IAAMA,cAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AAoON,IAAMA,cAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AAIN,IAAMA,cAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AAeN,IAAMA,cAAA,CAAA,IAAA,EAAAU,kBAAA,CAAA,CAAA;AAYN,IAAMV,cAAA,CAAA,IAAA,EAAA,qBAAA,CAAA,CAAA;AAxpCN,IAAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,cAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,GAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAA,cAAA,CAAA,IAAA,EAAAS,eAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,IAAAT,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAcE,IAAAC,cAAA,CAAA,IAAA,EAAK,QAAS,OAAQ,CAAA,KAAA,CAAA,CAAA;AACtB,IAAAA,cAAA,CAAA,IAAA,EAAK,KAAM,OAAQ,CAAA,EAAA,CAAA,CAAA;AACnB,IAAKA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAS,QAAQ,aAAc,CAAA,KAAA,CAAA,CAAA;AACpC,IAAAA,cAAA,CAAA,IAAA,EAAKQ,iBAAgB,OAAQ,CAAA,YAAA,CAAA,CAAA;AAC7B,IAAKR,cAAA,CAAA,IAAA,EAAA,cAAA,EAAiB,OAAO,EAAE,GAAG,QAAQ,aAAe,EAAA,SAAA,EAAW,cAAe,EAAA,CAAA,CAAA,CAAA;AAEnF,IAAM,MAAA,KAAA,GAAQ,OAAQ,CAAA,aAAA,CAAc,KAAS,IAAA,YAAA,CAAA;AAC7C,IAAAA,cAAA,CAAA,IAAA,EAAK,QAAS,OACZ,IAAA,EACA,EACAW,EAAAA,QAAAA,GAA+B,EAC5B,KAAA;AACH,MAAO,OAAA,KAAA,CAAS,MAAM,EAAI,EAAA;AAAA,QACxB,GAAGA,QAAAA;AAAA,QACH,CAAC,eAAA,CAAgB,KAAK,GAAGT,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,QAC9B,CAAC,eAAgB,CAAA,IAAI,GAAG,eAAA;AAAA,QACxB,CAAC,eAAgB,CAAA,OAAO,GAAG,OAAA;AAAA,OAC5B,CAAA,CAAA;AAAA,KACH,CAAA,CAAA;AAAA,GACF;AAAA,EA6BA,MAAM,MAAA,CACJ,CAIA,EAAA,CAAA,EACA,GACA,CAMA,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,QAAA,EAAU,YAAY;AACvC,MAAA,MAAM,SAAY,GAAA,cAAA,CAAe,CAAG,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAGxC,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAE5B,QAAM,MAAA,GAAA,GAAM,MAAMC,iBAAK,CAAA,IAAA,EAAA,cAAA,EAAA,gBAAA,CAAA,CAAL,WAAoB,CAAG,EAAA,EAAE,SAAW,EAAA,UAAA,EAAY,IAAK,EAAA,CAAA,CAAA;AAEvE,QAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAK,CAAC,GAAG,CAAA,CAAA;AAGvD,QAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,KAAiB,OAAO,CAAA,CAAA;AACvD,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAGA,MAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAC9B,QAAA,IAAI,CAAM,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAErD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAO,OAAA,MAAMA,iBAAK,CAAA,IAAA,EAAA,mBAAA,EAAA,qBAAA,CAAA,CAAL,IAAyB,CAAA,IAAA,EAAA,CAAA,EAAG,GAA2B,OAAS,EAAA,EAAE,UAAY,EAAA,IAAA,EAAM,SAAU,EAAA,CAAA,CAAA;AAAA,OAC7G;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,QAAS,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACjC,QAAA,IAAI,EAAE,EAAO,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAExD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAA,OAAO,MAAMA,iBAAK,CAAA,IAAA,EAAA,mBAAA,EAAA,qBAAA,CAAA,CAAL,IAAyB,CAAA,IAAA,EAAA,CAAA,CAAE,IAAI,EAAE,GAAG,CAAG,EAAA,EAAA,EAAI,QAAa,EAAA,OAAA,EAAS,EAAE,UAAA,EAAY,MAAM,SAAU,EAAA,CAAA,CAAA;AAAA,OAC9G;AAGA,MAAI,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AACf,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAO,OAAAA,iBAAA,CAAA,IAAA,EAAK,sBAAL,EAAA,wBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAA4B,CAAG,EAAA,OAAA,CAAA,CAAA;AAAA,OACxC;AAEA,MAAM,MAAA,IAAI,MAAM,qCAAqC,CAAA,CAAA;AAAA,KACvD,CAAA,CAAA;AAAA,GACF;AAAA,EAwGA,MAAM,IACJ,CAAA,CAAA,EACA,CAOA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,MAAA,EAAQ,YAAY;AACrC,MAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAI,CAAC,GAAY,CAAA,CAAA;AAG/D,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAE5B,QAAA,MAAM,MAAM,CAAE,CAAA,GAAA,CAAI,CAAC,IAAS,KAAA,SAAA,CAAU,IAAI,CAAC,CAAA,CAAA;AAE3C,QAAA,MAAM,eAAe,MAAM,IAAA,CAAK,MAAO,CAAA,EAAE,QAAQ,EAAE,EAAA,EAAI,EAAE,IAAA,EAAM,QAAQ,GAAG,CAAA,EAAI,EAAA,EAAG,SAAS,CAAA,CAAA;AAG1F,QAAA,MAAM,UAAa,GAAA,YAAA,CAAa,MAAO,CAAA,CAAC,KAAK,MAAW,KAAA;AACtD,UAAI,GAAA,CAAA,MAAA,CAAO,EAAE,CAAI,GAAA,MAAA,CAAA;AACjB,UAAO,OAAA,GAAA,CAAA;AAAA,SACT,EAAG,EAAqB,CAAA,CAAA;AAExB,QAAO,OAAA,GAAA,CAAI,IAAI,CAACU,GAAAA,KAAO,WAAWA,GAAM,IAAA,EAAE,KAAK,IAAI,CAAA,CAAA;AAAA,OACrD;AAGA,MAAM,MAAA,EAAA,GAAK,UAAU,CAAC,CAAA,CAAA;AACtB,MAAA,IAAI,EAAI,EAAA;AACN,QAAI,IAAA;AACF,UAAM,MAAA,QAAA,GAAW,MAAM,SAAU,CAAA;AAAA,YAC/B,UAAY,EAAA;AAAA,cACV,SAAW,EAAA,eAAA;AAAA,cACX,YAAc,EAAA,YAAA;AAAA,cACd,MAAQ,EAAA,UAAA;AAAA,cACR,WAAWV,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,cAChB,QAAU,EAAA,EAAA;AAAA,aACZ;AAAA,YACA,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,YACvB,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,WACJ,CAAA,CAAA;AAED,UAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,UAAO,OAAA,UAAA;AAAA,YACLR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA;AAAA,YACL,YAAA;AAAA,YACAA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,YACL,QAAA;AAAA,YACA,OAAA;AAAA,WACF,CAAA;AAAA,iBACO,CAAG,EAAA;AACV,UAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,CAAA,CAAE,WAAW,GAAK,EAAA;AACnC,YAAO,OAAA,IAAA,CAAA;AAAA,WACT;AAEA,UAAM,MAAA,CAAA,CAAA;AAAA,SACR;AAAA,OACF;AAEA,MAAO,OAAA,IAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACF;AAAA,EAsBA,MAAM,WACJ,CAAA,CAAA,EACA,CAMA,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,aAAA,EAAe,YAAY;AAC5C,MAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,GAAU,CAAQ,CAAA,CAAA;AAEjD,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CAAG,EAAA;AACzB,QAAA,MAAM,UAAa,GAAA,OAAA;AAAA,UAChB,CACE,CAAA,MAAA,CAAO,CAAC,KAAA,EAAO,UAAU,MAAO,CAAA,KAAK,CAAM,KAAA,IAAI,EAC/C,GAAI,CAAA,CAAC,IAAS,KAAA,SAAA,CAAU,IAAI,CAAC,CAAA;AAAA,SAClC,CAAA;AAEA,QAAI,IAAA,UAAA,CAAW,SAAS,CAAG,EAAA;AACzB,UAAA,MAAM,IAAI,KAAM,CAAA,CAAA,iCAAA,EAAoC,WAAW,IAAK,CAAA,IAAI,CAAC,CAAE,CAAA,CAAA,CAAA;AAAA,SAC7E;AAEA,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAEA,MAAA,IAAI,WAAW,IAAM,EAAA;AACnB,QAAM,MAAA,EAAA,GAAK,SAAU,CAAA,CAAC,CAAK,IAAA,SAAA,CAAA;AAC3B,QAAA,MAAM,IAAI,KAAA,CAAM,CAAkB,eAAA,EAAA,EAAE,CAAY,UAAA,CAAA,CAAA,CAAA;AAAA,OAClD;AAEA,MAAO,OAAA,MAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACF;AAAA,EA6BA,MAAM,MAAA,CACJ,CAIA,EAAA,CAAA,EACA,GACA,CAOA,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,QAAA,EAAU,YAAY;AACvC,MAAA,MAAM,SAAY,GAAA,cAAA,CAAe,CAAG,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAGxC,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAG5B,QAAA,MAAM,WAAW,MAAM,IAAA,CAAK,KAAK,CAAG,EAAA,CAAC,IAAI,CAAC,CAAA,CAAA;AAC1C,QAAM,MAAA,OAAA,GAAU,EAAE,MAAO,CAAA,CAAC,OAAO,KAAU,KAAA,QAAA,CAAS,KAAK,CAAA,KAAM,IAAI,CAAA,CAAA;AAEnE,QAAM,MAAAC,iBAAA,CAAA,IAAA,EAAK,cAAL,EAAA,gBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAoB,OAAgE,EAAA;AAAA,UACxF,SAAA;AAAA,UACA,MAAQ,EAAA,KAAA;AAAA,SACV,CAAA,CAAA;AAEA,QAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAK,CAAC,GAAG,CAAA,CAAA;AAGvD,QAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,GAAG,OAAO,CAAA,CAAA;AACzC,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAEA,MAAI,IAAA;AAEF,QAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAC9B,UAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,UAAO,OAAA,MAAMA,wBAAK,mBAAL,EAAA,qBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAyB,GAAG,CAA2B,EAAA,OAAA,EAAS,EAAE,SAAU,EAAA,CAAA,CAAA;AAAA,SAC3F;AAGA,QAAA,IAAI,SAAS,CAAC,CAAA,IAAK,QAAS,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACjC,UAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,UAAA,OAAO,MAAMA,iBAAA,CAAA,IAAA,EAAK,mBAAL,EAAA,qBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAyB,EAAE,EAAI,EAAA,EAAE,GAAG,CAAA,EAAG,EAAI,EAAA,KAAA,CAAA,EAAa,EAAA,OAAA,EAAS,EAAE,SAAU,EAAA,CAAA,CAAA;AAAA,SAC5F;AAAA,eACO,KAAY,EAAA;AACnB,QAAA,IAAI,MAAM,MAAW,KAAA,GAAA;AAAK,UAAO,OAAA,IAAA,CAAA;AACjC,QAAM,MAAA,KAAA,CAAA;AAAA,OACR;AAEA,MAAM,MAAA,IAAI,MAAM,qCAAqC,CAAA,CAAA;AAAA,KACvD,CAAA,CAAA;AAAA,GACF;AAAA,EA6BA,MAAM,aAAA,CACJ,CAIA,EAAA,CAAA,EACA,GACA,CAMA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,eAAA,EAAiB,YAAY;AAC9C,MAAA,MAAM,SAAS,MAAM,IAAA,CAAK,OAAO,CAAU,EAAA,CAAA,EAAU,GAAU,CAAQ,CAAA,CAAA;AAEvE,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CAAG,EAAA;AACzB,QAAA,MAAM,UAAa,GAAA,OAAA;AAAA,UAChB,CACE,CAAA,MAAA,CAAO,CAAC,KAAA,EAAO,UAAU,MAAO,CAAA,KAAK,CAAM,KAAA,IAAI,EAC/C,GAAI,CAAA,CAAC,IAAS,KAAA,SAAA,CAAU,IAAI,CAAC,CAAA;AAAA,SAClC,CAAA;AAEA,QAAI,IAAA,UAAA,CAAW,SAAS,CAAG,EAAA;AACzB,UAAA,MAAM,IAAI,KAAM,CAAA,CAAA,iCAAA,EAAoC,WAAW,IAAK,CAAA,IAAI,CAAC,CAAE,CAAA,CAAA,CAAA;AAAA,SAC7E;AAEA,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAEA,MAAA,IAAI,WAAW,IAAM,EAAA;AACnB,QAAM,MAAA,EAAA,GAAK,SAAU,CAAA,CAAC,CAAK,IAAA,SAAA,CAAA;AAC3B,QAAA,MAAM,IAAI,KAAA,CAAM,CAAkB,eAAA,EAAA,EAAE,CAAY,UAAA,CAAA,CAAA,CAAA;AAAA,OAClD;AAEA,MAAO,OAAA,MAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACF;AAAA,EAqGA,MAAM,cAAA,CACJ,CACA,EAAA,CAAA,EACA,GACA,CAMA,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,gBAAA,EAAkB,YAAY;AAC/C,MAAA,MAAM,SAAY,GAAA,cAAA,CAAe,CAAG,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAGxC,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAE5B,QAAM,MAAAC,iBAAA,CAAA,IAAA,EAAK,cAAL,EAAA,gBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAoB,CAA0D,EAAA;AAAA,UAClF,SAAA;AAAA,UACA,MAAQ,EAAA,IAAA;AAAA,SACV,CAAA,CAAA;AAEA,QAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAK,CAAC,GAAG,CAAA,CAAA;AAGvD,QAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,GAAG,OAAO,CAAA,CAAA;AACzC,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAGA,MAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAC9B,QAAA,IAAI,CAAM,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAErD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAO,OAAA,MAAMA,wBAAK,mBAAL,EAAA,qBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAyB,GAAG,CAA2B,EAAA,OAAA,EAAS,EAAE,SAAU,EAAA,CAAA,CAAA;AAAA,OAC3F;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,QAAS,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACjC,QAAA,IAAI,EAAE,EAAO,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAExD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAA,OAAO,MAAMA,iBAAA,CAAA,IAAA,EAAK,mBAAL,EAAA,qBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAyB,EAAE,EAAI,EAAA,EAAE,GAAG,CAAA,EAAG,EAAI,EAAA,KAAA,CAAA,EAAa,EAAA,OAAA,EAAS,EAAE,SAAU,EAAA,CAAA,CAAA;AAAA,OAC5F;AAGA,MAAA,IAAI,CAAC,SAAU,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAChC,QAAA,OAAO,MAAM,IAAA,CAAK,MAAO,CAAA,CAAA,EAA2B,CAAQ,CAAA,CAAA;AAAA,OAC9D;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,CAAC,SAAU,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACnC,QAAA,OAAO,MAAM,IAAA,CAAK,MAAO,CAAA,CAAA,EAA2B,CAAQ,CAAA,CAAA;AAAA,OAC9D;AAEA,MAAM,MAAA,IAAI,MAAM,6CAA6C,CAAA,CAAA;AAAA,KAC/D,CAAA,CAAA;AAAA,GACF;AAAA,EAsDA,MAAM,eAAA,CACJ,CACA,EAAA,CAAA,EACA,GACA,CAMA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,iBAAA,EAAmB,YAAY;AAChD,MAAA,MAAM,SAAY,GAAA,cAAA,CAAe,CAAG,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAGxC,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAE5B,QAAM,MAAA,GAAA,GAAM,MAAMC,iBAAK,CAAA,IAAA,EAAA,cAAA,EAAA,gBAAA,CAAA,CAAL,WAAoB,CAAG,EAAA,EAAE,SAAW,EAAA,UAAA,EAAY,KAAM,EAAA,CAAA,CAAA;AAExE,QAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAK,CAAC,GAAG,CAAA,CAAA;AAGvD,QAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,KAAiB,OAAO,CAAA,CAAA;AACvD,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAGA,MAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAC9B,QAAA,IAAI,CAAM,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAErD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAO,OAAA,MAAMA,iBAAK,CAAA,IAAA,EAAA,mBAAA,EAAA,qBAAA,CAAA,CAAL,IAAyB,CAAA,IAAA,EAAA,CAAA,EAAG,GAA2B,OAAS,EAAA,EAAE,UAAY,EAAA,KAAA,EAAO,SAAU,EAAA,CAAA,CAAA;AAAA,OAC9G;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,QAAS,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACjC,QAAA,IAAI,EAAE,EAAO,KAAA,EAAA;AAAI,UAAM,MAAA,IAAI,MAAM,uBAAuB,CAAA,CAAA;AAExD,QAAA,MAAM,OAAU,GAAA,wBAAA,CAAyB,CAAC,CAAA,GAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAClD,QAAA,OAAO,MAAMA,iBAAK,CAAA,IAAA,EAAA,mBAAA,EAAA,qBAAA,CAAA,CAAL,IAAyB,CAAA,IAAA,EAAA,CAAA,CAAE,IAAI,EAAE,GAAG,CAAG,EAAA,EAAA,EAAI,QAAa,EAAA,OAAA,EAAS,EAAE,UAAA,EAAY,OAAO,SAAU,EAAA,CAAA,CAAA;AAAA,OAC/G;AAGA,MAAA,IAAI,CAAC,SAAU,CAAA,CAAC,CAAK,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AAChC,QAAA,OAAO,MAAM,IAAA,CAAK,MAAO,CAAA,CAAA,EAA2B,CAAQ,CAAA,CAAA;AAAA,OAC9D;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,CAAC,SAAU,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACnC,QAAA,OAAO,MAAM,IAAA,CAAK,MAAO,CAAA,CAAA,EAA2B,CAAQ,CAAA,CAAA;AAAA,OAC9D;AAEA,MAAM,MAAA,IAAI,MAAM,8CAA8C,CAAA,CAAA;AAAA,KAChE,CAAA,CAAA;AAAA,GACF;AAAA,EAwBA,MAAM,MACJ,CAAA,CAAA,EACA,CAOA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,QAAA,EAAU,YAAY;AAEvC,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAG,EAAA;AACpB,QAAA,IAAI,EAAE,MAAW,KAAA,CAAA;AAAG,UAAA,OAAO,EAAC,CAAA;AAE5B,QAAA,MAAM,GAAM,GAAA,CAAA,CAAE,GAAI,CAAA,CAAC,CAAM,KAAA;AACvB,UAAA,IAAI,SAAS,CAAC,CAAA;AAAG,YAAO,OAAA,CAAA,CAAA;AACxB,UAAI,IAAA,QAAA,CAAS,EAAE,EAAE,CAAA;AAAG,YAAA,OAAO,CAAE,CAAA,EAAA,CAAA;AAC7B,UAAM,MAAA,IAAI,MAAM,qCAAqC,CAAA,CAAA;AAAA,SACtD,CAAA,CAAA;AAED,QAAA,MAAM,UAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAK,CAAC,GAAG,CAAA,CAAA;AAGvD,QAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,IAAA,CAAK,GAAU,OAAO,CAAA,CAAA;AAEhD,QAAM,MAAAC,iBAAA,CAAA,IAAA,EAAK,kCAAL,IAAoB,CAAA,IAAA,EAAA,GAAA,CAAA,CAAA;AAE1B,QAAO,OAAA,MAAA,CAAA;AAAA,OACT;AAGA,MAAI,IAAA,QAAA,CAAS,CAAC,CAAG,EAAA;AACf,QAAO,OAAAA,iBAAA,CAAA,IAAA,EAAK,aAAL,EAAA,eAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAmB,CAAG,EAAA,CAAA,CAAA,CAAA;AAAA,OAC/B;AAGA,MAAA,IAAI,SAAS,CAAC,CAAA,IAAK,QAAS,CAAA,CAAA,CAAE,EAAE,CAAG,EAAA;AACjC,QAAA,OAAOA,iBAAK,CAAA,IAAA,EAAA,aAAA,EAAA,eAAA,CAAA,CAAL,IAAmB,CAAA,IAAA,EAAA,CAAA,CAAE,EAAI,EAAA,CAAA,CAAA,CAAA;AAAA,OAClC;AAEA,MAAM,MAAA,IAAI,MAAM,qCAAqC,CAAA,CAAA;AAAA,KACvD,CAAA,CAAA;AAAA,GACF;AAAA,EAwBA,MAAM,aACJ,CAAA,CAAA,EACA,CAMA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,eAAA,EAAiB,YAAY;AAC9C,MAAA,MAAM,MAAS,GAAA,MAAM,IAAK,CAAA,MAAA,CAAO,GAAU,CAAQ,CAAA,CAAA;AAEnD,MAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CAAG,EAAA;AACzB,QAAA,MAAM,UAAa,GAAA,OAAA;AAAA,UAChB,CACE,CAAA,MAAA,CAAO,CAAC,KAAA,EAAO,UAAU,MAAO,CAAA,KAAK,CAAM,KAAA,IAAI,EAC/C,GAAI,CAAA,CAAC,IAAS,KAAA,SAAA,CAAU,IAAI,CAAC,CAAA;AAAA,SAClC,CAAA;AAEA,QAAI,IAAA,UAAA,CAAW,SAAS,CAAG,EAAA;AACzB,UAAA,MAAM,IAAI,KAAM,CAAA,CAAA,iCAAA,EAAoC,WAAW,IAAK,CAAA,IAAI,CAAC,CAAE,CAAA,CAAA,CAAA;AAAA,SAC7E;AAEA,QAAO,OAAA,MAAA,CAAA;AAAA,OACT,MAAA,IAAW,WAAW,IAAM,EAAA;AAC1B,QAAM,MAAA,EAAA,GAAK,SAAU,CAAA,CAAC,CAAK,IAAA,SAAA,CAAA;AAC3B,QAAA,MAAM,IAAI,KAAA,CAAM,CAAkB,eAAA,EAAA,EAAE,CAAY,UAAA,CAAA,CAAA,CAAA;AAAA,OAClD;AAEA,MAAO,OAAA,MAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACF;AAAA,EAgDA,MAAM,MAAA,CACJ,KACA,EAAA,OAAA,GAQI,EACJ,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,QAAA,EAAU,YAAY;AACvC,MAAA,MAAM,EAAE,OAAA,EAAY,GAAA,MAAM,WAAY,CAAA;AAAA,QACpC,UAAY,EAAA;AAAA,UACV,SAAW,EAAA,eAAA;AAAA,UACX,YAAc,EAAA,YAAA;AAAA,UACd,MAAQ,EAAA,UAAA;AAAA,UACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,SAClB;AAAA,QACA,IAAM,EAAA;AAAA,UACJ,KAAA;AAAA,UACA,WAAW,OAAQ,CAAA,SAAA;AAAA,UACnB,QAAQ,OAAQ,CAAA,MAAA;AAAA,UAChB,WAAW,OAAQ,CAAA,SAAA;AAAA,UACnB,QAAQ,OAAQ,CAAA,MAAA;AAAA,UAChB,UAAU,OAAQ,CAAA,QAAA;AAAA,UAClB,MAAM,OAAQ,CAAA,IAAA;AAAA,UACd,QAAQ,OAAQ,CAAA,MAAA;AAAA,SAClB;AAAA,QACA,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,OACJ,CAAA,CAAA;AAED,MAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAG3B,MAAA,OAAO,OAAQ,CAAA,GAAA,CAAI,CAAC,IAAA,KAAS,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,YAAc,EAAAA,cAAA,CAAA,IAAA,EAAK,MAAQ,CAAA,EAAA,IAAA,EAAM,CAAC,GAAG,CAAC,CAAC,CAAA,CAAA;AAAA,KAC3F,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,MAAM,YAAA,CACJ,MACA,EAAA,KAAA,EACA,OAO0D,EAAA;AAC1D,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,cAAA,EAAgB,YAAY;AAC7C,MAAA,MAAM,EAAE,OAAA,EAAY,GAAA,MAAM,iBAAkB,CAAA;AAAA,QAC1C,UAAY,EAAA;AAAA,UACV,SAAW,EAAA,eAAA;AAAA,UACX,YAAc,EAAA,YAAA;AAAA,UACd,MAAQ,EAAA,UAAA;AAAA,UACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,SAClB;AAAA,QACA,IAAM,EAAA;AAAA,UACJ,MAAA;AAAA,UACA,WAAa,EAAA,KAAA;AAAA,UACb,oBAAoB,OAAS,EAAA,kBAAA;AAAA,UAC7B,MAAM,OAAS,EAAA,IAAA;AAAA,UACf,QAAQ,OAAS,EAAA,MAAA;AAAA,SACnB;AAAA,QACA,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,OACJ,CAAA,CAAA;AAED,MAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAG3B,MAAA,OAAO,OAAQ,CAAA,GAAA,CAAI,CAAC,IAAA,KAAS,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,YAAc,EAAAA,cAAA,CAAA,IAAA,EAAK,MAAQ,CAAA,EAAA,IAAA,EAAM,CAAC,GAAG,CAAC,CAAC,CAAA,CAAA;AAAA,KAC3F,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,MAAM,SACJ,CAAA,IAAA,EACA,MACA,EAAA;AACA,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,WAAA,EAAa,YAAY;AAC1C,MAAM,MAAA,MAAA,GAAS,MAAM,cAAe,CAAA;AAAA,QAClC,UAAY,EAAA;AAAA,UACV,SAAW,EAAA,eAAA;AAAA,UACX,YAAc,EAAA,YAAA;AAAA,UACd,MAAQ,EAAA,UAAA;AAAA,UACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,SAClB;AAAA,QACA,IAAA,EAAM,EAAE,IAAA,EAAM,MAA2C,EAAA;AAAA,QACzD,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,OACJ,CAAA,CAAA;AAED,MAAO,OAAA,MAAA,CAAA;AAAA,KACT,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,MAAM,MAAiC,KAA6D,EAAA;AAClG,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,OAAA,EAAS,YAAY;AACtC,MAAA,MAAM,UAAa,GAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,cAAA,EAAA,gBAAA,CAAA,CAAL,IAA4B,CAAA,IAAA,EAAA,KAAA,CAAA,CAAA;AACrD,MAAI,IAAA,UAAA;AAAY,QAAA,OAAO,IAAI,IAAqB,CAAA,KAAA,EAAO,UAAW,CAAA,IAAA,EAAM,WAAW,OAAO,CAAA,CAAA;AAE1F,MAAM,MAAA,IAAA,GAAO,MAAM,eAAgB,EAAA,CAAA;AAEnC,MAAA,MAAM,EAAE,IAAM,EAAA,OAAA,EAAS,OAAQ,EAAA,GAAI,MAAM,UAAW,CAAA;AAAA,QAClD,UAAY,EAAA;AAAA,UACV,SAAW,EAAA,eAAA;AAAA,UACX,YAAc,EAAA,YAAA;AAAA,UACd,MAAQ,EAAA,UAAA;AAAA,UACR,WAAWD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,SAClB;AAAA,QACA,IAAM,EAAA;AAAA,UACJ,MAAA,EAAQ,WAAY,CAAA,IAAA,CAAK,MAAM,CAAA;AAAA,UAC/B,MAAM,IAAK,CAAA,IAAA,KAAS,SAAY,eAAgB,CAAA,IAAA,CAAK,IAAI,CAAI,GAAA,KAAA,CAAA;AAAA,UAC7D,MAAM,IAAK,CAAA,UAAA;AAAA,UACX,OAAS,EAAA,IAAA,CAAK,OAAW,IAAA,CAAC,GAAG,CAAA;AAAA,UAC7B,aAAa,IAAK,CAAA,WAAA;AAAA,SACpB;AAAA,QACA,cAAc,IAAK,CAAA,YAAA;AAAA,QACnB,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,OACJ,CAAA,CAAA;AAED,MAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,MAAA,MAAM,UAAU,OAAQ,CAAA,GAAA;AAAA,QAAI,CAAC,MAC3B,KAAA,UAAA;AAAA,UACER,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA;AAAA,UACL,YAAA;AAAA,UACAA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,UACL,MAAA;AAAA,UACC,IAAA,CAAK,OAA0C,IAAA,CAAC,GAAG,CAAA;AAAA,SACtD;AAAA,OACF,CAAA;AACA,MAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,cAAA,EAAA,gBAAA,CAAA,CAAL,IAAoB,CAAA,IAAA,EAAA,KAAA,EAAO,IAAM,EAAA,OAAA,CAAA,CAAA;AAEvC,MAAA,OAAO,IAAI,IAAA,CAAqB,KAAO,EAAA,IAAA,EAAM,OAAO,CAAA,CAAA;AAAA,KACtD,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,MAAM,cAAA,CACJ,KACA,EAAA,SAAA,EACA,eACA,EAAA;AACA,IAAA,OAAOD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,CAAL,IAAY,CAAA,IAAA,EAAA,WAAA,EAAa,YAAY;AAC1C,MAAM,MAAA,IAAA,GAAO,MAAM,eAAgB,EAAA,CAAA;AAEnC,MAAM,MAAA,MAAA,GAAS,MAAM,cAAe,CAAA;AAAA,QAClC,UAAY,EAAA;AAAA,UACV,SAAW,EAAA,eAAA;AAAA,UACX,YAAc,EAAA,YAAA;AAAA,UACd,MAAQ,EAAA,UAAA;AAAA,UACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,SAClB;AAAA,QACA,IAAM,EAAA;AAAA,UACJ,MAAA,EAAQ,WAAY,CAAA,IAAA,CAAK,MAAM,CAAA;AAAA,UAC/B,MAAM,IAAK,CAAA,IAAA,KAAS,SAAY,eAAgB,CAAA,IAAA,CAAK,IAAI,CAAI,GAAA,KAAA,CAAA;AAAA,UAC7D,SAAS,IAAK,CAAA,OAAA;AAAA,UACd,aAAa,IAAK,CAAA,WAAA;AAAA,UAClB,IAAA,EAAM,IAAK,CAAA,UAAA,EAAY,IAAS,KAAA,KAAA,CAAA,GAAY,EAAE,IAAM,EAAA,IAAA,CAAK,UAAY,EAAA,IAAA,EAAS,GAAA,KAAA,CAAA;AAAA,UAC9E,SAAA;AAAA,UACA,eAAA;AAAA,SACF;AAAA,QACA,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,OACJ,CAAA,CAAA;AACD,MAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,MAAO,OAAA;AAAA,QACL,GAAG,MAAA;AAAA,QACH,SAAA,EAAW,OAAO,SAAU,CAAA,GAAA;AAAA,UAAI,CAAC,OAAA,KAC/B,UAAW,CAAAR,cAAA,CAAA,IAAA,EAAK,GAAK,CAAA,EAAA,YAAA,EAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,OAAS,EAAA,IAAA,CAAK,OAAW,IAAA,EAAE,CAAA;AAAA,SAC7E;AAAA,OACF,CAAA;AAAA,KACF,CAAA,CAAA;AAAA,GACF;AAAA,EAEA,GAAA,CAAI,UAAkB,OAAkF,EAAA;AAEtG,IAAM,MAAA,aAAA,GAAgB,SAAS,SAAY,GAAA,EAAE,SAAS,QAAS,EAAA,GAAI,EAAE,QAAS,EAAA,CAAA;AAC9E,IAAA,MAAM,MAAS,GAAA;AAAA,MACb,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,QACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,QAChB,WAAW,OAAS,EAAA,SAAA;AAAA,OACtB;AAAA,MACA,IAAM,EAAA;AAAA,QACJ,GAAG,aAAA;AAAA,QACH,OAAO,OAAS,EAAA,KAAA;AAAA,QAChB,YAAY,OAAS,EAAA,UAAA;AAAA,QACrB,MAAQ,EAAA,OAAA,EAAS,UAAe,KAAA,SAAA,GAAY,SAAS,MAAS,GAAA,KAAA,CAAA;AAAA,QAC9D,YAAc,EAAA,OAAA,EAAS,UAAe,KAAA,QAAA,GAAW,SAAS,YAAe,GAAA,KAAA,CAAA;AAAA,OAC3E;AAAA,MACA,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACL,CAAA;AAEA,IAAA,IAAI,SAAS,SAAW,EAAA;AACtB,MAAgB,eAAA,CAAA;AAAA,QACd,QAAU,EAAA,WAAA;AAAA,QACV,GAAK,EAAA,uDAAA;AAAA,QACL,MAAQ,EAAA,MAAA;AAAA,QACR,SAAA,EAAW,CAAC,OAAiD,KAAA;AAC3D,UAAQ,OAAA,CAAA,SAAA,GAAY,EAAE,MAAQ,EAAA,OAAA,CAAQ,MAAM,OAAS,EAAA,OAAA,CAAQ,SAAS,CAAA,CAAA;AAAA,SACxE;AAAA,QACA,GAAG,MAAA;AAAA,OACJ,CAAA,CAAA;AAAA,KACI,MAAA;AACL,MAAA,OAAO,gBAAgB,MAAa,CAAA,CAAA;AAAA,KACtC;AAAA,GACF;AAuEF,CAAA;AA9rCE,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,GAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACAM,eAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACA,MAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAsHM,sBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,wBAAA,GAAsB,eAAC,MAAA,EAA8B,OAAsC,GAAA,CAAC,GAAG,CAAG,EAAA;AACtG,EAAA,MAAM,MAAS,GAAA,MAAML,iBAAK,CAAA,IAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA,CAAL,IAA2B,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAEhD,EAAM,MAAA,QAAA,GAAW,MAAM,YAAa,CAAA;AAAA,IAClC,UAAY,EAAA;AAAA,MACV,SAAW,EAAA,eAAA;AAAA,MACX,YAAc,EAAA,YAAA;AAAA,MACd,MAAQ,EAAA,UAAA;AAAA,MACR,WAAWD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,KAClB;AAAA,IACA,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,IACvB,IAAM,EAAA,MAAA;AAAA,IACN,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,EAAA,OAAO,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,cAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,UAAU,OAAO,CAAA,CAAA;AAC1E,CAAA,CAAA;AAEM,mBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,qBAAmB,GAAA,eACvB,QACA,EAAA,MAAA,EACA,OAAsC,GAAA,CAAC,GAAG,CAC1C,EAAA,EAAE,UAAY,EAAA,SAAA,EACd,EAAA;AACA,EAAA,IAAI,CAAC,QAAA;AAAU,IAAO,OAAA,IAAA,CAAA;AAEtB,EAAA,MAAM,MAAS,GAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA,CAAL,IAA2B,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAEhD,EAAM,MAAA,QAAA,GAAW,MAAM,kBAAmB,CAAA;AAAA,IACxC,UAAY,EAAA;AAAA,MACV,SAAW,EAAA,eAAA;AAAA,MACX,YAAc,EAAA,YAAA;AAAA,MACd,MAAQ,EAAA,UAAA;AAAA,MACR,WAAWD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,MAChB,QAAA;AAAA,KACF;AAAA,IACA,IAAM,EAAA,MAAA;AAAA,IACN,WAAa,EAAA,EAAE,UAAY,EAAA,OAAA,EAAS,SAAU,EAAA;AAAA,IAC9C,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,EAAA,OAAO,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,cAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,UAAU,OAAO,CAAA,CAAA;AAC1E,CAAA,CAAA;AAEM,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,gBAAA,GAAc,eAClB,OAAA,EACA,EAAE,UAAA,EAAY,WACd,EAAA;AACA,EAAA,MAAM,UAAa,GAAA,MAAM,UAAW,CAAA,OAAA,EAAS,OAAO,MAAW,KAAA;AAC7D,IAAA,MAAM,MAAS,GAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA,CAAL,IAA2B,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAChD,IAAO,OAAA,EAAE,QAAQ,EAAE,KAAA,EAAOD,qBAAK,MAAQ,CAAA,EAAA,MAAA,EAAQ,UAAY,EAAA,SAAA,EAAY,EAAA,CAAA;AAAA,GACxE,CAAA,CAAA;AAED,EAAM,MAAA,iBAAA,GAA8C,KAAM,CAAA,UAAA,EAAY,uBAAuB,CAAA,CAAA;AAE7F,EAAA,MAAM,MAAM,EAAC,CAAA;AAEb,EAAA,KAAA,MAAWW,eAAc,iBAAmB,EAAA;AAC1C,IAAA,MAAM,EAAE,OAAA,EAAY,GAAA,MAAM,iBAAkB,CAAA;AAAA,MAC1C,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,OACV;AAAA,MACA,IAAA,EAAM,EAAE,UAAA,EAAAA,WAAW,EAAA;AAAA,MACnB,GAAGX,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAED,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC5B,MAAI,IAAA,MAAA,CAAO,cAAc,QAAU,EAAA;AACjC,QAAI,GAAA,CAAA,IAAA,CAAK,OAAO,EAAE,CAAA,CAAA;AAAA,OACb,MAAA;AACL,QAAA,GAAA,CAAI,KAAK,IAAI,CAAA,CAAA;AAAA,OACf;AAAA,KACF;AAAA,GACF;AAEA,EAAO,OAAA,GAAA,CAAA;AACT,CAAA,CAAA;AAySM,mBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,qBAAmB,GAAA,eACvB,UACA,MACA,EAAA,OAAA,GAAsC,CAAC,GAAG,CAAA,EAC1C,EAAE,SAAA,EACF,EAAA;AACA,EAAA,IAAI,CAAC,QAAA;AAAU,IAAO,OAAA,IAAA,CAAA;AAGtB,EAAM,MAAA,EAAE,IAAI,GAAK,EAAA,GAAG,QAAW,GAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA,CAAL,IAA2B,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAEhE,EAAI,IAAA;AACF,IAAM,MAAA,QAAA,GAAW,MAAM,kBAAmB,CAAA;AAAA,MACxC,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,QACR,WAAWD,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,QAChB,QAAA;AAAA,OACF;AAAA,MACA,WAAA,EAAa,EAAE,OAAA,EAAS,SAAU,EAAA;AAAA,MAClC,IAAM,EAAA,MAAA;AAAA,MACN,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAED,IAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,IAAA,OAAO,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,cAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,UAAU,OAAO,CAAA,CAAA;AAAA,WACjE,CAAG,EAAA;AACV,IAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,CAAA,CAAE,WAAW,GAAK,EAAA;AACnC,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAEA,IAAM,MAAA,CAAA,CAAA;AAAA,GACR;AACF,CAAA,CAAA;AAEM,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,gBAAA,GAAc,eAClB,OAAA,EACA,EAAE,SAAA,EAAW,QACb,EAAA;AACA,EAAM,MAAA,UAAA,GAAa,MAAM,UAAW,CAAA,OAAA,EAAS,OAAO,EAAE,EAAA,EAAI,GAAG,MAAA,EAAa,KAAA;AACxE,IAAA,MAAM,MAAS,GAAA,MAAMC,iBAAK,CAAA,IAAA,EAAA,qBAAA,EAAA,uBAAA,CAAA,CAAL,IAA2B,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA;AAChD,IAAO,OAAA,EAAE,MAAQ,EAAA,EAAE,KAAO,EAAAD,cAAA,CAAA,IAAA,EAAK,SAAQ,EAAI,EAAA,SAAA,EAAW,MAAQ,EAAA,MAAA,EAAS,EAAA,CAAA;AAAA,GACxE,CAAA,CAAA;AAED,EAAM,MAAA,iBAAA,GAA8C,KAAM,CAAA,UAAA,EAAY,uBAAuB,CAAA,CAAA;AAE7F,EAAA,MAAM,MAAM,EAAC,CAAA;AAEb,EAAA,KAAA,MAAWW,eAAc,iBAAmB,EAAA;AAC1C,IAAA,MAAM,EAAE,OAAA,EAAY,GAAA,MAAM,iBAAkB,CAAA;AAAA,MAC1C,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,OACV;AAAA,MACA,IAAA,EAAM,EAAE,UAAA,EAAAA,WAAW,EAAA;AAAA,MACnB,GAAGX,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAED,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC5B,MAAI,IAAA,MAAA,CAAO,cAAc,QAAU,EAAA;AACjC,QAAI,GAAA,CAAA,IAAA,CAAK,OAAO,EAAE,CAAA,CAAA;AAAA,OACb,MAAA;AACL,QAAA,GAAA,CAAI,KAAK,IAAI,CAAA,CAAA;AAAA,OACf;AAAA,KACF;AAAA,GACF;AAEA,EAAO,OAAA,GAAA,CAAA;AACT,CAAA,CAAA;AAyFM,mBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,qBAAmB,GAAA,eACvB,UACA,MACA,EAAA,OAAA,GAAsC,CAAC,GAAG,CAAA,EAC1C,EAAE,SAAA,EACF,EAAA;AACA,EAAA,IAAI,CAAC,QAAA;AAAU,IAAO,OAAA,IAAA,CAAA;AAEtB,EAAM,MAAA,QAAA,GAAW,MAAM,kBAAmB,CAAA;AAAA,IACxC,UAAY,EAAA;AAAA,MACV,SAAW,EAAA,eAAA;AAAA,MACX,YAAc,EAAA,YAAA;AAAA,MACd,MAAQ,EAAA,UAAA;AAAA,MACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,MAChB,QAAA;AAAA,KACF;AAAA,IACA,WAAA,EAAa,EAAE,OAAA,EAAS,SAAU,EAAA;AAAA,IAClC,IAAM,EAAA,MAAA;AAAA,IACN,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,EAAA,OAAO,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,cAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,UAAU,OAAO,CAAA,CAAA;AAC1E,CAAA,CAAA;AAgNM,aAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,eAAA,GAAa,eAAC,QAAA,EAAsB,OAAsC,GAAA,CAAC,GAAG,CAAG,EAAA;AACrF,EAAA,IAAI,CAAC,QAAA;AAAU,IAAO,OAAA,IAAA,CAAA;AAEtB,EAAI,IAAA;AACF,IAAM,MAAA,QAAA,GAAW,MAAM,YAAa,CAAA;AAAA,MAClC,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,QACR,WAAWA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA;AAAA,QAChB,QAAA;AAAA,OACF;AAAA,MACA,WAAA,EAAa,EAAE,OAAQ,EAAA;AAAA,MACvB,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAED,IAAM,MAAA,YAAA,GAAe,MAAMC,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,IAAA,OAAO,WAAWR,cAAK,CAAA,IAAA,EAAA,GAAA,CAAA,EAAK,cAAcA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,UAAU,OAAO,CAAA,CAAA;AAAA,WACjE,CAAG,EAAA;AACV,IAAA,IAAI,QAAS,CAAA,CAAC,CAAK,IAAA,CAAA,CAAE,WAAW,GAAK,EAAA;AACnC,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAEA,IAAM,MAAA,CAAA,CAAA;AAAA,GACR;AACF,CAAA,CAAA;AAEM,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,gBAAA,GAAc,eAAC,SAAyB,EAAA;AAC5C,EAAA,MAAM,iBAA8C,GAAA,KAAA;AAAA,IAClD,OAAQ,CAAA,SAAS,CAAE,CAAA,GAAA,CAAI,CAAC,EAAQ,MAAA,EAAE,MAAQ,EAAA,EAAE,KAAO,EAAAA,cAAA,CAAA,IAAA,EAAK,MAAQ,CAAA,EAAA,EAAA,IAAO,CAAA,CAAA;AAAA,IACvE,uBAAA;AAAA,GACF,CAAA;AAEA,EAAA,KAAA,MAAW,cAAc,iBAAmB,EAAA;AAC1C,IAAA,MAAM,iBAAkB,CAAA;AAAA,MACtB,UAAY,EAAA;AAAA,QACV,SAAW,EAAA,eAAA;AAAA,QACX,YAAc,EAAA,YAAA;AAAA,QACd,MAAQ,EAAA,UAAA;AAAA,OACV;AAAA,MACA,IAAA,EAAM,EAAE,UAAW,EAAA;AAAA,MACnB,GAAGA,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAAA,GACH;AACF,CAAA,CAAA;AAmNM,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,gBAAc,GAAA,eAAC,KAAkC,EAAA,IAAA,EAAuB,OAAsC,EAAA;AAClH,EAAA,MAAMA,qBAAK,MAAQ,CAAA,EAAA,GAAA,CAAI,SAASA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAM,IAAI,KAAM,CAAA,GAAA,EAAK,CAAA,CAAA,EAAI,EAAE,IAAM,kBAAA,IAAI,MAAQ,EAAA,IAAA,EAAM,SAAS,CAAA,CAAA;AACnG,CAAA,CAAA;AAEM,cAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,gBAAA,GAAoC,eACxC,KACyD,EAAA;AACzD,EAAA,MAAM,MAAM,CAAS,MAAA,EAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,CAAI,CAAA,EAAA,KAAA,CAAM,KAAK,CAAA,CAAA,CAAA;AAC/C,EAAA,MAAM,MAAS,GAAA,MAAMA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,IAAyD,GAAG,CAAA,CAAA;AAC9F,EAAA,IAAI,CAAC,MAAA;AAAQ,IAAO,OAAA,IAAA,CAAA;AAEpB,EAAM,MAAA,UAAA,GAAaA,cAAK,CAAA,IAAA,EAAA,MAAA,CAAA,EAAQ,eAAmB,IAAA,CAAA,CAAA,CAAA;AACnD,EAAA,MAAM,EAAE,KAAO,EAAA,GAAA,GAAM,UAAW,EAAA,GAAI,MAAM,eAAgB,EAAA,CAAA;AAC1D,EAAA,IAAI,GAAM,GAAA,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAEpB,EAAA,MAAM,aAAa,MAAO,CAAA,IAAA,CAAK,SAAY,GAAA,GAAA,GAAM,KAAK,GAAI,EAAA,CAAA;AAC1D,EAAA,OAAO,aAAa,IAAO,GAAA,MAAA,CAAA;AAC7B,CAAA,CAAA;AAEMO,kBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAAC,oBAAA,GAAgB,iBAA6B;AACjD,EAAA,IAAIR,cAAK,CAAA,IAAA,EAAAM,eAAA,CAAA;AAAe,IAAA,OAAON,cAAK,CAAA,IAAA,EAAAM,eAAA,CAAA,CAAA;AAEpC,EAAA,MAAM,EAAE,MAAA,EAAW,GAAA,MAAM,gBAAiB,CAAA;AAAA,IACxC,YAAY,EAAE,SAAA,EAAW,iBAAiB,YAAc,EAAA,YAAA,EAAc,QAAQ,UAAW,EAAA;AAAA,IACzF,GAAGN,qBAAK,cAAL,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAAF,cAAA,CAAA,IAAA,EAAKQ,iBAAgB,MAAO,CAAA,MAAA,CAAA,CAAA;AAC5B,EAAA,OAAO,MAAO,CAAA,MAAA,CAAA;AAChB,CAAA,CAAA;AAEM,qBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,uBAAA,GAAqB,eAAC,MAA+C,EAAA;AACzE,EAAM,MAAA,YAAA,GAAe,MAAML,iBAAA,CAAA,IAAA,EAAKM,kBAAL,EAAAC,oBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA;AAC3B,EAAM,MAAA,MAAA,GAAS,aAAa,IAAK,CAAA,CAAC,UAAU,KAAM,CAAA,IAAA,KAASR,qBAAK,MAAM,CAAA,CAAA,CAAA;AACtE,EAAA,IAAI,CAAC,MAAA;AAAQ,IAAA,MAAM,IAAI,KAAA,CAAM,CAAS,MAAA,EAAAA,cAAA,CAAA,IAAA,EAAK,OAAM,CAAsB,oBAAA,CAAA,CAAA,CAAA;AAEvE,EAAA,MAAM,SAA0B,EAAC,CAAA;AAEjC,EAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,MAAM,CAAG,EAAA;AAEjD,IAAA,IAAI,GAAQ,KAAA,MAAA;AAAQ,MAAA,SAAA;AAEpB,IAAM,MAAA,IAAA,GAAO,OAAO,OAAQ,CAAA,IAAA,CAAK,CAAC,MAAW,KAAA,MAAA,CAAO,IAAS,KAAA,GAAG,CAAG,EAAA,IAAA,CAAA;AAEnE,IAAA,QAAQ,IAAM;AAAA,MACZ,KAAK,MAAQ,EAAA;AACX,QAAA,MAAA,CAAO,GAAG,CAAI,GAAA,cAAA,CAAe,KAAK,CAAA,GAAI,MAAM,EAAK,GAAA,KAAA,CAAA;AACjD,QAAA,MAAA;AAAA,OACF;AAAA,MACA,KAAK,UAAY,EAAA;AACf,QAAA,MAAA,CAAO,GAAG,CAAI,GAAA,KAAA,YAAiB,IAAO,GAAA,KAAA,CAAM,aAAgB,GAAA,KAAA,CAAA;AAC5D,QAAA,MAAA;AAAA,OACF;AAAA,MACA,KAAK,CAAA,IAAA,CAAA;AACH,QAAA,MAAA,CAAO,GAAG,CAAA,GAAI,MAAM,mBAAA,CAAoB,KAAsB,CAAA,CAAA;AAC9D,QAAA,MAAA;AAAA,MACF,KAAK,QAAA;AACH,QAAO,MAAA,CAAA,GAAG,IAAI,MAAM,UAAA,CAAW,OAA0B,CAAC,IAAA,KAAS,mBAAoB,CAAA,IAAI,CAAC,CAAA,CAAA;AAC5F,QAAA,MAAA;AAAA,MACF,KAAK,MAAA;AACH,QAAO,MAAA,CAAA,GAAG,CAAI,GAAA,aAAA,CAAc,KAAY,CAAA,CAAA;AACxC,QAAA,MAAA;AAAA,MACF;AACE,QAAA,MAAA,CAAO,GAAG,CAAI,GAAA,KAAA,CAAA;AAAA,KAClB;AAAA,GACF;AAEA,EAAO,OAAA,MAAA,CAAA;AACT,CAAA,CAAA;AAGK,MAAM,aAAa,CACxB,EAAA,EACA,YACA,EAAA,KAAA,EACA,QACA,eACG,KAAA;AACH,EAAA,MAAM,OAA4B,EAAC,CAAA;AACnC,EAAA,MAAM,EAAE,IAAM,EAAA,GAAG,IAAK,EAAA,GAAI,UAAU,EAAC,CAAA;AACrC,EAAO,MAAA,CAAA,MAAA,CAAO,MAAM,IAAI,CAAA,CAAA;AAExB,EAAA,MAAM,EAAE,OAAA,EAAY,GAAA,YAAA,CAAa,IAAK,CAAA,CAAC,EAAE,IAAA,EAAW,KAAA,IAAA,KAAS,KAAK,CAAA,IAAK,EAAC,CAAA;AACxE,EAAA,IAAI,CAAC,OAAA;AAAS,IAAQ,OAAA,CAAA,KAAA,CAAM,CAAS,MAAA,EAAA,KAAK,CAAsB,oBAAA,CAAA,CAAA,CAAA;AAEhE,EAAW,KAAA,MAAA,MAAA,IAAU,OAAW,IAAA,EAAI,EAAA;AAElC,IAAI,IAAA,CAAC,aAAc,CAAA,eAAA,EAAiB,MAAM,CAAA;AAAG,MAAA,SAAA;AAE7C,IAAM,MAAA,KAAA,GAAQ,IAAK,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAE9B,IAAA,QAAQ,OAAO,IAAM;AAAA,MACnB,KAAK,UAAY,EAAA;AACf,QAAA,MAAM,OAAO,KAAU,KAAA,KAAA,CAAA,GAAY,IAAI,IAAA,CAAK,KAAe,CAAI,GAAA,IAAA,CAAA;AAE/D,QAAA,IAAI,SAAS,IAAQ,IAAA,KAAA,CAAM,IAAK,CAAA,OAAA,EAAS,CAAG,EAAA;AAC1C,UAAA,OAAA,CAAQ,MAAM,CAAwB,qBAAA,EAAA,KAAK,CAAc,WAAA,EAAA,MAAA,CAAO,IAAI,CAAE,CAAA,CAAA,CAAA;AAAA,SACjE,MAAA;AACL,UAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAI,GAAA,IAAA,CAAA;AAAA,SACtB;AAEA,QAAA,MAAA;AAAA,OACF;AAAA,MACA,KAAK,MAAQ,EAAA;AACX,QAAM,MAAA,SAAA,GAAY,OAAO,IAAM,EAAA,KAAA,CAAA;AAE/B,QAAA,IAAI,CAAC,SAAW,EAAA;AACd,UAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,+BAAA,EAAkC,MAAO,CAAA,IAAI,CAAE,CAAA,CAAA,CAAA;AAAA,SAC/D,MAAA,IAAW,QAAS,CAAA,KAAK,CAAG,EAAA;AAC1B,UAAA,MAAM,mBAAuB,GAAA,eAAA,CAA6B,MAAO,CAAA,CAAC,KAAK,IAAS,KAAA;AAC9E,YAAI,IAAA,IAAA,KAAS,OAAO,IAAM,EAAA;AACxB,cAAO,OAAA,CAAC,GAAG,GAAA,EAAK,GAAG,CAAA,CAAA;AAAA,aACrB;AAEA,YAAI,IAAA,QAAA,CAAS,IAAI,CAAK,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA,MAAA,CAAO,IAAI,CAAA,CAAA,CAAG,CAAG,EAAA;AACxD,cAAA,MAAM,GAAG,GAAG,IAAI,CAAI,GAAA,IAAA,CAAK,MAAM,GAAG,CAAA,CAAA;AAClC,cAAA,OAAO,CAAC,GAAG,GAAA,EAAK,IAAK,CAAA,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA;AAAA,aAChC;AAEA,YAAO,OAAA,GAAA,CAAA;AAAA,WACT,EAAG,EAAc,CAAA,CAAA;AAEjB,UAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAI,GAAA,UAAA;AAAA,YAClB,EAAA;AAAA,YACA,YAAA;AAAA,YACA,SAAA;AAAA,YACA,KAAA;AAAA,YACA,mBAAA;AAAA,WACF,CAAA;AAAA,SACK,MAAA;AACL,UAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAI,GAAA,IAAA,CAAA;AAAA,SACtB;AAEA,QAAA,MAAA;AAAA,OACF;AAAA,MACA,KAAK,MAAA;AACH,QAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAI,GAAA,SAAA,CAAU,KAAK,CAAI,GAAA,IAAI,QAAS,CAAA,KAAY,CAAI,GAAA,IAAA,CAAA;AACpE,QAAA,MAAA;AAAA,MACF,KAAK,QAAA;AACH,QAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAA,GAAK,KAA2B,EAAA,GAAA,CAAI,CAAC,IAAA,KAAS,IAAI,QAAA,CAAS,IAAI,CAAC,CAAK,IAAA,IAAA,CAAA;AACrF,QAAA,MAAA;AAAA,MACF,KAAK,MAAA;AACH,QAAA,IAAA,CAAK,MAAO,CAAA,IAAI,CAAI,GAAA,SAAA,CAAU,KAAe,CAAA,CAAA;AAC7C,QAAA,MAAA;AAAA,MACF;AACE,QAAK,IAAA,CAAA,MAAA,CAAO,IAAI,CAAA,GAAI,KAAS,IAAA,IAAA,CAAA;AAE7B,QAAA,IAAI,MAAO,CAAA,OAAA,KAAY,IAAQ,IAAA,KAAA,KAAU,IAAM,EAAA;AAC7C,UAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,oBAAA,EAAuB,MAAO,CAAA,IAAI,CAA0C,wCAAA,CAAA,CAAA,CAAA;AAAA,SAC5F;AACA,QAAA,MAAA;AAAA,KACJ;AAAA,GACF;AAEA,EAAM,MAAA,MAAA,GAAS,EAAE,GAAG,IAAK,EAAA,CAAA;AACzB,EAAA,MAAM,WACJ,IAAS,KAAA,KAAA,CAAA,GACL,EAAE,GAAG,IAAA,EAAM,WAAW,IAAI,IAAA,CAAK,IAAK,CAAA,SAAS,GAAG,SAAW,EAAA,IAAI,KAAK,IAAK,CAAA,SAAS,GAClF,GAAA,KAAA,CAAA,CAAA;AAEN,EAAO,MAAA,CAAA,IAAA,GAAO,SAAUY,QAAe,EAAA;AACrC,IAAA,OAAO,GAAG,KAAK,CAAA,CAAE,KAAK,MAAO,CAAA,IAAI,GAAaA,QAAO,CAAA,CAAA;AAAA,GACvD,CAAA;AAEA,EAAA,MAAA,CAAO,MAAS,GAAA,SAAUC,KAAW,EAAA,CAAA,EAAS,CAAS,EAAA;AACrD,IAAA,MAAMD,WAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAI,CAAC,GAAG,CAAA,CAAA;AACtD,IAAM,MAAA,SAAA,GAAY,cAAe,CAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAErC,IAAO,OAAA,EAAA,CAAG,KAAK,CAAA,CAAE,MAAO,CAAA,MAAA,CAAO,IAAI,CAAA,EAAaC,KAAMD,EAAAA,QAAAA,EAAS,EAAE,SAAA,EAAW,CAAA,CAAA;AAAA,GAC9E,CAAA;AAEA,EAAA,MAAA,CAAO,OAAU,GAAA,SAAUC,KAAW,EAAA,CAAA,EAAS,CAAS,EAAA;AACtD,IAAA,MAAMD,WAAU,wBAAyB,CAAA,CAAC,CAAI,GAAA,CAAA,GAAI,CAAC,GAAG,CAAA,CAAA;AACtD,IAAM,MAAA,SAAA,GAAY,cAAe,CAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAErC,IAAO,OAAA,EAAA,CAAG,KAAK,CAAA,CAAE,eAAgB,CAAA,MAAA,CAAO,IAAI,CAAA,EAAaC,KAAMD,EAAAA,QAAAA,EAAS,EAAE,SAAA,EAAW,CAAA,CAAA;AAAA,GACvF,CAAA;AAEA,EAAA,MAAA,CAAO,SAAS,WAAY;AAC1B,IAAA,OAAO,GAAG,KAAK,CAAA,CAAE,MAAO,CAAA,MAAA,CAAO,IAAI,CAAW,CAAA,CAAA;AAAA,GAChD,CAAA;AAEA,EAAA,IAAI,aAAa,KAAW,CAAA,EAAA;AAC1B,IAAO,MAAA,CAAA,IAAA,GAAO,MAAO,CAAA,MAAA,CAAO,QAAQ,CAAA,CAAA;AAAA,GACtC;AAEA,EAAA,MAAA,CAAO,cAAc,WAAY;AAC/B,IAAA,OAAO,MAAO,CAAA,IAAA,CAAA;AAAA,GAChB,CAAA;AAEA,EAAA,MAAA,CAAO,iBAAiB,WAAY;AAClC,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,SAAA,CAAU,MAAM,CAAC,CAAA,CAAA;AAAA,GAC1C,CAAA;AAEA,EAAA,MAAA,CAAO,WAAW,WAAY;AAC5B,IAAO,OAAA,IAAA,CAAK,UAAU,MAAM,CAAA,CAAA;AAAA,GAC9B,CAAA;AAEA,EAAW,KAAA,MAAA,IAAA,IAAQ,CAAC,MAAQ,EAAA,QAAA,EAAU,WAAW,QAAU,EAAA,aAAA,EAAe,gBAAkB,EAAA,UAAU,CAAG,EAAA;AACvG,IAAA,MAAA,CAAO,eAAe,MAAQ,EAAA,IAAA,EAAM,EAAE,UAAA,EAAY,OAAO,CAAA,CAAA;AAAA,GAC3D;AAEA,EAAA,MAAA,CAAO,OAAO,MAAM,CAAA,CAAA;AAEpB,EAAO,OAAA,MAAA,CAAA;AACT,CAAA,CAAA;AAEA,SAAS,UAAU,KAAoC,EAAA;AACrD,EAAA,IAAI,SAAS,KAAK,CAAA;AAAG,IAAO,OAAA,KAAA,CAAA;AAC5B,EAAA,IAAI,QAAS,CAAA,KAAK,CAAK,IAAA,QAAA,CAAS,MAAM,EAAE,CAAA;AAAG,IAAA,OAAO,KAAM,CAAA,EAAA,CAAA;AACxD,EAAO,OAAA,KAAA,CAAA,CAAA;AACT,CAAA;AAEA,SAAS,aAAA,CACP,SACA,MACA,EAAA;AAEA,EAAI,IAAA,OAAA,CAAQ,SAAS,GAAG,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAGlC,EAAA,OAAO,OAAQ,CAAA,MAAA,CAAO,CAAC,IAAA,KAAS,QAAS,CAAA,IAAI,CAAK,IAAA,IAAA,CAAK,UAAW,CAAA,MAAA,CAAO,IAAI,CAAC,EAAE,MAAS,GAAA,CAAA,CAAA;AAC3F,CAAA;AAEA,SAAS,kBAAkB,IAAiC,EAAA;AAC1D,EAAA,KAAA,MAAW,OAAO,IAAM,EAAA;AACtB,IAAA,IAAI,SAAS,GAAG,CAAA,IAAK,QAAS,CAAA,GAAA,CAAI,SAAS,CAAG,EAAA;AAC5C,MAAA,OAAO,GAAI,CAAA,SAAA,CAAA;AAAA,KACb;AAAA,GACF;AAEA,EAAO,OAAA,KAAA,CAAA,CAAA;AACT;;;;;;;;;;;;;;;;;;;;AC/oEA,IAAA,IAAA,CAAA;AAeO,MAAM,WAAiC,CAAA;AAAA,EAM5C,WAAA,CAAY,OAA8B,GAAA,EAAI,EAAA;AAL9C,IAAAf,cAAA,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAME,IAAKC,cAAA,CAAA,IAAA,EAAA,IAAA,sBAAW,GAAI,EAAA,CAAA,CAAA;AACpB,IAAK,IAAA,CAAA,QAAA,GAAW,QAAQ,GAAO,IAAA,GAAA,CAAA;AAC/B,IAAK,IAAA,CAAA,eAAA,GAAkB,OAAQ,CAAA,eAAA,IAAmB,EAAK,GAAA,GAAA,CAAA;AAAA,GACzD;AAAA,EAEA,MAAM,MAA2C,GAAA;AAC/C,IAAO,OAAA,MAAA,CAAO,WAAY,CAAAE,cAAA,CAAA,IAAA,EAAK,IAAI,CAAA,CAAA,CAAA;AAAA,GACrC;AAAA,EAEA,MAAM,IAAO,GAAgC,EAAA;AAC3C,IAAA,OAAQA,cAAK,CAAA,IAAA,EAAA,IAAA,CAAA,CAAK,GAAI,CAAA,GAAG,CAAK,IAAA,IAAA,CAAA;AAAA,GAChC;AAAA,EAEA,MAAM,GAAO,CAAA,GAAA,EAAa,KAAyB,EAAA;AACjD,IAAM,MAAA,IAAA,CAAK,OAAO,GAAG,CAAA,CAAA;AACrB,IAAKA,cAAA,CAAA,IAAA,EAAA,IAAA,CAAA,CAAK,GAAI,CAAA,GAAA,EAAK,KAAK,CAAA,CAAA;AAExB,IAAA,IAAIA,cAAK,CAAA,IAAA,EAAA,IAAA,CAAA,CAAK,IAAO,GAAA,IAAA,CAAK,QAAU,EAAA;AAClC,MAAA,MAAM,oBAAoBA,cAAK,CAAA,IAAA,EAAA,IAAA,CAAA,CAAK,IAAK,EAAA,CAAE,MAAO,CAAA,KAAA,CAAA;AAClD,MAAM,MAAA,IAAA,CAAK,OAAO,iBAAiB,CAAA,CAAA;AAAA,KACrC;AAAA,GACF;AAAA,EAEA,MAAM,OAAO,GAA4B,EAAA;AACvC,IAAKA,cAAA,CAAA,IAAA,EAAA,IAAA,CAAA,CAAK,OAAO,GAAG,CAAA,CAAA;AAAA,GACtB;AAAA,EAEA,MAAM,KAAuB,GAAA;AAC3B,IAAO,OAAAA,cAAA,CAAA,IAAA,EAAK,MAAK,KAAM,EAAA,CAAA;AAAA,GACzB;AACF,CAAA;AApCE,IAAA,GAAA,IAAA,OAAA,EAAA;;ACHK,MAAM,WAAc,GAAA,CAA2B,KAAuC,MAAA,EAAE,KAAK,KAAM,EAAA,EAAA;AAKnG,MAAM,EAAK,GAAA,YAAA;AAKX,MAAM,iBAAoB,GAAA,CAA2B,KAAuC,MAAA,EAAE,KAAK,KAAM,EAAA,EAAA;AAKzG,MAAM,aAAgB,GAAA,kBAAA;AAKtB,MAAM,GAAM,GAAA,kBAAA;AAKZ,MAAM,EAAK,GAAA,kBAAA;AAKX,MAAM,QAAW,GAAA,CAA2B,KAAuC,MAAA,EAAE,KAAK,KAAM,EAAA,EAAA;AAKhG,MAAM,EAAK,GAAA,SAAA;AAKX,MAAM,cAAiB,GAAA,CAA2B,KAAuC,MAAA,EAAE,KAAK,KAAM,EAAA,EAAA;AAKtG,MAAM,UAAa,GAAA,eAAA;AAKnB,MAAM,GAAM,GAAA,eAAA;AAKZ,MAAM,EAAK,GAAA,eAAA;AAKX,MAAM,MAAS,GAAA,CAAI,MAAmD,MAAA,EAAE,SAAS,MAAO,EAAA,EAAA;AAKxF,MAAM,SAAY,GAAA,CAAI,MAAmD,MAAA,EAAE,YAAY,MAAO,EAAA,EAAA;AAK9F,MAAM,UAAa,GAAA,CAAC,KAAqC,MAAA,EAAE,aAAa,KAAM,EAAA,EAAA;AAK9E,MAAM,QAAW,GAAA,CAAC,KAAqC,MAAA,EAAE,WAAW,KAAM,EAAA,EAAA;AAK1E,MAAM,OAAU,GAAA,CAAC,KAAqC,MAAA,EAAE,UAAU,KAAM,EAAA,EAAA;AAKxE,MAAM,QAAW,GAAA,CAAC,KAAqC,MAAA,EAAE,WAAW,KAAM,EAAA,EAAA;AAK1E,MAAM,EAAK,GAAA,CAAI,KAAiC,MAAA,EAAE,KAAK,KAAM,EAAA,EAAA;AAK7D,MAAM,MAAS,GAAA,GAAA;AAKf,MAAM,KAAQ,GAAA,CAAI,KAAiC,MAAA,EAAE,QAAQ,KAAM,EAAA,EAAA;AAKnE,MAAM,QAAW,GAAA,CAAC,KAAqC,MAAA,EAAE,WAAW,KAAM,EAAA,EAAA;AAK1E,MAAM,SAAY,GAAA,CAAC,KAAqC,MAAA,EAAE,YAAY,KAAM,EAAA,EAAA;AAK5E,MAAM,QAAW,GAAA,CAAI,KAA8B,MAAA,EAAE,WAAW,KAAM,EAAA,EAAA;AAKtE,MAAM,WAAc,GAAA,CAAI,KAA8B,MAAA,EAAE,cAAc,KAAM,EAAA,EAAA;AAK5E,MAAM,YAAe,GAAA,CAAI,KAA8B,MAAA,EAAE,eAAe,KAAM,EAAA,EAAA;AAK9E,MAAM,WAAc,GAAA,CAAI,KAA8B,MAAA,EAAE,cAAc,KAAM,EAAA;;;;;;;;;;;;;;;;;;;;AC/InF,IAAA,OAAA,EAAAM,eAAA,CAAA;AA2BO,MAAM,qBAAiE,UAAW,CAAA;AAAA,EAIvF,YAAY,YAAwB,EAAA;AAClC,IAAM,KAAA,EAAA,CAAA;AAJR,IAAAT,cAAA,CAAA,IAAA,EAAA,OAAA,EAA2C,EAAC,CAAA,CAAA;AAC5C,IAAAA,cAAA,CAAA,IAAA,EAAAS,eAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAKE,IAAAR,cAAA,CAAA,IAAA,EAAKQ,eAAgB,EAAA,YAAA,CAAA,CAAA;AAAA,GACvB;AAAA,EAEA,MAAM,aAA+D,EAAA;AACnE,IAAA,MAAM,KAAU,IAAI,KAAA;AAAA,MAClB,EAAC;AAAA,MACD;AAAA,QACE,GAAA,EAAK,CAAC,OAAA,EAAS,KAAU,KAAA;AACvB,UAAI,IAAA,CAAC,SAAS,KAAK,CAAA;AAAG,YAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA,CAAA;AAC1D,UAAA,IAAIN,cAAK,CAAA,IAAA,EAAA,OAAA,CAAA,CAAQ,KAAK,CAAA,KAAM,KAAW,CAAA,EAAA;AACrC,YAAAA,cAAA,CAAA,IAAA,EAAK,OAAQ,CAAA,CAAA,KAAK,CAAI,GAAA,IAAI,cAAe,CAAA,EAAE,EAAI,EAAA,aAAA,EAAe,KAAO,EAAA,YAAA,EAAcA,cAAK,CAAA,IAAA,EAAAM,eAAA,CAAA,EAAe,CAAA,CAAA;AAAA,WACzG;AAEA,UAAO,OAAAN,cAAA,CAAA,IAAA,EAAK,SAAQ,KAAK,CAAA,CAAA;AAAA,SAC3B;AAAA,OACF;AAAA,KACF,CAAA;AAGA,IAAM,MAAA,UAAA,GAAaA,cAAK,CAAA,IAAA,EAAAM,eAAA,CAAA,EAAe,GAAI,CAAA,CAAC,EAAE,IAAK,EAAA,KAAM,IAAI,CAAA,IAAK,EAAC,CAAA;AACnE,IAAA,KAAA,MAAW,SAAS,UAAY,EAAA;AAC9B,MAAG,EAAA,CAAA,KAAK,CAAI,GAAA,IAAI,cAAe,CAAA,EAAE,EAAI,EAAA,aAAA,EAAe,KAAO,EAAA,YAAA,EAAcN,cAAK,CAAA,IAAA,EAAAM,eAAA,CAAA,EAAe,CAAA,CAAA;AAAA,KAC/F;AAEA,IAAO,OAAA,EAAA,CAAA;AAAA,GACT;AACF,CAAA;AAhCE,OAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AACAA,eAAA,GAAA,IAAA,OAAA,EAAA;;ACqBK,MAAM,oBAAgE,UAAW,CAAA;AAAA,EACtF,MAAM,aAA8D,EAAA;AAClE,IAAO,OAAA;AAAA,MACL,QAAA,EAAU,OAAO,QAAiD,KAAA;AAChE,QAAM,MAAA,EAAE,OAAO,MAAQ,EAAA,MAAA,EAAQ,SAAS,EAAG,EAAA,GAAI,YAAY,EAAC,CAAA;AAE5D,QAAA,OAAO,MAAM,WAAY,CAAA;AAAA,UACvB,UAAY,EAAA;AAAA,YACV,SAAW,EAAA,eAAA;AAAA,YACX,YAAc,EAAA,YAAA;AAAA,YACd,MAAQ,EAAA,UAAA;AAAA,YACR,WAAW,KAAS,IAAA,EAAA;AAAA,YACpB,UAAU,MAAU,IAAA,EAAA;AAAA,YACpB,YAAY,MAAU,IAAA,EAAA;AAAA,YACtB,MAAA;AAAA,WACF;AAAA,UACA,GAAG,aAAA;AAAA,UACH,WAAa,EAAA,IAAA;AAAA,SACd,CAAA,CAAA;AAAA,OACH;AAAA,MACA,MAAQ,EAAA,OACN,QACA,EAAA,IAAA,EACA,OACG,KAAA;AACH,QAAM,MAAA,EAAE,OAAO,MAAQ,EAAA,MAAA,EAAQ,SAAS,EAAG,EAAA,GAAI,YAAY,EAAC,CAAA;AAC5D,QAAA,MAAM,eAAe,MAAM,IAAA,CAAA;AAC3B,QAAA,MAAM,WAAc,GAAA,OAAA,EAAS,SAAa,IAAA,cAAA,CAAe,YAAY,CAAA,CAAA;AACrE,QAAA,MAAM,IAAO,GAAA,YAAA,YAAwB,QAAW,GAAA,YAAA,CAAa,QAAY,GAAA,YAAA,CAAA;AAEzE,QAAA,OAAO,MAAM,WAAY,CAAA;AAAA,UACvB,GAAG,aAAA;AAAA,UACH,UAAY,EAAA;AAAA,YACV,SAAW,EAAA,eAAA;AAAA,YACX,YAAc,EAAA,YAAA;AAAA,YACd,MAAQ,EAAA,UAAA;AAAA,YACR,WAAW,KAAS,IAAA,EAAA;AAAA,YACpB,UAAU,MAAU,IAAA,EAAA;AAAA,YACpB,YAAY,MAAU,IAAA,EAAA;AAAA,YACtB,MAAA;AAAA,WACF;AAAA,UACA,IAAA;AAAA,UACA,OAAA,EAAS,EAAE,cAAA,EAAgB,WAAY,EAAA;AAAA,SACxC,CAAA,CAAA;AAAA,OACH;AAAA,MACA,MAAA,EAAQ,OAAO,QAAiD,KAAA;AAC9D,QAAM,MAAA,EAAE,OAAO,MAAQ,EAAA,MAAA,EAAQ,SAAS,EAAG,EAAA,GAAI,YAAY,EAAC,CAAA;AAE5D,QAAA,OAAO,MAAM,cAAe,CAAA;AAAA,UAC1B,UAAY,EAAA;AAAA,YACV,SAAW,EAAA,eAAA;AAAA,YACX,YAAc,EAAA,YAAA;AAAA,YACd,MAAQ,EAAA,UAAA;AAAA,YACR,WAAW,KAAS,IAAA,EAAA;AAAA,YACpB,UAAU,MAAU,IAAA,EAAA;AAAA,YACpB,YAAY,MAAU,IAAA,EAAA;AAAA,YACtB,MAAA;AAAA,WACF;AAAA,UACA,GAAG,aAAA;AAAA,SACJ,CAAA,CAAA;AAAA,OACH;AAAA,KACF,CAAA;AAAA,GACF;AACF,CAAA;AAEA,SAAS,eAAe,IAA0B,EAAA;AAChD,EAAI,IAAA,OAAO,SAAS,QAAU,EAAA;AAC5B,IAAO,OAAA,YAAA,CAAA;AAAA,GACT;AAGA,EAAA,IAAI,eAAe,IAAM,EAAA;AACvB,IAAA,OAAO,IAAK,CAAA,SAAA,CAAA;AAAA,GACd;AAEA,EAAI,IAAA,MAAA,CAAO,IAAI,CAAG,EAAA;AAChB,IAAA,OAAO,IAAK,CAAA,IAAA,CAAA;AAAA,GACd;AAEA,EAAI,IAAA;AAEF,IAAA,OAAQ,IAAa,CAAA,IAAA,CAAA;AAAA,WACd,CAAG,EAAA;AAAA,GAEZ;AAEA,EAAO,OAAA,0BAAA,CAAA;AACT;;;;;;;;;;;;;;;;;;;;;;;;ACzIA,IAAA,aAAA,EAAA,OAAA,EAAA,SAAA,EAAA,gBAAA,EAAA,kBAAA,CAAA;AA0DO,MAAM,qBAAiE,UAAW,CAAA;AAAA,EAGvF,WAAA,CAAoB,IAAiC,YAAwB,EAAA;AAC3E,IAAM,KAAA,EAAA,CAAA;AADY,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA,CAAA;AAsCpB,IAAMT,cAAA,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AAiBN,IAAMA,cAAA,CAAA,IAAA,EAAA,gBAAA,CAAA,CAAA;AAzDN,IAAAA,cAAA,CAAA,IAAA,EAAA,aAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AAIE,IAAAC,cAAA,CAAA,IAAA,EAAK,aAAgB,EAAA,YAAA,CAAA,CAAA;AAAA,GACvB;AAAA,EAEA,MAAM,aAA+D,EAAA;AACnE,IAAO,OAAA;AAAA,MACL,GAAK,EAAA,OAA2C,KAAe,EAAA,OAAA,GAA0C,EAAO,KAAA;AAC9G,QAAA,MAAM,UAAU,MAAMG,iBAAA,CAAA,IAAA,EAAK,OAAL,EAAA,SAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAa,OAAO,OAAS,EAAA,aAAA,CAAA,CAAA;AACnD,QAAA,MAAM,YAAe,GAAA,MAAMA,iBAAK,CAAA,IAAA,EAAA,gBAAA,EAAA,kBAAA,CAAA,CAAL,IAAsB,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA;AAEjD,QAAO,OAAA,OAAA,CAAQ,GAAI,CAAA,CAAC,MAAW,KAAA;AAC7B,UAAA,MAAM,EAAE,KAAA,GAAQ,QAAS,EAAA,GAAI,MAAO,CAAA,IAAA,CAAA;AAGpC,UAAA,OAAO,EAAE,KAAA,EAAO,MAAQ,EAAA,UAAA,CAAW,IAAK,CAAA,EAAA,EAAI,YAAc,EAAA,KAAA,EAAO,MAAQ,EAAA,CAAC,GAAG,CAAC,CAAE,EAAA,CAAA;AAAA,SACjF,CAAA,CAAA;AAAA,OACH;AAAA,MACA,OAAS,EAAA,OACP,KACA,EAAA,OAAA,GAA0C,EACvC,KAAA;AACH,QAAA,MAAM,UAAU,MAAMA,iBAAA,CAAA,IAAA,EAAK,OAAL,EAAA,SAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAa,OAAO,OAAS,EAAA,aAAA,CAAA,CAAA;AACnD,QAAA,MAAM,YAAe,GAAA,MAAMA,iBAAK,CAAA,IAAA,EAAA,gBAAA,EAAA,kBAAA,CAAA,CAAL,IAAsB,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA;AAEjD,QAAA,OAAO,OAAQ,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,MAAW,KAAA;AACrC,UAAA,MAAM,EAAE,KAAA,GAAQ,QAAS,EAAA,GAAI,MAAO,CAAA,IAAA,CAAA;AAEpC,UAAA,MAAM,KAAQ,GAAA,GAAA,CAAI,KAAK,CAAA,IAAK,EAAC,CAAA;AAE7B,UAAM,MAAA,IAAA,GAAO,WAAW,IAAK,CAAA,EAAA,EAAI,cAAc,KAAO,EAAA,MAAA,EAAQ,CAAC,GAAG,CAAC,CAAA,CAAA;AAEnE,UAAO,OAAA,EAAE,GAAG,GAAA,EAAK,CAAC,KAAK,GAAG,CAAC,GAAG,KAAO,EAAA,IAAI,CAAE,EAAA,CAAA;AAAA,SAC7C,EAAG,EAAS,CAAA,CAAA;AAAA,OACd;AAAA,KACF,CAAA;AAAA,GACF;AA8BF,CAAA;AApEE,aAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAwCM,OAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,SAA2C,GAAA,eAC/C,KACA,EAAA,OAAA,EACA,aACA,EAAA;AACA,EAAM,MAAA,EAAE,QAAQ,SAAW,EAAA,SAAA,EAAW,QAAQ,IAAK,EAAA,GAAI,WAAW,EAAC,CAAA;AAEnE,EAAA,MAAM,EAAE,OAAA,EAAY,GAAA,MAAM,YAAa,CAAA;AAAA,IACrC,YAAY,EAAE,SAAA,EAAW,iBAAiB,YAAc,EAAA,YAAA,EAAc,QAAQ,UAAW,EAAA;AAAA;AAAA,IAEzF,MAAM,EAAE,MAAA,EAAQ,OAAO,SAAW,EAAA,MAAA,EAAQ,WAAW,IAAK,EAAA;AAAA,IAC1D,GAAG,aAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAO,OAAA,OAAA,CAAA;AACT,CAAA,CAAA;AAEM,gBAAA,GAAA,IAAA,OAAA,EAAA,CAAA;AAAA,kBAAA,GAAgB,eAAC,aAAoD,EAAA;AACzE,EAAA,IAAID,cAAK,CAAA,IAAA,EAAA,aAAA,CAAA;AAAe,IAAA,OAAOA,cAAK,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA;AAEpC,EAAA,MAAM,EAAE,MAAA,EAAW,GAAA,MAAM,gBAAiB,CAAA;AAAA,IACxC,YAAY,EAAE,SAAA,EAAW,iBAAiB,YAAc,EAAA,YAAA,EAAc,QAAQ,UAAW,EAAA;AAAA,IACzF,GAAG,aAAA;AAAA,GACJ,CAAA,CAAA;AAED,EAAAF,cAAA,CAAA,IAAA,EAAK,eAAgB,MAAO,CAAA,MAAA,CAAA,CAAA;AAC5B,EAAA,OAAO,MAAO,CAAA,MAAA,CAAA;AAChB,CAAA;;AC3HF,SAAS,cAAc,qBAA+B,EAAA;AACpD,EAAM,MAAA,OAAA,GAAU,sBAAsB,OAAQ,CAAA,KAAA,EAAO,MAAM,CAAE,CAAA,OAAA,CAAQ,MAAM,KAAK,CAAA,CAAA;AAEhF,EAAA,OAAO,MAAM,OAAU,GAAA,GAAA,CAAA;AACzB,CAAA;AAEA,SAAS,YAA6B,GAAQ,EAAA;AAC5C,EAAA,IAAI,MAAS,GAAA,GAAA,CAAA;AACb,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,GAAA,CAAI,QAAQ,CAAK,EAAA,EAAA;AACnC,IAAA,IAAI,IAAI,CAAG,EAAA;AACT,MAAA,MAAA,GAAS,MAAS,GAAA,GAAA,CAAA;AAAA,KACpB;AACA,IAAI,IAAA,GAAA,CAAI,CAAC,CAAM,KAAA,IAAA,IAAQ,OAAO,GAAI,CAAA,CAAC,MAAM,WAAa,EAAA;AACpD,MAAA,MAAA,GAAS,MAAS,GAAA,MAAA,CAAA;AAAA,eACT,KAAM,CAAA,OAAA,CAAQ,GAAI,CAAA,CAAC,CAAC,CAAG,EAAA;AAChC,MAAA,MAAA,GAAS,MAAS,GAAA,WAAA,CAAY,GAAI,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,KAC3B,MAAA,IAAA,GAAA,CAAI,CAAC,CAAA,YAAa,MAAQ,EAAA;AACnC,MAAA,MAAA,IAAU,OAAU,GAAA,GAAA,CAAI,CAAC,CAAA,CAAE,SAAS,KAAK,CAAA,CAAA;AAAA,KACpC,MAAA;AACL,MAAA,MAAA,IAAU,aAAc,CAAA,YAAA,CAAa,GAAI,CAAA,CAAC,CAAC,CAAC,CAAA,CAAA;AAAA,KAC9C;AAAA,GACF;AACA,EAAA,MAAA,GAAS,MAAS,GAAA,GAAA,CAAA;AAClB,EAAO,OAAA,MAAA,CAAA;AACT,CAAA;AAGA,SAAS,aAAa,KAAgB,EAAA;AAEpC,EAAI,IAAA,CAAC,UAAU,KAAK,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAG9B,EAAA,IAAI,iBAAiB,IAAM,EAAA;AACzB,IAAA,OAAO,MAAM,WAAY,EAAA,CAAA;AAAA,GAC3B;AAGA,EAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;AACxB,IAAA,OAAO,YAAY,KAAK,CAAA,CAAA;AAAA,GAC1B;AAGA,EAAI,IAAA,QAAA,CAAS,KAAK,CAAG,EAAA;AACnB,IAAO,OAAA,IAAA,CAAK,UAAU,KAAK,CAAA,CAAA;AAAA,GAC7B;AAEA,EAAI,IAAA;AAEF,IAAA,OAAO,MAAM,QAAS,EAAA,CAAA;AAAA,WACf,CAAG,EAAA;AACV,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AACF,CAAA;AAEgB,SAAA,aAAA,CAAc,QAAkB,MAAgB,EAAA;AAC9D,EAAI,IAAA,QAAA,CAAS,MAAM,CAAG,EAAA;AACpB,IAAO,OAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,MAAQ,EAAA,MAAA,EAAQ,GAAI,CAAA,CAAC,KAAU,KAAA,YAAA,CAAa,KAAK,CAAC,CAAE,EAAA,CAAA;AAAA,GAClF;AAEA,EAAI,IAAA,aAAA,CAAc,MAAM,CAAG,EAAA;AACzB,IAAA,MAAM,YAAY,MAAO,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,MAAM,KAAU,KAAA;AACpD,MAAO,OAAA,GAAA,GAAM,QAAQ,KAAS,IAAA,MAAA,EAAQ,UAAU,CAAK,CAAA,GAAA,GAAA,IAAO,QAAQ,CAAK,CAAA,GAAA,EAAA,CAAA,CAAA;AAAA,OACxE,EAAE,CAAA,CAAA;AAEL,IAAO,OAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,MAAQ,EAAA,GAAA,CAAI,CAAC,KAAU,KAAA,YAAA,CAAa,KAAK,CAAC,CAAE,EAAA,CAAA;AAAA,GAC1E;AAEA,EAAI,IAAA,QAAA,CAAS,MAAM,CAAG,EAAA;AACpB,IAAA,MAAM,EAAE,SAAA,EAAW,MAAQ,EAAA,WAAA,EAAgB,GAAA,MAAA,CAAA;AAE3C,IAAO,OAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,MAAQ,EAAA,GAAA,CAAI,CAAC,KAAA,KAAU,YAAa,CAAA,KAAK,CAAC,CAAA,EAAG,WAAY,EAAA,CAAA;AAAA,GACvF;AAEA,EAAM,MAAA,IAAI,MAAM,eAAe,CAAA,CAAA;AACjC;;ACzDO,MAAM,kBAAkB,UAAW,CAAA;AAAA,EACxC,MAAM,aAAmD,EAAA;AACvD,IAAO,OAAA,OAAU,WAAqB,MAAkB,KAAA;AACtD,MAAA,MAAM,EAAE,SAAW,EAAA,MAAA,EAAQ,aAAgB,GAAA,aAAA,CAAc,QAAQ,MAAM,CAAA,CAAA;AAEvE,MAAA,MAAM,EAAE,OAAA,EAAS,OAAQ,EAAA,GAAI,MAAM,QAAS,CAAA;AAAA,QAC1C,YAAY,EAAE,SAAA,EAAW,iBAAiB,YAAc,EAAA,YAAA,EAAc,QAAQ,UAAW,EAAA;AAAA,QACzF,IAAM,EAAA,EAAE,SAAW,EAAA,MAAA,EAAQ,WAAY,EAAA;AAAA,QACvC,GAAG,aAAA;AAAA,OACJ,CAAA,CAAA;AAED,MAAO,OAAA,EAAE,SAAyB,OAAQ,EAAA,CAAA;AAAA,KAC5C,CAAA;AAAA,GACF;AACF;;ACtBO,MAAM,0BAAsE,UAAW,CAAA;AAAA,EAC5F,MAAM,aAAoE,EAAA;AACxE,IAAO,OAAA;AAAA,MACL,GAAA,EAAK,OACH,UACG,KAAA;AACH,QAAM,MAAA,QAAA,GAAW,MAAM,iBAAkB,CAAA;AAAA,UACvC,YAAY,EAAE,SAAA,EAAW,iBAAiB,YAAc,EAAA,YAAA,EAAc,QAAQ,UAAW,EAAA;AAAA,UACzF,IAAA,EAAM,EAAE,UAA8B,EAAA;AAAA,UACtC,GAAG,aAAA;AAAA,SACJ,CAAA,CAAA;AAED,QAAO,OAAA,QAAA,CAAA;AAAA,OACT;AAAA,KACF,CAAA;AAAA,GACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;ACOa,MAAA,WAAA,GAAc,CAAkD,OAAmB,KAAA;AAnChG,EAAA,IAAA,QAAA,EAAA,aAAA,EAAA,eAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,EAAA,CAAA;AAoCE,EAAM,OAAA,EAAA,GAAA,MAAA;AAAA,IASJ,WAAY,CAAA,OAAA,GAA6B,EAAC,EAAG,YAAgC,EAAA;AAsC7E,MAAA,YAAA,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA;AAgEA,MAAA,YAAA,CAAA,IAAA,EAAA,cAAA,CAAA,CAAA;AA9GA,MAAA,YAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AASE,MAAM,MAAA,WAAA,GAAc,eAAK,CAAA,IAAA,EAAA,aAAA,EAAA,eAAA,CAAA,CAAL,IAAmB,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AACvC,MAAA,YAAA,CAAA,IAAA,EAAK,QAAW,EAAA,WAAA,CAAA,CAAA;AAEhB,MAAA,MAAM,aAAmC,GAAA;AAAA,QACvC,GAAG,eAAK,CAAA,IAAA,EAAA,cAAA,EAAA,gBAAA,CAAA,CAAL,IAAoB,CAAA,IAAA,EAAA,WAAA,CAAA;AAAA,QACvB,OAAO,WAAY,CAAA,KAAA;AAAA,QACnB,MAAM,WAAY,CAAA,IAAA;AAAA,OACpB,CAAA;AAEA,MAAA,MAAM,KAAK,IAAI,YAAA,CAAa,YAAY,CAAA,CAAE,MAAM,aAAa,CAAA,CAAA;AAC7D,MAAA,MAAM,SAAS,IAAI,YAAA,CAAa,IAAI,YAAY,CAAA,CAAE,MAAM,aAAa,CAAA,CAAA;AACrE,MAAA,MAAM,YAAe,GAAA,IAAI,iBAAkB,EAAA,CAAE,MAAM,aAAa,CAAA,CAAA;AAChE,MAAA,MAAM,GAAM,GAAA,IAAI,SAAU,EAAA,CAAE,MAAM,aAAa,CAAA,CAAA;AAC/C,MAAA,MAAM,KAAQ,GAAA,IAAI,WAAY,EAAA,CAAE,MAAM,aAAa,CAAA,CAAA;AAGnD,MAAA,IAAA,CAAK,EAAK,GAAA,EAAA,CAAA;AACV,MAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AACd,MAAA,IAAA,CAAK,YAAe,GAAA,YAAA,CAAA;AACpB,MAAA,IAAA,CAAK,GAAM,GAAA,GAAA,CAAA;AACX,MAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AAEb,MAAW,KAAA,MAAA,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAQ,CAAA,OAAA,IAAW,EAAE,CAAG,EAAA;AAC5D,QAAA,IAAI,SAAc,KAAA,KAAA,CAAA;AAAW,UAAA,SAAA;AAG7B,QAAA,IAAA,CAAK,GAAG,CAAA,GAAI,SAAU,CAAA,KAAA,CAAM,aAAa,CAAA,CAAA;AAAA,OAC3C;AAAA,KACF;AAAA,IAEA,MAAa,SAAY,GAAA;AACvB,MAAM,MAAA,WAAA,GAAc,mBAAK,QAAS,CAAA,CAAA,WAAA,CAAA;AAClC,MAAM,MAAA,MAAA,GAAS,mBAAK,QAAS,CAAA,CAAA,MAAA,CAAA;AAE7B,MAAO,OAAA,EAAE,aAAa,MAAO,EAAA,CAAA;AAAA,KAC/B;AAAA,GA5CA,EAAA,QAAA,GAAA,IAAA,OAAA,EAAA,EA8CA,aAAa,GAAA,IAAA,OAAA,EAAA,EAAA,eAAA,GAAA,SAAC,OAA0C,EAAA;AAEtD,IAAA,MAAM,aAAgB,GAAA,OAAA,EAAS,aAAiB,IAAA,wBAAA,EAA8B,IAAA,KAAA,CAAA;AAE9E,IAAA,MAAM,SAAY,GAAA,OAAO,MAAW,KAAA,WAAA,IAAe,OAAO,IAAS,KAAA,WAAA,CAAA;AACnE,IAAI,IAAA,SAAA,IAAa,CAAC,aAAe,EAAA;AAC/B,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,+OAAA;AAAA,OACF,CAAA;AAAA,KACF;AAEA,IAAM,MAAA,KAAA,GAAQ,sBAAuB,CAAA,OAAA,EAAS,KAAK,CAAA,CAAA;AACnD,IAAM,MAAA,WAAA,GAAc,OAAS,EAAA,WAAA,IAAe,cAAe,EAAA,CAAA;AAC3D,IAAM,MAAA,MAAA,GAAS,OAAS,EAAA,MAAA,IAAU,SAAU,EAAA,CAAA;AAC5C,IAAM,MAAA,KAAA,GAAQ,SAAS,KAAS,IAAA,IAAI,YAAY,EAAE,eAAA,EAAiB,GAAG,CAAA,CAAA;AACtE,IAAM,MAAA,KAAA,GAAQ,SAAS,KAAS,IAAA,YAAA,CAAA;AAChC,IAAA,MAAM,aAAa,OAAS,EAAA,UAAA,CAAA;AAC5B,IAAM,MAAA,IAAA,GAAO,SAAS,IAAQ,IAAA,YAAA,CAAA;AAC9B,IAAA,MAAM,iBAAiB,OAAS,EAAA,cAAA,CAAA;AAEhC,IAAA,IAAI,CAAC,MAAQ,EAAA;AACX,MAAM,MAAA,IAAI,MAAM,2BAA2B,CAAA,CAAA;AAAA,KAC7C;AAEA,IAAA,IAAI,CAAC,WAAa,EAAA;AAChB,MAAM,MAAA,IAAI,MAAM,gCAAgC,CAAA,CAAA;AAAA,KAClD;AAEA,IAAA,MAAM,YAAY,SAAU,EAAA,CAAA;AAC5B,IAAA,MAAM,gBAAgB,gBAAiB,EAAA,CAAA;AACvC,IAAA,MAAM,MAAS,GAAA,OAAA,EAAS,MAAU,IAAA,aAAA,IAAiB,SAAa,IAAA,MAAA,CAAA;AAChE,IAAA,IAAI,CAAC,CAAC,aAAiB,IAAA,MAAA,KAAW,aAAe,EAAA;AAC/C,MAAQ,OAAA,CAAA,IAAA;AAAA,QACN,CAAA,wBAAA,EAA2B,aAAa,CAAA,uEAAA,EAA0E,MAAM,CAAA,CAAA;AAAA,OAC1H,CAAA;AAAA,KACS,MAAA,IAAA,CAAC,CAAC,SAAA,IAAa,WAAW,SAAW,EAAA;AAC9C,MAAQ,OAAA,CAAA,IAAA;AAAA,QACN,CAAA,gBAAA,EAAmB,SAAS,CAAA,uEAAA,EAA0E,MAAM,CAAA,CAAA;AAAA,OAC9G,CAAA;AAAA,KACF,MAAA,IAAW,CAAC,CAAC,aAAA,IAAiB,CAAC,CAAC,SAAA,IAAa,kBAAkB,SAAW,EAAA;AACxE,MAAQ,OAAA,CAAA,IAAA;AAAA,QACN,CAA2B,wBAAA,EAAA,aAAa,CAAe,YAAA,EAAA,SAAS,0EAA0E,MAAM,CAAA,CAAA;AAAA,OAClJ,CAAA;AAAA,eACS,CAAC,aAAA,IAAiB,CAAC,SAAa,IAAA,OAAA,EAAS,WAAW,KAAW,CAAA,EAAA;AACxE,MAAQ,OAAA,CAAA,IAAA;AAAA,QACN,wEAAwE,MAAM,CAAA,6HAAA,CAAA;AAAA,OAChF,CAAA;AAAA,KACF;AAEA,IAAO,OAAA;AAAA,MACL,KAAA;AAAA,MACA,WAAA;AAAA,MACA,MAAA;AAAA,MACA,MAAA;AAAA,MACA,KAAA;AAAA,MACA,KAAA;AAAA,MACA,IAAA;AAAA,MACA,UAAU,YAAa,EAAA;AAAA,MACvB,aAAA;AAAA,MACA,UAAA;AAAA,MACA,cAAA;AAAA,KACF,CAAA;AAAA,GACF,EAEA,mDAAc,SAAC;AAAA,IACb,KAAA;AAAA,IACA,MAAA;AAAA,IACA,WAAA;AAAA,IACA,MAAA;AAAA,IACA,KAAA;AAAA,IACA,QAAA;AAAA,IACA,UAAA;AAAA,IACA,cAAA;AAAA,GAC6B,EAAA;AAC7B,IAAO,OAAA;AAAA,MACL,KAAA;AAAA,MACA,MAAA;AAAA,MACA,MAAQ,EAAA,EAAA;AAAA;AAAA,MAER,gBAAA,EAAkB,CAAC,IAAA,EAAM,MAAW,KAAA;AAClC,QAAM,MAAA,SAAA,GAAY,MAAO,CAAA,YAAA,IAAgB,MAAO,CAAA,MAAA,CAAA;AAChD,QAAM,MAAA,OAAA,GAAU,KAAK,OAAQ,CAAA,cAAA,EAAgB,cAAc,KAAY,CAAA,GAAA,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,GAAK,EAAE,CAAA,CAAA;AACxF,QAAA,OAAO,WAAc,GAAA,OAAA,CAAA;AAAA,OACvB;AAAA,MACA,KAAA;AAAA,MACA,QAAA;AAAA,MACA,UAAA;AAAA,MACA,cAAA;AAAA,KACF,CAAA;AAAA,GAvIJ,EAAA,EAAA,CAAA;AAAA,EAAA;AAmKW,MAAA,UAAA,SAAmB,aAAmC,CAAA;AAAC;;AClMpE,MAAM,IAAO,GAAA,IAAA,CAAA;AACb,MAAM,KAAQ,GAAA,KAAA,CAAA;AAGP,MAAM,UAAW,CAAA;AAAA,EAAjB,WAAA,GAAA;AACL,IAAA,IAAA,CAAA,OAAA,GAA+B,EAAC,CAAA;AAAA,GAAA;AAAA,EAEhC,IAAI,KAAY,EAAA;AACd,IAAK,IAAA,CAAA,OAAA,CAAQ,KAAM,CAAA,IAAI,CAAI,GAAA,KAAA,CAAA;AAAA,GAC7B;AAAA,EAEA,OAAU,IAAiB,EAAA;AAKzB,IAAA,SAAS,MAAM,GAAe,EAAA;AAC5B,MAAI,IAAA,KAAA,CAAM,QAAQ,GAAG,CAAA;AAAG,QAAO,OAAA,GAAA,CAAI,IAAI,KAAK,CAAA,CAAA;AAE5C,MAAA,MAAM,OAAO,OAAO,GAAA,CAAA;AACpB,MAAA,IAAI,IAAS,KAAA,WAAA;AAAa,QAAA,OAAO,EAAE,CAAC,IAAI,GAAG,WAAY,EAAA,CAAA;AACvD,MAAA,IAAI,IAAS,KAAA,QAAA;AAAU,QAAO,OAAA,EAAE,CAAC,IAAI,GAAG,QAAA,EAAU,CAAC,KAAK,GAAG,GAAI,CAAA,QAAA,EAAW,EAAA,CAAA;AAC1E,MAAI,IAAA,GAAA,KAAQ,QAAQ,IAAS,KAAA,QAAA;AAAU,QAAO,OAAA,GAAA,CAAA;AAE9C,MAAA,MAAM,cAAc,GAAI,CAAA,WAAA,CAAA;AACxB,MAAA,MAAM,IAAyB,EAAE,CAAC,IAAI,GAAG,YAAY,IAAK,EAAA,CAAA;AAC1D,MAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,GAAG,CAAG,EAAA;AAC9C,QAAE,CAAA,CAAA,GAAG,CAAI,GAAA,KAAA,CAAM,KAAK,CAAA,CAAA;AAAA,OACtB;AACA,MAAA,IAAI,WAAgB,KAAA,IAAA;AAAM,QAAE,CAAA,CAAA,KAAK,CAAI,GAAA,GAAA,CAAI,WAAY,EAAA,CAAA;AACrD,MAAA,IAAI,WAAgB,KAAA,GAAA;AAAK,QAAA,CAAA,CAAE,KAAK,CAAA,GAAI,MAAO,CAAA,WAAA,CAAY,GAAG,CAAA,CAAA;AAC1D,MAAA,IAAI,WAAgB,KAAA,GAAA;AAAK,QAAA,CAAA,CAAE,KAAK,CAAA,GAAI,CAAC,GAAG,GAAG,CAAA,CAAA;AAC3C,MAAO,OAAA,CAAA,CAAA;AAAA,KACT;AAEA,IAAA,OAAO,IAAK,CAAA,SAAA,CAAU,KAAM,CAAA,IAAI,CAAC,CAAA,CAAA;AAAA,GACnC;AAAA,EAEA,SAAY,IAAiB,EAAA;AAC3B,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAM,EAAA,CAAC,KAAK,KAAU,KAAA;AAEtC,MAAI,IAAA,KAAA,IAAS,OAAO,KAAU,KAAA,QAAA,IAAY,CAAC,KAAM,CAAA,OAAA,CAAQ,KAAK,CAAG,EAAA;AAC/D,QAAM,MAAA,EAAE,CAAC,IAAI,GAAG,KAAA,EAAO,CAAC,KAAK,GAAG,GAAA,EAAK,GAAG,IAAA,EAAS,GAAA,KAAA,CAAA;AACjD,QAAM,MAAA,WAAA,GAAc,IAAK,CAAA,OAAA,CAAQ,KAAK,CAAA,CAAA;AAGtC,QAAA,IAAI,WAAa,EAAA;AACf,UAAA,OAAO,OAAO,MAAO,CAAA,MAAA,CAAO,OAAO,WAAY,CAAA,SAAS,GAAG,IAAI,CAAA,CAAA;AAAA,SACjE;AACA,QAAA,IAAI,KAAU,KAAA,MAAA;AAAQ,UAAO,OAAA,IAAI,KAAK,GAAG,CAAA,CAAA;AACzC,QAAA,IAAI,KAAU,KAAA,KAAA;AAAO,UAAO,OAAA,IAAI,IAAI,GAAG,CAAA,CAAA;AACvC,QAAA,IAAI,KAAU,KAAA,KAAA;AAAO,UAAA,OAAO,IAAI,GAAA,CAAI,MAAO,CAAA,OAAA,CAAQ,GAAG,CAAC,CAAA,CAAA;AACvD,QAAA,IAAI,KAAU,KAAA,QAAA;AAAU,UAAA,OAAO,OAAO,GAAG,CAAA,CAAA;AAGzC,QAAA,IAAI,KAAU,KAAA,WAAA;AAAa,UAAO,OAAA,KAAA,CAAA,CAAA;AAClC,QAAO,OAAA,IAAA,CAAA;AAAA,OACT;AACA,MAAO,OAAA,KAAA,CAAA;AAAA,KACR,CAAA,CAAA;AAAA,GACH;AACF,CAAA;AAEA,MAAM,iBAAA,GAAoB,IAAI,UAAW,EAAA,CAAA;AAK5B,MAAA,SAAA,GAAY,CAAI,IAAiC,KAAA;AAC5D,EAAO,OAAA,iBAAA,CAAkB,OAAO,IAAI,CAAA,CAAA;AACtC,EAAA;AAEa,MAAA,WAAA,GAAc,CAAkC,IAAmD,KAAA;AAC9G,EAAO,OAAA,iBAAA,CAAkB,SAAS,IAAI,CAAA,CAAA;AACxC;;ACjEO,SAAS,kBAA8B,MAA4B,EAAA;AACxE,EAAO,OAAA,SAAS,UACd,CAAA,IAAA,EACA,MACA,EAAA;AACA,IAAA,OAAO,UAAU,IAA4F,KAAA;AAC3G,MAAA,MAAM,GACJ,GAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,KAAa,gBACrB,CAA0B,uBAAA,EAAA,IAAI,CAC9B,CAAA,GAAA,CAAA,oCAAA,EAAuC,OAAO,SAAS,CAAA,CAAA,EAAI,MAAO,CAAA,MAAM,IAAI,IAAI,CAAA,CAAA,CAAA;AAEtF,MAAM,MAAA,MAAA,GAAS,MAAM,KAAA,CAAM,GAAK,EAAA;AAAA,QAC9B,MAAQ,EAAA,MAAA;AAAA,QACR,OAAA,EAAS,EAAE,cAAA,EAAgB,kBAAmB,EAAA;AAAA,QAC9C,IAAM,EAAA,SAAA,CAAU,EAAE,IAAA,EAAM,CAAA;AAAA,OACzB,CAAA,CAAA;AAID,MAAM,MAAA,IAAA,GAAO,MAAO,MAAA,CAAe,IAAK,EAAA,CAAA;AACxC,MAAA,OAAO,YAAiB,IAAI,CAAA,CAAA;AAAA,KAC9B,CAAA;AAAA,GACF,CAAA;AACF;;ACrCO,MAAM,kBAAkB,KAAM,CAAA;AAAA,EAGnC,WAAA,CAAY,SAAiB,MAAgB,EAAA;AAC3C,IAAA,KAAA,CAAM,OAAO,CAAA,CAAA;AACb,IAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AAAA,GAChB;AACF;;;;"}